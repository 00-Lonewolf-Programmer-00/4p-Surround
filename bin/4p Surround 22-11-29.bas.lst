------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm LEVEL 1 PASS 4
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 4
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; VCS.H
      4  8400 ????						; Version 1.05, 13/November/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_VCS =	105
      7  8400 ????
      8  8400 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines hardware registers and memory mapping for the
     13  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  8400 ????						; with your views.  Please contribute, if you think you can improve this
     21  8400 ????						; file!
     22  8400 ????						;
     23  8400 ????						; Latest Revisions...
     24  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  8400 ????						;			    This will allow conditional code to verify VCS.H being
     27  8400 ????						;			    used for code assembly.
     28  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  8400 ????						;			 mirrored reading/writing differences.	This is more a 
     31  8400 ????						;			 readability issue, and binary compatibility with disassembled
     32  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  8400 ????						;			 which was broken by the use of segments in this file, as
     35  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  8400 ????						;						   it is safe to leave it undefined, and the base address will
     40  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  8400 ????						;			  - register definitions are now generated through assignment
     43  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     44  8400 ????						;			    address architecture.
     45  8400 ????						; 1.0	22/MAR/2003		Initial release
     46  8400 ????
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????
     50  8400 ????						; TIA_BASE_ADDRESS
     51  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  8400 ????						; Normally 0, the base address should (externally, before including this file)
     53  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  8400 ????						; < $40 as a bankswitch.
     56  8400 ????
     57  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  8400 ????			  -TIA_BASE_ADDRESS =	0
     59  8400 ????				      ENDIF
     60  8400 ????
     61  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  8400 ????						; *OR* by declaring the label before including this file, eg:
     64  8400 ????						; TIA_BASE_ADDRESS = $40
     65  8400 ????						;   include "vcs.h"
     66  8400 ????
     67  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  8400 ????						; for the mirrored ROM hardware registers.
     70  8400 ????
     71  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  8400 ????
     75  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  8400 ????				      ENDIF
     78  8400 ????
     79  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  8400 ????				      ENDIF
     82  8400 ????
     83  8400 ????						;-------------------------------------------------------------------------------
     84  8400 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  8400 ????				      SEG
    201  8400 ????
    202  8400 ????						; EOF
------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm
------- FILE macro.h LEVEL 2 PASS 4
      0  8400 ????				      include	"macro.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; MACRO.H
      4  8400 ????						; Version 1.05, 13/NOVEMBER/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_MACRO =	105
      7  8400 ????
      8  8400 ????						;
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  8400 ????						; It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  8400 ????						; contents, or would like to add something, please write to me
     19  8400 ????						; (atari2600@taswegian.com) with your contribution.
     20  8400 ????						;
     21  8400 ????						; Latest Revisions...
     22  8400 ????						;
     23  8400 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  8400 ????						;			    This will allow conditional code to verify MACRO.H being
     25  8400 ????						;			    used for code assembly.
     26  8400 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  8400 ????						;
     28  8400 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  8400 ????						;
     30  8400 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  8400 ????						;			   (standardised macro for vertical synch code)
     32  8400 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  8400 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  8400 ????						; 1.0	22/MAR/2003		Initial release
     35  8400 ????
     36  8400 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  8400 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  8400 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  8400 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  8400 ????						;   registers and require them to be defined first).
     41  8400 ????
     42  8400 ????						; Available macros...
     43  8400 ????						;   SLEEP n		 - sleep for n cycles
     44  8400 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  8400 ????						;   CLEAN_START	 - set machine to known state on startup
     46  8400 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????						; SLEEP duration
     50  8400 ????						; Original author: Thomas Jentzsch
     51  8400 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  8400 ????						; useful for code where precise timing is required.
     53  8400 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  8400 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  8400 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  8400 ????
     57  8400 ????				      MAC	sleep
     58  8400 ????			   .CYCLES    SET	{1}
     59  8400 ????
     60  8400 ????				      IF	.CYCLES < 2
     61  8400 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  8400 ????				      ERR
     63  8400 ????				      ENDIF
     64  8400 ????
     65  8400 ????				      IF	.CYCLES & 1
     66  8400 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  8400 ????				      nop	0
     68  8400 ????				      ELSE
     69  8400 ????				      bit	VSYNC
     70  8400 ????				      ENDIF
     71  8400 ????			   .CYCLES    SET	.CYCLES - 3
     72  8400 ????				      ENDIF
     73  8400 ????
     74  8400 ????				      REPEAT	.CYCLES / 2
     75  8400 ????				      nop
     76  8400 ????				      REPEND
     77  8400 ????				      ENDM		;usage: SLEEP n (n>1)
     78  8400 ????
     79  8400 ????						;-------------------------------------------------------------------------------
     80  8400 ????						; VERTICAL_SYNC
     81  8400 ????						; Original author: Manuel Polik
     82  8400 ????						; Inserts the code required for a proper 3 scannline 
     83  8400 ????						; vertical sync sequence
     84  8400 ????						;
     85  8400 ????						; Note: Alters the accumulator
     86  8400 ????						;
     87  8400 ????						; IN:
     88  8400 ????						; OUT: A = 1
     89  8400 ????
     90  8400 ????				      MAC	vertical_sync
     91  8400 ????				      LDA	#$02	; A = VSYNC enable
     92  8400 ????				      STA	WSYNC	; Finish current line
     93  8400 ????				      STA	VSYNC	; Start vertical sync
     94  8400 ????				      STA	WSYNC	; 1st line vertical sync
     95  8400 ????				      STA	WSYNC	; 2nd line vertical sync
     96  8400 ????				      LSR		; A = VSYNC disable
     97  8400 ????				      STA	WSYNC	; 3rd line vertical sync
     98  8400 ????				      STA	VSYNC	; Stop vertical sync
     99  8400 ????				      ENDM
    100  8400 ????
    101  8400 ????						;-------------------------------------------------------------------------------
    102  8400 ????						; CLEAN_START
    103  8400 ????						; Original author: Andrew Davie
    104  8400 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  8400 ????						; Sets stack pointer to $FF, and all registers to 0
    106  8400 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  8400 ????						; Use as very first section of code on boot (ie: at reset)
    108  8400 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  8400 ????
    110  8400 ????				      MAC	clean_start
    111  8400 ????				      sei
    112  8400 ????				      cld
    113  8400 ????
    114  8400 ????				      ldx	#0
    115  8400 ????				      txa
    116  8400 ????				      tay
    117  8400 ????			   .CLEAR_STACK dex
    118  8400 ????				      txs
    119  8400 ????				      pha
    120  8400 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  8400 ????
    122  8400 ????				      ENDM
    123  8400 ????
    124  8400 ????						;-------------------------------------------------------
    125  8400 ????						; SET_POINTER
    126  8400 ????						; Original author: Manuel Rotschkar
    127  8400 ????						;
    128  8400 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  8400 ????						;
    130  8400 ????						; Usage: SET_POINTER pointer, address
    131  8400 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  8400 ????						;
    133  8400 ????						; Note: Alters the accumulator, NZ flags
    134  8400 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  8400 ????						; IN 2: absolute address
    136  8400 ????
    137  8400 ????				      MAC	set_pointer
    138  8400 ????			   .POINTER   SET	{1}
    139  8400 ????			   .ADDRESS   SET	{2}
    140  8400 ????
    141  8400 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  8400 ????				      STA	.POINTER	; Store in pointer
    143  8400 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  8400 ????				      STA	.POINTER+1	; Store in pointer+1
    145  8400 ????
    146  8400 ????				      ENDM
    147  8400 ????
    148  8400 ????						; EOF
------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm
------- FILE DPCplus.h LEVEL 2 PASS 4
      0  8400 ????				      include	"DPCplus.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; DPCplus.H - Display Processor Chip Plus Definitions
      4  8400 ????						; Chris Walton, Fred Quimby, Darrell Spice 2010
      5  8400 ????						; Version 0.00
      6  8400 ????
      7  8400 ????						; DPC Base Address
      8  8400 ????			  -	      IFNCONST	DPC_BASE_ADDRESS
      9  8400 ????			  -DPC_BASE_ADDRESS =	$1000
     10  8400 ????				      ENDIF
     11  8400 ????
     12  8400 ????						; DPC Read Base
     13  8400 ????			  -	      IFNCONST	DPC_BASE_READ_ADDRESS
     14  8400 ????			  -DPC_BASE_READ_ADDRESS =	DPC_BASE_ADDRESS
     15  8400 ????				      ENDIF
     16  8400 ????
     17  8400 ????						; DPC Write Base
     18  8400 ????			  -	      IFNCONST	DPC_BASE_WRITE_ADDRESS
     19  8400 ????			  -DPC_BASE_WRITE_ADDRESS =	DPC_BASE_ADDRESS+$28
     20  8400 ????				      ENDIF
     21  8400 ????
     22 U1028 ????				      SEG.U	DPC_REGISTERS_READ
     23 U1000					      ORG	DPC_BASE_READ_ADDRESS
     24 U1000
     25 U1000							;****************************************
     26 U1000							; DPC+ Read Registers
     27 U1000							;****************************************
     28 U1000							;
     29 U1000							;----------------------------------------
     30 U1000							; Random Numbers
     31 U1000							;----------------------------------------
     32 U1000							; DPC+ provides a 32 bit LFSR (Linear feedback shift register)
     33 U1000							; which is used as a random number generator.	Each individual byte of the
     34 U1000							; random number will return values from 0-255.  The random numbers will follow
     35 U1000							; an exact sequence, so it's best to clock them at least once per frame even if 
     36 U1000							; you don't need the value (this allows the amount of time it takes the user to
     37 U1000							; start the game to select a random starting point in the sequence)
     38 U1000							;----------------------------------------
     39 U1000		       00	   RANDOM0NEXT DS	1	; $00 clock next 32 bit number and returns byte 0
     40 U1001		       00	   RANDOM0PRIOR DS	1	; $01 clock prior 32 bit number and returns byte 0
     41 U1002		       00	   RANDOM1    DS	1	; $02 returns byte 1 of random number w/out clock
     42 U1003		       00	   RANDOM2    DS	1	; $03 returns byte 2 of random number w/out clock
     43 U1004		       00	   RANDOM3    DS	1	; $04 returns byte 3 of random number w/out clock
     44 U1005
     45 U1005							;----------------------------------------
     46 U1005							; Music Fetcher
     47 U1005							;----------------------------------------
     48 U1005							; When generating music, this value must be read every single scanline and
     49 U1005							; stored into AUDV0.
     50 U1005							;----------------------------------------
     51 U1005		       00	   AMPLITUDE  DS	1	; $05
     52 U1006
     53 U1006							;----------------------------------------
     54 U1006							; Reserved
     55 U1006							;----------------------------------------
     56 U1006		       00		      DS	1	; $06
     57 U1007		       00		      DS	1	; $07
     58 U1008
     59 U1008							;----------------------------------------
     60 U1008							; Data Fetcher
     61 U1008							;----------------------------------------
     62 U1008							; There are 8 Data Fetchers which are used to access data stored in the Display
     63 U1008							; Data bank.  Before using, you must point the Data Fetcher at the data to read
     64 U1008							; via DFxLOW and DFxHI.  After each read the Data Fetcher will update to point
     65 U1008							; to the next byte of data to return.
     66 U1008							;
     67 U1008							; psuedo code* to point Data Fetcher 1 to the color data
     68 U1008							;	lda #<(ColorDataPosition - HowFarDownScreen)
     69 U1008							;	sta DF1LOW
     70 U1008							;	lda #>(ColorDataPosition - HowFarDownScreen)
     71 U1008							;	sta DF1HI 
     72 U1008							;	....
     73 U1008							; then in the kernel read the Data Fetcher and update the color, takes 7 cycles
     74 U1008							;	LDA DF1DATA
     75 U1008							;	STA COLUP0
     76 U1008							;
     77 U1008							; * see DPCplus.asm for actual code
     78 U1008							;----------------------------------------
     79 U1008		       00	   DF0DATA    DS	1	; $08
     80 U1009		       00	   DF1DATA    DS	1	; $09
     81 U100a		       00	   DF2DATA    DS	1	; $0A
     82 U100b		       00	   DF3DATA    DS	1	; $0B
     83 U100c		       00	   DF4DATA    DS	1	; $0C
     84 U100d		       00	   DF5DATA    DS	1	; $0D
     85 U100e		       00	   DF6DATA    DS	1	; $0E
     86 U100f		       00	   DF7DATA    DS	1	; $0F
     87 U1010
     88 U1010							;----------------------------------------
     89 U1010							; Data Fetcher, Windowed
     90 U1010							;----------------------------------------
     91 U1010							; The 8 Data Fetchers can also be read in a "windowed" mode, which is most
     92 U1010							; commonly used to update sprites.  To use windowed mode, point the Data
     93 U1010							; Fetcher the same as above, but then also set the Top and Bottom of the
     94 U1010							; Window using DFxTOP and DFxBOT.  When reading via the DFxDATAW registers, a 0
     95 U1010							; value will be returned for anything that's outside of the window.
     96 U1010							;
     97 U1010							; psuedo code to point Data Fetcher0 to the sprite data
     98 U1010							;	lda #<(SpriteDataPosition - HowFarDownScreen)
     99 U1010							;	sta DF0LOW
    100 U1010							;	lda #>(SpriteDataPosition - HowFarDownScreen)
    101 U1010							;	sta DF0HI
    102 U1010							;	
    103 U1010							; set the window for Data Fetcher 0
    104 U1010							;	lda #<(SpriteDataPosition - 1)
    105 U1010							;	sta DF0TOP
    106 U1010							;	lda #<(SpriteDataPosition + ImageHeight)
    107 U1010							;	sta DF0BOT
    108 U1010							;	....
    109 U1010							; then in the kernel read the Data Fetcher and update the sprite, takes 7 cycles
    110 U1010							;	LDA DF0DATAW
    111 U1010							;	STA GRP0
    112 U1010							;----------------------------------------
    113 U1010		       00	   DF0DATAW   DS	1	; $10
    114 U1011		       00	   DF1DATAW   DS	1	; $11
    115 U1012		       00	   DF2DATAW   DS	1	; $12
    116 U1013		       00	   DF3DATAW   DS	1	; $13
    117 U1014		       00	   DF4DATAW   DS	1	; $14
    118 U1015		       00	   DF5DATAW   DS	1	; $15
    119 U1016		       00	   DF6DATAW   DS	1	; $16
    120 U1017		       00	   DF7DATAW   DS	1	; $17
    121 U1018
    122 U1018							;----------------------------------------
    123 U1018							; Fractional Data Fetcher
    124 U1018							;----------------------------------------
    125 U1018							; Another 8 Data Fetchers exist which work differently than the first 8.
    126 U1018							; These allow you to fractionally increment the Data Fetcher so a single
    127 U1018							; value can be read a set number of times before advancing to the next value.
    128 U1018							; This is commonly used to draw asymmetrical playfields without needing to 
    129 U1018							; use 1200 bytes of data (200 scanlines * 6 playfield updates).
    130 U1018							; Before using, you must point the Fractional Data Fetcher at the data to read
    131 U1018							; via DFxFRACLOW and DFxFRACHI.  You must also set the increment value via
    132 U1018							; DFxFRACINC.
    133 U1018							;
    134 U1018							; Set pointer
    135 U1018							;	LDA #<PlayfieldPF0l
    136 U1018							;	STA DF0FRACLOW
    137 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    138 U1018							;	lda #>PlayFieldPF0l
    139 U1018							;	STA DF0FRACHI
    140 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    141 U1018							; Set the increment to repeat the value for x reads
    142 U1018							;	LDA #(256/x)
    143 U1018							;	STA DF0FRACINC
    144 U1018							;	 STA DF1FRACINC
    145 U1018							;	... repeat for 2-5
    146 U1018							;
    147 U1018							; Special Condition - IF you want to increment the pointer after every read 
    148 U1018							; (just like the normal Data Fetcher), then use the following to set the
    149 U1018							; increment AND prime the Fractional Data Fetcher
    150 U1018							;	LDA #255
    151 U1018							;	STA DF0FRACINC
    152 U1018							;	 STA DF1FRACINC
    153 U1018							;	... repeat for 2-5
    154 U1018							;	LDA DF0FRACDATA - priming read (first value will be read twice)
    155 U1018							;	LDA DF1FRACDATA - priming read (first value will be read twice)
    156 U1018							;	... repeat for 2-5
    157 U1018							;
    158 U1018							; then in the kernel read the Fractional Data Fetchers and update the playfield
    159 U1018							;	LDA DF0FRACDATA
    160 U1018							;	STA PF0
    161 U1018							;	LDA PF1FRACDATA
    162 U1018							;	STA PF1
    163 U1018							;	... repeat for Data Fetchers 2-5, putting them in PF2, PF0, PF1 and PF2
    164 U1018							;----------------------------------------
    165 U1018		       00	   DF0FRACDATA DS	1	; $18
    166 U1019		       00	   DF1FRACDATA DS	1	; $19
    167 U101a		       00	   DF2FRACDATA DS	1	; $1A
    168 U101b		       00	   DF3FRACDATA DS	1	; $1B
    169 U101c		       00	   DF4FRACDATA DS	1	; $1C
    170 U101d		       00	   DF5FRACDATA DS	1	; $1D
    171 U101e		       00	   DF6FRACDATA DS	1	; $1E
    172 U101f		       00	   DF7FRACDATA DS	1	; $1F
    173 U1020
    174 U1020							;----------------------------------------
    175 U1020							; Data Fetcher Window Flag
    176 U1020							;----------------------------------------
    177 U1020							; The Data Fetcher Window Flag allows you to dual-purpose the first four
    178 U1020							; Data Fetchers.  The Window is not required when a Data Fetcher is used to
    179 U1020							; update a sprite's color.  The Flag will return $FF if it's within the window,
    180 U1020							; or 0 if it's not - this value can be used to control the display of the ball
    181 U1020							; and missiles. The Data Fetcher will NOT increment when reading the flag.
    182 U1020							;
    183 U1020							; psuedo code to point Data Fetcher 1 to the color data
    184 U1020							;	lda #<(ColorDataPosition - HowFarDownScreen)
    185 U1020							;	sta DF1LOW
    186 U1020							;	lda #>(ColorDataPosition - HowFarDownScreen)
    187 U1020							;	sta DF1HI
    188 U1020							;
    189 U1020							; set the window based on the missile's Y position and height (number of
    190 U1020							; scanlines to draw missile on)
    191 U1020							;	lda #<(ColorDataPosition + MissileYposition - 1)
    192 U1020							;	sta DF1TOP
    193 U1020							;	lda #<(ColorDataPosition + MissileYposition + MissileHeight)
    194 U1020							;	sta DF1BOT
    195 U1020							;
    196 U1020							; then in the kernel read the Data Fetcher and update the color, then read the
    197 U1020							; flag and update the missile
    198 U1020							;	LDA DF1DATA
    199 U1020							;	STA COLUP0
    200 U1020							;	LDA DF1FLAG
    201 U1020							;	STA ENAM0
    202 U1020							;----------------------------------------
    203 U1020		       00	   DF0FLAG    DS	1	; $20
    204 U1021		       00	   DF1FLAG    DS	1	; $21
    205 U1022		       00	   DF2FLAG    DS	1	; $22
    206 U1023		       00	   DF3FLAG    DS	1	; $23
    207 U1024
    208 U1024							;----------------------------------------
    209 U1024							; Reserved
    210 U1024							;----------------------------------------
    211 U1024		       00		      DS	1	; $24
    212 U1025		       00		      DS	1	; $25
    213 U1026		       00		      DS	1	; $26
    214 U1027		       00		      DS	1	; $27
    215 U1028
    216 U1028
    217 U1080 ????				      SEG.U	DPC_REGISTERS_WRITE
    218 U1028					      ORG	DPC_BASE_WRITE_ADDRESS
    219 U1028
    220 U1028							;****************************************
    221 U1028							; SECTION 2 - DPC+ Write Registers
    222 U1028							;****************************************
    223 U1028							;
    224 U1028							;----------------------------------------
    225 U1028							; Fractional Data Fetcher, Low Pointer
    226 U1028							;----------------------------------------
    227 U1028							; These are used in conjunction with DFxFRACHI to point a Fractional Data
    228 U1028							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    229 U1028							; in SECTION 1.
    230 U1028							;----------------------------------------
    231 U1028		       00	   DF0FRACLOW DS	1	; $28
    232 U1029		       00	   DF1FRACLOW DS	1	; $29
    233 U102a		       00	   DF2FRACLOW DS	1	; $2A
    234 U102b		       00	   DF3FRACLOW DS	1	; $2B
    235 U102c		       00	   DF4FRACLOW DS	1	; $2C
    236 U102d		       00	   DF5FRACLOW DS	1	; $2D
    237 U102e		       00	   DF6FRACLOW DS	1	; $2E
    238 U102f		       00	   DF7FRACLOW DS	1	; $2F
    239 U1030
    240 U1030							;----------------------------------------
    241 U1030							; Fractional Data Fetcher, High Pointer
    242 U1030							;----------------------------------------
    243 U1030							; These are used in conjunction with DFxFRACLOW to point a Fractional Data
    244 U1030							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    245 U1030							; in SECTION 1.
    246 U1030							;
    247 U1030							; NOTE: for only the lower 4 bits are used.
    248 U1030							;----------------------------------------
    249 U1030		       00	   DF0FRACHI  DS	1	; $30
    250 U1031		       00	   DF1FRACHI  DS	1	; $31
    251 U1032		       00	   DF2FRACHI  DS	1	; $32
    252 U1033		       00	   DF3FRACHI  DS	1	; $33
    253 U1034		       00	   DF4FRACHI  DS	1	; $34
    254 U1035		       00	   DF5FRACHI  DS	1	; $35 
    255 U1036		       00	   DF6FRACHI  DS	1	; $36 
    256 U1037		       00	   DF7FRACHI  DS	1	; $37 
    257 U1038
    258 U1038							;----------------------------------------
    259 U1038							; Fractional Data Fetcher, Increment
    260 U1038							;----------------------------------------
    261 U1038							; These are used to set the increment amount for the Fractional Data Fetcher.
    262 U1038							; To increment pointer after every Xth read use int(256/X)
    263 U1038							; For usage, see "Fractional Data Fetcher" in SECTION 1.
    264 U1038							;----------------------------------------
    265 U1038		       00	   DF0FRACINC DS	1	; $38
    266 U1039		       00	   DF1FRACINC DS	1	; $39
    267 U103a		       00	   DF2FRACINC DS	1	; $3A
    268 U103b		       00	   DF3FRACINC DS	1	; $3B
    269 U103c		       00	   DF4FRACINC DS	1	; $3C
    270 U103d		       00	   DF5FRACINC DS	1	; $3D
    271 U103e		       00	   DF6FRACINC DS	1	; $3E
    272 U103f		       00	   DF7FRACINC DS	1	; $3F
    273 U1040
    274 U1040							;----------------------------------------
    275 U1040							; Data Fetcher, Window Top
    276 U1040							;----------------------------------------
    277 U1040							; These are used with DFxBOT to define the Data Fetcher Window
    278 U1040							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    279 U1040							;----------------------------------------
    280 U1040		       00	   DF0TOP     DS	1	; $40
    281 U1041		       00	   DF1TOP     DS	1	; $41
    282 U1042		       00	   DF2TOP     DS	1	; $42
    283 U1043		       00	   DF3TOP     DS	1	; $43
    284 U1044		       00	   DF4TOP     DS	1	; $44
    285 U1045		       00	   DF5TOP     DS	1	; $45
    286 U1046		       00	   DF6TOP     DS	1	; $46
    287 U1047		       00	   DF7TOP     DS	1	; $47
    288 U1048
    289 U1048							;----------------------------------------
    290 U1048							; Data Fetcher, Window Bottom
    291 U1048							;----------------------------------------
    292 U1048							; These are used with DFxTOP to define the Data Fetcher Window
    293 U1048							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    294 U1048							;----------------------------------------
    295 U1048		       00	   DF0BOT     DS	1	; $48
    296 U1049		       00	   DF1BOT     DS	1	; $49
    297 U104a		       00	   DF2BOT     DS	1	; $4A
    298 U104b		       00	   DF3BOT     DS	1	; $4B
    299 U104c		       00	   DF4BOT     DS	1	; $4C
    300 U104d		       00	   DF5BOT     DS	1	; $4D
    301 U104e		       00	   DF6BOT     DS	1	; $4E
    302 U104f		       00	   DF7BOT     DS	1	; $4F
    303 U1050
    304 U1050							;----------------------------------------
    305 U1050							; Data Fetcher, Low Pointer
    306 U1050							;----------------------------------------
    307 U1050							; These are used in conjunction with DFxHI to point a Data Fetcher to the data
    308 U1050							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    309 U1050							;----------------------------------------
    310 U1050		       00	   DF0LOW     DS	1	; $50
    311 U1051		       00	   DF1LOW     DS	1	; $51
    312 U1052		       00	   DF2LOW     DS	1	; $52
    313 U1053		       00	   DF3LOW     DS	1	; $53
    314 U1054		       00	   DF4LOW     DS	1	; $54
    315 U1055		       00	   DF5LOW     DS	1	; $55
    316 U1056		       00	   DF6LOW     DS	1	; $56
    317 U1057		       00	   DF7LOW     DS	1	; $57
    318 U1058
    319 U1058							;----------------------------------------
    320 U1058							; Fast Fetch Mode
    321 U1058							;----------------------------------------
    322 U1058							; Fast Fetch Mode enables the fastest way to read DPC+ registers.  Normal
    323 U1058							; reads use LDA Absolute addressing (LDA DF0DATA) which takes 4 cycles to
    324 U1058							; process.  Fast Fetch Mode intercepts LDA Immediate addressing (LDA #<DF0DATA)
    325 U1058							; which takes only 2 cycles!  Only immediate values < $28 are intercepted
    326 U1058							; 
    327 U1058							; set Fast Fetch Mode
    328 U1058							;	LDA #0
    329 U1058							;	STA FASTFETCH
    330 U1058							;
    331 U1058							; then use immediate mode to read the registers, takes just 5 cycles to update
    332 U1058							; any TIA register
    333 U1058							;
    334 U1058							;	LDA #<DF0DATA
    335 U1058							;	STA GRP0
    336 U1058							;
    337 U1058							; when done, turn off Fast Fetch Mode using any non-zero value
    338 U1058							;	LDA #$FF
    339 U1058							;	STA FASTFETCH
    340 U1058							;
    341 U1058							; NOTE: if you forget to turn off FASTFETCH mode, then code like this will not
    342 U1058							;	 work as you expect
    343 U1058							;	LDA #0	; returns a RANDOM NUMBER, not 0.
    344 U1058							;	STA COLUPF
    345 U1058							;----------------------------------------
    346 U1058		       00	   FASTFETCH  DS	1	; $58
    347 U1059
    348 U1059							;----------------------------------------
    349 U1059							; Function Support
    350 U1059							;----------------------------------------
    351 U1059							; Currently only Function 255 is defined, and it is used to call user
    352 U1059							; written ARM routines (or C code compiled for the ARM processor.)
    353 U1059							;
    354 U1059							; PARAMETER is not used by function 255, it may be used by future functions.
    355 U1059							; 
    356 U1059							; call custom ARM routine
    357 U1059							;	LDA #$FF
    358 U1059							;	STA CALLFUNCTION
    359 U1059							;
    360 U1059							; A custom ARM demo will be released in the near future
    361 U1059							;----------------------------------------
    362 U1059		       00	   PARAMETER  DS	1	; $59
    363 U105a		       00	   CALLFUNCTION DS	1	; $5A
    364 U105b
    365 U105b							;----------------------------------------
    366 U105b							; Reserved
    367 U105b							;----------------------------------------
    368 U105b		       00		      DS	1	; $5B	 ; reserved
    369 U105c		       00		      DS	1	; $5C	 ; reserved
    370 U105d
    371 U105d							;----------------------------------------
    372 U105d							; Waveforms
    373 U105d							;----------------------------------------
    374 U105d							; Waveforms are 32 byte tables that define a waveform.  Waveforms must be 32
    375 U105d							; byte aligned, and can only be stored in the 4K Display Data Bank. You MUST
    376 U105d							; define an "OFF" waveform,  comprised of all zeros.  The sum of all waveforms
    377 U105d							; being played should be <= 15, so typically you'll use a maximum of 5 for any
    378 U105d							; given value.
    379 U105d							;
    380 U105d							; Valid values are 0-127 and point to the 4K Display Data bank.  The formula
    381 U105d							; (* & $1fff)/32 as shown below will calculate the value for you
    382 U105d							;
    383 U105d							;
    384 U105d							; example waveforms
    385 U105d							;	align 32		; forces the waveform to a 32 byte boundary
    386 U105d							;SOUND_OFF = (* & $1fff)/32	; calculates waveform pointer
    387 U105d							;	.byte 0,0,0,0,0,0,0,0
    388 U105d							;	.byte 0,0,0,0,0,0,0,0
    389 U105d							;	.byte 0,0,0,0,0,0,0,0
    390 U105d							;	.byte 0,0,0,0,0,0,0,0 
    391 U105d							; 
    392 U105d							;	align 32
    393 U105d							;SINE_WAVE = (* & $1fff)/32
    394 U105d							;	.byte 3,3,3,4,4,5,5,5
    395 U105d							;	.byte 5,5,5,5,4,4,3,3
    396 U105d							;	.byte 3,2,2,1,1,0,0,0
    397 U105d							;	.byte 0,0,0,0,1,1,2,2 
    398 U105d							;
    399 U105d							; usage, set voice 0 to Sine Wave, set voice 1 & 2 off
    400 U105d							;	LDA #SINE_WAVE
    401 U105d							;	STA WAVEFORM0
    402 U105d							;	LDA #SOUND_OFF
    403 U105d							;	STA WAVEFORM1
    404 U105d							;	STA WAVEFORM2	
    405 U105d							;----------------------------------------
    406 U105d		       00	   WAVEFORM0  DS	1	; $5D
    407 U105e		       00	   WAVEFORM1  DS	1	; $5E
    408 U105f		       00	   WAVEFORM2  DS	1	; $5F
    409 U1060
    410 U1060							;----------------------------------------
    411 U1060							; Data Fetcher Push (stack)
    412 U1060							;----------------------------------------
    413 U1060							; The Data Fetchers can also be used to update the contents of the 4K
    414 U1060							; Display Data bank.  Point the Data Fetcher to the data to change,
    415 U1060							; then Push to it.  The Data Fetcher's pointer will be decremented BEFORE
    416 U1060							; the data is written.
    417 U1060							;
    418 U1060							; point Data Fetcher 1 to the sprite data
    419 U1060							;	lda #<DisplayData
    420 U1060							;	sta DF1LOW
    421 U1060							;	lda #>DisplayData
    422 U1060							;	sta DF1HI 
    423 U1060							;
    424 U1060							; then update it
    425 U1060							;	LDA #$FF
    426 U1060							;	STA DF1PUSH ; changes data at DisplayData - 1
    427 U1060							;	LDA #$81
    428 U1060							;	STA DF1OUSH ; changes data at DisplayData - 2
    429 U1060							;----------------------------------------
    430 U1060		       00	   DF0PUSH    DS	1	; $60
    431 U1061		       00	   DF1PUSH    DS	1	; $61
    432 U1062		       00	   DF2PUSH    DS	1	; $62
    433 U1063		       00	   DF3PUSH    DS	1	; $63
    434 U1064		       00	   DF4PUSH    DS	1	; $64
    435 U1065		       00	   DF5PUSH    DS	1	; $65
    436 U1066		       00	   DF6PUSH    DS	1	; $66
    437 U1067		       00	   DF7PUSH    DS	1	; $67
    438 U1068
    439 U1068							;----------------------------------------
    440 U1068							; Data Fetcher, High Pointer
    441 U1068							;----------------------------------------
    442 U1068							; These are used in conjunction with DFxLOW to point a Data Fetcher to the data
    443 U1068							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    444 U1068							;----------------------------------------
    445 U1068		       00	   DF0HI      DS	1	; $68
    446 U1069		       00	   DF1HI      DS	1	; $69
    447 U106a		       00	   DF2HI      DS	1	; $6A
    448 U106b		       00	   DF3HI      DS	1	; $6B
    449 U106c		       00	   DF4HI      DS	1	; $6C
    450 U106d		       00	   DF5HI      DS	1	; $6D 
    451 U106e		       00	   DF6HI      DS	1	; $6E 
    452 U106f		       00	   DF7HI      DS	1	; $6F 
    453 U1070
    454 U1070							;----------------------------------------
    455 U1070							; Random Number Initialization
    456 U1070							;----------------------------------------
    457 U1070							; The random number generate defaults to a value that spells out DPC+.
    458 U1070							; Store any value to RRESET to set the random number back to DPC+, or you
    459 U1070							; can use RWRITE0-3 to change the 32 bit value to anything you desire.
    460 U1070							;
    461 U1070							; reset random number
    462 U1070							;	LDA #0
    463 U1070							;	STA RRESET
    464 U1070							;
    465 U1070							; set a specific random number (spells out 2600)
    466 U1070							;	LDA #$32
    467 U1070							;	STA RWRITE0
    468 U1070							;	LDA #$36
    469 U1070							;	STA RWRITE1
    470 U1070							;	LDA #$30
    471 U1070							;	STA RWRITE2
    472 U1070							;	STA RWRITE3
    473 U1070							;
    474 U1070							; NOTE: do not set all 4 bytes to 0, as that will disable the generator.
    475 U1070							;----------------------------------------
    476 U1070		       00	   RRESET     DS	1	; $70
    477 U1071		       00	   RWRITE0    DS	1	; $71
    478 U1072		       00	   RWRITE1    DS	1	; $72
    479 U1073		       00	   RWRITE2    DS	1	; $73
    480 U1074		       00	   RWRITE3    DS	1	; $74
    481 U1075
    482 U1075							;----------------------------------------
    483 U1075							; Notes
    484 U1075							;----------------------------------------
    485 U1075							; These are used to select a value from the frequency table to play.
    486 U1075							; The default table, store in DPC_frequencies.h, only defines frequencies
    487 U1075							; for 1-88, which cover the keys of a piano.  You are free to add additional
    488 U1075							; frequencies from 88-255.  Piano keys are defined at the end of this file
    489 U1075							;
    490 U1075							; set voice 0 to middle C
    491 U1075							;	LDA #C4
    492 U1075							;	STA NOTE0
    493 U1075							;
    494 U1075							; Note: if you are using ARM USER CODE then you can only use notes to 128.
    495 U1075							;----------------------------------------
    496 U1075		       00	   NOTE0      DS	1	; $75
    497 U1076		       00	   NOTE1      DS	1	; $76
    498 U1077		       00	   NOTE2      DS	1	; $77
    499 U1078
    500 U1078							;----------------------------------------
    501 U1078							; Data Fetcher Write (queue)
    502 U1078							;----------------------------------------
    503 U1078							; The Data Fetchers can also be used to update the contents of the 4K
    504 U1078							; Display Data bank.  Point the Data Fetcher to the data to change,
    505 U1078							; then Write to it  The Data Fetcher's pointer will be incremented AFTER
    506 U1078							; the data is written.
    507 U1078							;
    508 U1078							; point Data Fetcher 1 to the sprite data
    509 U1078							;	lda #<SpriteData
    510 U1078							;	sta DF1LOW
    511 U1078							;	lda #>SpriteData
    512 U1078							;	sta DF1HI 
    513 U1078							;
    514 U1078							; then update it
    515 U1078							;	LDA #$FF
    516 U1078							;	STA DF1WRITE ; changes data at SpriteData
    517 U1078							;	LDA #$81
    518 U1078							;	STA DF1WRITE ; changes data at SpriteData + 1
    519 U1078							;----------------------------------------
    520 U1078		       00	   DF0WRITE   DS	1	; $78
    521 U1079		       00	   DF1WRITE   DS	1	; $79
    522 U107a		       00	   DF2WRITE   DS	1	; $7A
    523 U107b		       00	   DF3WRITE   DS	1	; $7B
    524 U107c		       00	   DF4WRITE   DS	1	; $7C
    525 U107d		       00	   DF5WRITE   DS	1	; $7D
    526 U107e		       00	   DF6WRITE   DS	1	; $7E
    527 U107f		       00	   DF7WRITE   DS	1	; $7F
    528 U1080
    529 U1080							;-------------------------------------------------------------------------------
    530 U1080							; The following required for back-compatibility with code which does not use
    531 U1080							; segments.
    532 U1080
    533  8400 ????				      SEG
------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm
------- FILE DPCplusbB.h LEVEL 2 PASS 4
      0  8400 ????				      include	"DPCplusbB.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3 U00f5 ????				      SEG.U	vars
      4 U0080					      org	$80
      5 U0080		       00	   player0x   ds	1
      6 U0081		       00	   topP1x     ds	1
      7 U0082		       00	   missile0x  ds	1
      8 U0083		       00	   missile1x  ds	1
      9 U0084		       00	   ballx      ds	1
     10 U0085
     11 U0085		       00 00 00 00*SpriteGfxIndex ds	9
     12 U008e
     13 U008e		       00	   spritedisplay ds	1
     14 U008f
     15 U008f		       00	   player0xcoll ds	1	; to detect p0x colls
     16 U0090		       00	   NewSpriteX ds	1	;		X position
     17 U0090		       00 90	   player1x   =	NewSpriteX
     18 U0091		       00	   player2x   ds	1
     19 U0092		       00	   player3x   ds	1
     20 U0093		       00	   player4x   ds	1
     21 U0094		       00	   player5x   ds	1
     22 U0095		       00	   player6x   ds	1
     23 U0096		       00	   player7x   ds	1
     24 U0097		       00	   player8x   ds	1
     25 U0098		       00	   player9x   ds	1
     26 U0099
     27 U0099		       00	   player0y   ds	1
     28 U009a		       00	   NewSpriteY ds	1	;		Y position
     29 U009a		       00 9a	   player1y   =	NewSpriteY
     30 U009b		       00	   player2y   ds	1
     31 U009c		       00	   player3y   ds	1
     32 U009d		       00	   player4y   ds	1
     33 U009e		       00	   player5y   ds	1
     34 U009f		       00	   player6y   ds	1
     35 U00a0		       00	   player7y   ds	1
     36 U00a1		       00	   player8y   ds	1
     37 U00a2		       00	   player9y   ds	1
     38 U00a3
     39 U00a3		       00 00	   player0color ds	2
     40 U00a5
     41 U00a5		       00	   player0height ds	1
     42 U00a6		       00	   player1height ds	1
     43 U00a7		       00	   player2height ds	1
     44 U00a8		       00	   player3height ds	1
     45 U00a9		       00	   player4height ds	1
     46 U00aa		       00	   player5height ds	1
     47 U00ab		       00	   player6height ds	1
     48 U00ac		       00	   player7height ds	1
     49 U00ad		       00	   player8height ds	1
     50 U00ae		       00	   player9height ds	1
     51 U00af
     52 U00af		       00	   _NUSIZ1    ds	1
     53 U00b0		       00	   NUSIZ2     ds	1
     54 U00b1		       00	   NUSIZ3     ds	1
     55 U00b2		       00	   NUSIZ4     ds	1
     56 U00b3		       00	   NUSIZ5     ds	1
     57 U00b4		       00	   NUSIZ6     ds	1
     58 U00b5		       00	   NUSIZ7     ds	1
     59 U00b6		       00	   NUSIZ8     ds	1
     60 U00b7		       00	   NUSIZ9     ds	1
     61 U00b8
     62 U00b8		       00 00 00    score      ds	3
     63 U00bb		       00	   COLUM0     ds	1
     64 U00bc		       00	   COLUM1     ds	1
     65 U00bd		       00	   player0pointerlo ds	1
     66 U00be		       00	   player0pointerhi ds	1
     67 U00bf
     68 U00bf		       00 85	   RAMcopybegin =	SpriteGfxIndex
     69 U00bf		       00 3a	   RAMcopylength =	*-RAMcopybegin
     70 U00bf
     71 U00bf		       00	   missile0y  ds	1
     72 U00c0		       00	   missile1y  ds	1
     73 U00c1		       00	   bally      ds	1
     74 U00c2
     75 U00c2		       00	   missile0height ds	1
     76 U00c3		       00	   missile1height ds	1
     77 U00c4		       00	   ballheight ds	1
     78 U00c5
     79 U00c5		       00	   statusbarlength ds	1	; needed?
     80 U00c5		       00 c5	   aux3       =	statusbarlength
     81 U00c6
     82 U00c6		       00	   lifecolor  ds	1
     83 U00c6		       00 c6	   pfscorecolor =	lifecolor
     84 U00c7		       00	   aux4       ds	1
     85 U00c8
     86 U00c8		       00	   lifepointer ds	1
     87 U00c9		       00	   lives      ds	1
     88 U00c9		       00 c8	   pfscore1   =	lifepointer
     89 U00c9		       00 c9	   pfscore2   =	lives
     90 U00c9		       00 c8	   aux5       =	pfscore1
     91 U00c9		       00 c9	   aux6       =	pfscore2
     92 U00ca
     93 U00ca		       00	   playfieldpos ds	1
     94 U00cb
     95 U00cb		       00	   temp1      ds	1	; used in sprite flickering
     96 U00cc		       00	   temp2      ds	1	;are obliterated when drawscreen is called.
     97 U00cd		       00	   temp3      ds	1
     98 U00ce		       00	   temp4      ds	1
     99 U00cf		       00	   temp5      ds	1
    100 U00d0		       00	   temp6      ds	1
    101 U00d0		       00 81	   temp7      =	topP1x	; This is used to aid in bankswitching
    102 U00d1
    103 U00d1		       00	   A	      ds	1
    104 U00d1		       00 d1	   a	      =	A
    105 U00d2		       00	   B	      ds	1
    106 U00d2		       00 d2	   b	      =	B
    107 U00d3		       00	   C	      ds	1
    108 U00d3		       00 d3	   c	      =	C
    109 U00d4		       00	   D	      ds	1
    110 U00d4		       00 d4	   d	      =	D
    111 U00d5		       00	   E	      ds	1
    112 U00d5		       00 d5	   e	      =	E
    113 U00d6		       00	   F	      ds	1
    114 U00d6		       00 d6	   f	      =	F
    115 U00d7		       00	   G	      ds	1
    116 U00d7		       00 d7	   g	      =	G
    117 U00d8		       00	   H	      ds	1
    118 U00d8		       00 d8	   h	      =	H
    119 U00d9		       00	   I	      ds	1
    120 U00d9		       00 d9	   i	      =	I
    121 U00da		       00	   J	      ds	1
    122 U00da		       00 da	   j	      =	J
    123 U00db		       00	   K	      ds	1
    124 U00db		       00 db	   k	      =	K
    125 U00dc		       00	   L	      ds	1
    126 U00dc		       00 dc	   l	      =	L
    127 U00dd		       00	   M	      ds	1
    128 U00dd		       00 dd	   m	      =	M
    129 U00de		       00	   N	      ds	1
    130 U00de		       00 de	   n	      =	N
    131 U00df		       00	   O	      ds	1
    132 U00df		       00 df	   o	      =	O
    133 U00e0		       00	   P	      ds	1
    134 U00e0		       00 e0	   p	      =	P
    135 U00e1		       00	   Q	      ds	1
    136 U00e1		       00 e1	   q	      =	Q
    137 U00e2		       00	   R	      ds	1
    138 U00e2		       00 e2	   r	      =	R
    139 U00e3		       00	   S	      ds	1
    140 U00e3		       00 e3	   s	      =	S
    141 U00e4		       00	   T	      ds	1
    142 U00e4		       00 e4	   t	      =	T
    143 U00e5		       00	   U	      ds	1
    144 U00e5		       00 e5	   u	      =	U
    145 U00e6		       00	   V	      ds	1
    146 U00e6		       00 e6	   v	      =	V
    147 U00e7		       00	   W	      ds	1
    148 U00e7		       00 e7	   w	      =	W
    149 U00e8		       00	   X	      ds	1
    150 U00e8		       00 e8	   x	      =	X
    151 U00e9		       00	   Y	      ds	1
    152 U00e9		       00 e9	   y	      =	Y
    153 U00ea		       00	   Z	      ds	1
    154 U00ea		       00 ea	   z	      =	Z
    155 U00eb		       00	   scorecolor ds	1
    156 U00ec
    157 U00ec		       00	   var0       ds	1
    158 U00ed		       00	   var1       ds	1
    159 U00ee		       00	   var2       ds	1
    160 U00ef		       00	   var3       ds	1
    161 U00f0		       00	   var4       ds	1
    162 U00f1		       00	   var5       ds	1
    163 U00f2		       00	   var6       ds	1
    164 U00f3		       00	   var7       ds	1
    165 U00f4		       00	   var8       ds	1
    166 U00f5
 free ram: 0
    167 U00f5					      echo	"free ram:",($f5-*)d
    168 U00f5
    169 U00f5		       00 f6	   stack1     =	$f6
    170 U00f5		       00 f7	   stack2     =	$f7
    171 U00f5		       00 f8	   stack3     =	$f8
    172 U00f5		       00 f9	   stack4     =	$f9
    173 U00f5							; the stack bytes above may be used in the kernel
    174 U00f5							; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    175 U00f5
    176 U00f5					      MAC	return
    177 U00f5					      ifnconst	bankswitch
    178 U00f5					      rts
    179 U00f5					      else
    180 U00f5					      jmp	BS_return
    181 U00f5					      endif
    182 U00f5					      ENDM		; auto-return from either a regular or bankswitched module
    183  8400 ????				      seg
    184  8400 ????	       10 00	   rand       =	RANDOM0NEXT
    185  8400 ????	       00 d3	   KERNEL_LINES =	178*76/64	; warning: not all values will work
    186  8400 ????	       00 a7	   OVERSCAN_LINES =	128+33*76/64	; again, not all values work
    187  8400 ????	       d1 a4	   C_function =	FETCHER_BEGIN
    188  8400 ????	       d1 a8	   CcodeData  =	C_function + 4
    189  8400 ????	       d1 e2	   playerpointers =	CcodeData + RAMcopylength
    190  8400 ????	       d2 08	   P1GFX      =	playerpointers + 38
    191  8400 ????	       d3 08	   P1COLOR    =	P1GFX + 256
    192  8400 ????	       d4 08	   P0GFX      =	P1COLOR + 256
    193  8400 ????	       d5 08	   P0COLOR    =	P0GFX + 256
    194  8400 ????	       d6 08	   PF1L       =	P0COLOR + 256
    195  8400 ????	       d7 08	   PF2L       =	PF1L + 256
    196  8400 ????	       d8 08	   PF1R       =	PF2L + 256
    197  8400 ????	       d9 08	   PF2R       =	PF1R + 256
    198  8400 ????	       da 08	   PFCOLS     =	PF2R + 256
    199  8400 ????	       db 08	   JUMPTABLELO =	PFCOLS + 256
    200  8400 ????	       db 14	   JUMPTABLEHI =	JUMPTABLELO + 12
    201  8400 ????	       db 20	   P1HMP      =	JUMPTABLEHI + 12
    202  8400 ????	       db 2d	   P1SKIP     =	P1HMP + 13
    203  8400 ????	       db 39	   NUSIZREFP  =	P1SKIP + 12
    204  8400 ????	       db 45	   scoredata  =	NUSIZREFP + 12
    205  8400 ????	       db a5	   BKCOLS     =	scoredata + 96
    206  8400 ????	       dc a5	   STACKbegin =	BKCOLS + 256
    207  8400 ????	       dd a5	   USERSTACK  =	STACKbegin + 256	; stack starts here and goes down!!!!
 DPC free RAM= 603
    208  8400 ????				      echo	"DPC free RAM=",($1000-(USERSTACK&$0FFF))d
------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 4
      0  8400 ????				      include	"2600basic_variable_redefs.h"
      1  8400 ????						; This file contains variable mapping and other information for the current project.
      2  8400 ????
      3  8400 ????	       00 08	   quadtari_detection_length =	.skipL0183-quadtari_detection
      4  8400 ????
      5  8400 ????	       00 ea	   qtcontroller =	z
      6  8400 ????
      7  8400 ????	       00 db	   moveCounter =	k
      8  8400 ????
      9  8400 ????	       00 da	   delayInc   =	j
     10  8400 ????
     11  8400 ????	       00 d9	   moveDelay  =	i
     12  8400 ????
     13  8400 ????	       00 d8	   previusYPos =	h
     14  8400 ????
     15  8400 ????	       00 d7	   previusXPos =	g
     16  8400 ????
     17  8400 ????	       00 d4	   directionP4 =	d
     18  8400 ????
     19  8400 ????	       00 d3	   directionP3 =	c
     20  8400 ????
     21  8400 ????	       00 d2	   directionP2 =	b
     22  8400 ????
     23  8400 ????	       00 d1	   directionP1 =	a
     24  8400 ????
     25  8400 ????	       00 04	   tileWidth  =	4
     26  8400 ????
     27  8400 ????	       00 08	   tileHeight =	8
     28  8400 ????
     29  8400 ????	       00 03	   tileWidthMask =	%00000011
     30  8400 ????
     31  8400 ????	       00 07	   tileHeightMask =	%00000111
     32  8400 ????
     33  8400 ????	       00 10	   pfOffset   =	16
     34  8400 ????
     35  8400 ????	       00 03	   objectWidthMinusOne =	3
     36  8400 ????
     37  8400 ????	       00 07	   objectHeightMinusOne =	7
     38  8400 ????
     39  8400 ????	       00 d0	   tempY      =	temp6
     40  8400 ????
     41  8400 ????	       00 cf	   tempX      =	temp5
     42  8400 ????
     43  8400 ????	       00 ce	   pfY	      =	temp4
     44  8400 ????
     45  8400 ????	       00 cd	   pfX	      =	temp3
     46  8400 ????
     47  8400 ????	       00 01	   scorefade  =	1
     48  8400 ????
     49  8400 ????	       00 d2	   swdebounce =	b
     50  8400 ????
     51  8400 ????	       00 e9	   gamenumber =	y
     52  8400 ????
     53  8400 ????	       00 90	   scorepointers =	player1x
     54  8400 ????
     55  8400 ????	       00 20	   bscode_length =	32
     56  8400 ????	       00 2b	   vblank_time =	43
     57  8400 ????	       00 25	   overscan_time =	37
     58  8400 ????	       00 07	   bs_mask    =	7
     59  8400 ????	       00 1c	   bankswitch =	28
     60  8400 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     61  8400 ????	       00 02	   multisprite =	2
------- FILE c:\Users\Jag\Desktop\github\4p Surround\4p Surround 22-11-29.bas.asm
      9  0400					      ORG	$400
     10  0400					      RORG	$0
     11  0400					      incbin	DPCplus.arm
     12  1000					      ORG	$1000
     13  1000					      RORG	$1000
     14  1000					      incbin	custom/bin/custom2.bin
     15  1894							; assume custom2.bin > 128 bytes
     16  1894							; repeat $80
     17  1894							; .byte 0
     18  1894							; repend
     19  1894							; Provided under the CC0 license. See the included LICENSE.txt for details.
     20  1894
     21  1894							; feel free to modify the score graphics - just keep each digit 8 high
     22  1894							; and keep the conditional compilation stuff intact
     23  1894				  -	      ifconst	ROM2k
     24  1894				  -	      ORG	$F7AC-8
     25  1894					      else
     26  1894					      ifconst	bankswitch
     27  1894				  -	      if	bankswitch == 8
     28  1894				  -	      ORG	$2F94-bscode_length
     29  1894				  -	      RORG	$FF94-bscode_length
     30  1894					      endif
     31  1894				  -	      if	bankswitch == 16
     32  1894				  -	      ORG	$4F94-bscode_length
     33  1894				  -	      RORG	$FF94-bscode_length
     34  1894					      endif
     35  1894				  -	      if	bankswitch == 32
     36  1894				  -	      ORG	$8F94-bscode_length
     37  1894				  -	      RORG	$FF94-bscode_length
     38  1894					      endif
     39  1894				  -	      if	bankswitch == 64
     40  1894				  -	      ORG	$10F80-bscode_length
     41  1894				  -	      RORG	$1FF80-bscode_length
     42  1894					      endif
     43  1894				  -	      else
     44  1894				  -	      ORG	$FF9C
     45  1894					      endif
     46  1894					      endif
     47  1894
     48  1894							; font equates
     49  1894		       00 01	   .21stcentury =	1
     50  1894		       00 02	   alarmclock =	2
     51  1894		       00 03	   handwritten =	3
     52  1894		       00 04	   interrupted =	4
     53  1894		       00 05	   retroputer =	5
     54  1894		       00 06	   whimsey    =	6
     55  1894		       00 07	   tiny       =	7
     56  1894		       00 08	   hex	      =	8
     57  1894
     58  1894				  -	      ifconst	font
     59  1894				  -	      if	font == hex
     60  1894				  -	      ORG	. - 48
     61  1894				  -	      endif
     62  1894					      endif
     63  1894
     64  1894				   scoretable
     65  1894
     66  1894				  -	      ifconst	font
     67  1894				  -	      if	font == .21stcentury
     68  1894				  -	      include	"score_graphics.asm.21stcentury"
     69  1894				  -	      endif
     70  1894				  -	      if	font == alarmclock
     71  1894				  -	      include	"score_graphics.asm.alarmclock"
     72  1894				  -	      endif
     73  1894				  -	      if	font == handwritten
     74  1894				  -	      include	"score_graphics.asm.handwritten"
     75  1894				  -	      endif
     76  1894				  -	      if	font == interrupted
     77  1894				  -	      include	"score_graphics.asm.interrupted"
     78  1894				  -	      endif
     79  1894				  -	      if	font == retroputer
     80  1894				  -	      include	"score_graphics.asm.retroputer"
     81  1894				  -	      endif
     82  1894				  -	      if	font == whimsey
     83  1894				  -	      include	"score_graphics.asm.whimsey"
     84  1894				  -	      endif
     85  1894				  -	      if	font == tiny
     86  1894				  -	      include	"score_graphics.asm.tiny"
     87  1894				  -	      endif
     88  1894				  -	      if	font == hex
     89  1894				  -	      include	"score_graphics.asm.hex"
     90  1894				  -	      endif
     91  1894					      else		; default font
     92  1894
     93  1894		       3c		      .byte.b	%00111100
     94  1895		       66		      .byte.b	%01100110
     95  1896		       66		      .byte.b	%01100110
     96  1897		       66		      .byte.b	%01100110
     97  1898		       66		      .byte.b	%01100110
     98  1899		       66		      .byte.b	%01100110
     99  189a		       66		      .byte.b	%01100110
    100  189b		       3c		      .byte.b	%00111100
    101  189c
    102  189c		       7e		      .byte.b	%01111110
    103  189d		       18		      .byte.b	%00011000
    104  189e		       18		      .byte.b	%00011000
    105  189f		       18		      .byte.b	%00011000
    106  18a0		       18		      .byte.b	%00011000
    107  18a1		       38		      .byte.b	%00111000
    108  18a2		       18		      .byte.b	%00011000
    109  18a3		       08		      .byte.b	%00001000
    110  18a4
    111  18a4		       7e		      .byte.b	%01111110
    112  18a5		       60		      .byte.b	%01100000
    113  18a6		       60		      .byte.b	%01100000
    114  18a7		       3c		      .byte.b	%00111100
    115  18a8		       06		      .byte.b	%00000110
    116  18a9		       06		      .byte.b	%00000110
    117  18aa		       46		      .byte.b	%01000110
    118  18ab		       3c		      .byte.b	%00111100
    119  18ac
    120  18ac		       3c		      .byte.b	%00111100
    121  18ad		       46		      .byte.b	%01000110
    122  18ae		       06		      .byte.b	%00000110
    123  18af		       06		      .byte.b	%00000110
    124  18b0		       1c		      .byte.b	%00011100
    125  18b1		       06		      .byte.b	%00000110
    126  18b2		       46		      .byte.b	%01000110
    127  18b3		       3c		      .byte.b	%00111100
    128  18b4
    129  18b4		       0c		      .byte.b	%00001100
    130  18b5		       0c		      .byte.b	%00001100
    131  18b6		       7e		      .byte.b	%01111110
    132  18b7		       4c		      .byte.b	%01001100
    133  18b8		       4c		      .byte.b	%01001100
    134  18b9		       2c		      .byte.b	%00101100
    135  18ba		       1c		      .byte.b	%00011100
    136  18bb		       0c		      .byte.b	%00001100
    137  18bc
    138  18bc		       3c		      .byte.b	%00111100
    139  18bd		       46		      .byte.b	%01000110
    140  18be		       06		      .byte.b	%00000110
    141  18bf		       06		      .byte.b	%00000110
    142  18c0		       3c		      .byte.b	%00111100
    143  18c1		       60		      .byte.b	%01100000
    144  18c2		       60		      .byte.b	%01100000
    145  18c3		       7e		      .byte.b	%01111110
    146  18c4
    147  18c4		       3c		      .byte.b	%00111100
    148  18c5		       66		      .byte.b	%01100110
    149  18c6		       66		      .byte.b	%01100110
    150  18c7		       66		      .byte.b	%01100110
    151  18c8		       7c		      .byte.b	%01111100
    152  18c9		       60		      .byte.b	%01100000
    153  18ca		       62		      .byte.b	%01100010
    154  18cb		       3c		      .byte.b	%00111100
    155  18cc
    156  18cc		       30		      .byte.b	%00110000
    157  18cd		       30		      .byte.b	%00110000
    158  18ce		       30		      .byte.b	%00110000
    159  18cf		       18		      .byte.b	%00011000
    160  18d0		       0c		      .byte.b	%00001100
    161  18d1		       06		      .byte.b	%00000110
    162  18d2		       42		      .byte.b	%01000010
    163  18d3		       3e		      .byte.b	%00111110
    164  18d4
    165  18d4		       3c		      .byte.b	%00111100
    166  18d5		       66		      .byte.b	%01100110
    167  18d6		       66		      .byte.b	%01100110
    168  18d7		       66		      .byte.b	%01100110
    169  18d8		       3c		      .byte.b	%00111100
    170  18d9		       66		      .byte.b	%01100110
    171  18da		       66		      .byte.b	%01100110
    172  18db		       3c		      .byte.b	%00111100
    173  18dc
    174  18dc		       3c		      .byte.b	%00111100
    175  18dd		       46		      .byte.b	%01000110
    176  18de		       06		      .byte.b	%00000110
    177  18df		       3e		      .byte.b	%00111110
    178  18e0		       66		      .byte.b	%01100110
    179  18e1		       66		      .byte.b	%01100110
    180  18e2		       66		      .byte.b	%01100110
    181  18e3		       3c		      .byte.b	%00111100
    182  18e4
    183  18e4					      ifnconst	DPC_kernel_options
    184  18e4
    185  18e4		       00		      .byte.b	%00000000
    186  18e5		       00		      .byte.b	%00000000
    187  18e6		       00		      .byte.b	%00000000
    188  18e7		       00		      .byte.b	%00000000
    189  18e8		       00		      .byte.b	%00000000
    190  18e9		       00		      .byte.b	%00000000
    191  18ea		       00		      .byte.b	%00000000
    192  18eb		       00		      .byte.b	%00000000
    193  18ec
    194  18ec					      endif
    195  18ec
    196  18ec					      endif
    197  18ec
    198  18ec				  -	      ifconst	ROM2k
    199  18ec				  -	      ORG	$F7FC
    200  18ec					      else
    201  18ec					      ifconst	bankswitch
    202  18ec				  -	      if	bankswitch == 8
    203  18ec				  -	      ORG	$2FF4-bscode_length
    204  18ec				  -	      RORG	$FFF4-bscode_length
    205  18ec					      endif
    206  18ec				  -	      if	bankswitch == 16
    207  18ec				  -	      ORG	$4FF4-bscode_length
    208  18ec				  -	      RORG	$FFF4-bscode_length
    209  18ec					      endif
    210  18ec				  -	      if	bankswitch == 32
    211  18ec				  -	      ORG	$8FF4-bscode_length
    212  18ec				  -	      RORG	$FFF4-bscode_length
    213  18ec					      endif
    214  18ec				  -	      if	bankswitch == 64
    215  18ec				  -	      ORG	$10FE0-bscode_length
    216  18ec				  -	      RORG	$1FFE0-bscode_length
    217  18ec					      endif
    218  18ec				  -	      else
    219  18ec				  -	      ORG	$FFFC
    220  18ec					      endif
    221  18ec					      endif
    222  18ec							; Provided under the CC0 license. See the included LICENSE.txt for details.
    223  18ec
    224  18ec				   start
    225  18ec		       78		      sei
    226  18ed		       d8		      cld
    227  18ee		       a0 00		      ldy	#0
    228  18f0		       a5 d0		      lda	$D0
    229  18f2		       c9 2c		      cmp	#$2C	;check RAM location #1
    230  18f4		       d0 07		      bne	MachineIs2600
    231  18f6		       a5 d1		      lda	$D1
    232  18f8		       c9 a9		      cmp	#$A9	;check RAM location #2
    233  18fa		       d0 01		      bne	MachineIs2600
    234  18fc		       88		      dey
    235  18fd				   MachineIs2600
    236  18fd		       a2 00		      ldx	#0
    237  18ff		       8a		      txa
    238  1900				   clearmem
    239  1900		       e8		      inx
    240  1901		       9a		      txs
    241  1902		       48		      pha
    242  1903		       d0 fb		      bne	clearmem
    243  1905		       84 cb		      sty	temp1
    244  1907		       a2 08		      ldx	#8
    245  1909		       86 ca		      stx	playfieldpos
    246  190b		       8e 58 10 	      stx	FASTFETCH
    247  190e		       a2 08		      ldx	#8
    248  1910		       a9 e0		      lda	#224
    249  1912				   inityloop
    250  1912		       95 9a		      sta	player1y,x
    251  1914		       ca		      dex
    252  1915		       10 fb		      bpl	inityloop
    253  1917
    254  1917		       a9 01		      lda	#1
    255  1919		       85 0a		      sta	CTRLPF
    256  191b		       ad 84 02 	      lda	INTIM
    257  191e		       8d 71 10 	      sta	RWRITE0
    258  1921		       a9 00		      lda	#0
    259  1923		       8d 38 10 	      STA	DF0FRACINC
    260  1926		       8d 39 10 	      STA	DF1FRACINC
    261  1929		       8d 3a 10 	      STA	DF2FRACINC
    262  192c		       8d 3b 10 	      STA	DF3FRACINC
    263  192f		       8d 3c 10 	      STA	DF4FRACINC
    264  1932		       8d 3e 10 	      STA	DF6FRACINC
    265  1935		       a9 a5		      lda	#<USERSTACK
    266  1937		       8d 57 10 	      STA	DF7LOW
    267  193a		       a9 0d		      lda	#(>USERSTACK) & $0F
    268  193c		       8d 6f 10 	      STA	DF7HI
    269  193f		       a9 ff		      lda	#255
    270  1941		       8d 5a 10 	      sta	CALLFUNCTION	; zero-fill fetcher
    271  1944
    272  1944		       a9 1f		      lda	#>(game-1)
    273  1946		       48		      pha
    274  1947		       a9 93		      lda	#<(game-1)
    275  1949		       48		      pha
    276  194a		       48		      pha
    277  194b		       48		      pha
    278  194c		       a2 01		      ldx	#1
    279  194e		       4c ee df 	      jmp	BS_jsr
    280  1951				   drawscreen
    281  1951		       a9 01		      lda	#1
    282  1953		       85 2c		      sta	CXCLR
    283  1955		       85 09		      sta	COLUBK	; REVENG - don't start with the lastline color
    284  1957
    285  1957				   fufu
    286  1957		       ad 84 02 	      lda	INTIM
    287  195a		       30 fb		      bmi	fufu
    288  195c
      0  195c					      VERTICAL_SYNC
      1  195c		       a9 02		      LDA	#$02
      2  195e		       85 02		      STA	WSYNC
      3  1960		       85 00		      STA	VSYNC
      4  1962		       85 02		      STA	WSYNC
      5  1964		       85 02		      STA	WSYNC
      6  1966		       4a		      LSR
      7  1967		       85 02		      STA	WSYNC
      8  1969		       85 00		      STA	VSYNC
    290  196b
    291  196b		       a9 a9		      lda	#41+128	;was 37 - do more w/c code
    292  196d		       8d 96 02 	      sta	TIM64T
    293  1970
    294  1970							; adjust for pfpos?
    295  1970
    296  1970							; set zero to properly enter C code
    297  1970		       a9 a4		      lda	#<C_function
    298  1972		       8d 50 10 	      sta	DF0LOW
    299  1975		       a9 01		      lda	#(>C_function) & $0F
    300  1977		       8d 68 10 	      sta	DF0HI
    301  197a		       a9 00		      lda	#0
    302  197c		       8d 78 10 	      sta	DF0WRITE
    303  197f
    304  197f							; REVENG - pass the number of vsprites we want...
    305  197f					      ifnconst	dpcspritemax
    306  197f				  -	      ifconst	readpaddle
    307  197f				  -	      lda	#8
    308  197f					      else
    309  197f		       a9 09		      lda	#9
    310  1981					      endif
    311  1981				  -	      else
    312  1981				  -	      lda	#dpcspritemax
    313  1981					      endif
    314  1981		       8d 78 10 	      sta	DF0WRITE
    315  1984
    316  1984		       a5 80		      lda	player0x
    317  1986		       85 8f		      sta	player0xcoll	; detect p0x colls
    318  1988
    319  1988							; copy RAM to fetcher for C-code
    320  1988		       a9 e2		      lda	#<(CcodeData + RAMcopylength)
    321  198a		       8d 50 10 	      sta	DF0LOW
    322  198d		       a9 01		      lda	#(>(CcodeData + RAMcopylength)) & $0F
    323  198f		       8d 68 10 	      sta	DF0HI
    324  1992		       a2 39		      ldx	#RAMcopylength-1
    325  1994				   copy2fetcherloop
    326  1994		       b5 85		      lda	RAMcopybegin,x
    327  1996		       8d 60 10 	      sta	DF0PUSH
    328  1999		       ca		      dex
    329  199a		       10 f8		      bpl	copy2fetcherloop
    330  199c
    331  199c		       a9 ff		      lda	#255
    332  199e		       8d 5a 10 	      sta	CALLFUNCTION
    333  19a1
    334  19a1							; copy modified data back (just need first 6 bytes, which is sprite sort data)
    335  19a1		       a2 ed		      ldx	#256-19
    336  19a3				   copyfromfetcherloop
    337  19a3		       ad 08 10 	      lda	DF0DATA
    338  19a6		       95 98		      sta	RAMcopybegin+19,x
    339  19a8		       e8		      inx
    340  19a9		       30 f8		      bmi	copyfromfetcherloop
    341  19ab
    342  19ab		       20 3d 1e 	      jsr	kernel_setup
    343  19ae		       85 02		      sta	WSYNC
    344  19b0		       a0 80		      ldy	#$80
    345  19b2		       84 20		      sty	HMP0
    346  19b4		       84 21		      sty	HMP1
    347  19b6		       84 22		      sty	HMM0
    348  19b8		       84 23		      sty	HMM1
    349  19ba		       84 24		      sty	HMBL
    350  19bc
    351  19bc							; run possible vblank bB code
    352  19bc				  -	      ifconst	vblank_bB_code
    353  19bc				  -	      jsr	vblank_bB_code
    354  19bc					      endif
    355  19bc
    356  19bc		       20 05 1d 	      jsr	set_fetchers
    357  19bf
    358  19bf		       a2 07		      ldx	#7
    359  19c1				   setloopfrac
    360  19c1		       bd 80 1d 	      lda	dffraclow,x
    361  19c4		       9d 28 10 	      sta	DF0FRACLOW,x
    362  19c7		       bd 88 1d 	      lda	dffrachi,x
    363  19ca		       9d 30 10 	      sta	DF0FRACHI,x
    364  19cd		       ca		      dex
    365  19ce		       10 f1		      bpl	setloopfrac
    366  19d0							; lda #255
    367  19d0		       8e 3d 10 	      STx	DF5FRACINC	; x=255 right now
    368  19d3		       8e 3f 10 	      STx	DF7FRACINC
    369  19d6		       ad 1d 10 	      lda	DF5FRACDATA	; priming read
    370  19d9		       ad 1f 10 	      lda	DF7FRACDATA	; priming read
    371  19dc
    372  19dc		       a6 85		      ldx	SpriteGfxIndex
    373  19de		       b5 af		      lda	_NUSIZ1,x	; top NUSIZ/REFP
    374  19e0		       85 05		      sta	NUSIZ1
    375  19e2		       85 0c		      sta	REFP1
    376  19e4
    377  19e4							;REVENG - allow P0 to wrap at the top
    378  19e4				   startwrapfix
    379  19e4		       a9 ff		      lda	#255
    380  19e6		       85 cc		      sta	temp2
    381  19e8		       18		      clc
    382  19e9		       a5 99		      lda	player0y
    383  19eb		       65 a5		      adc	player0height
    384  19ed		       38		      sec
    385  19ee		       c5 a5		      cmp	player0height
    386  19f0		       90 04		      bcc	skipwrapfix
    387  19f2		       a9 00		      lda	#0
    388  19f4		       85 cc		      sta	temp2
    389  19f6				   skipwrapfix
    390  19f6
    391  19f6		       38		      sec
    392  19f7		       a9 08		      lda	#<P0GFX
    393  19f9		       e5 99		      sbc	player0y
    394  19fb		       8d 52 10 	      sta	DF2LOW
    395  19fe		       a9 d4		      lda	#>P0GFX
    396  1a00							;sbc #0
    397  1a00		       e5 cc		      sbc	temp2
    398  1a02		       8d 6a 10 	      sta	DF2HI
    399  1a05		       a9 07		      lda	#<(P0GFX-1)
    400  1a07		       8d 42 10 	      sta	DF2TOP
    401  1a0a		       38		      sec
    402  1a0b		       65 a5		      adc	player0height
    403  1a0d		       8d 4a 10 	      sta	DF2BOT
    404  1a10
    405  1a10							;REVENG - 1/2 of the COLUM0 fix. the rest is in main.c
    406  1a10		       a9 08		      lda	#<(P0COLOR)
    407  1a12		       8d 50 10 	      sta	DF0LOW
    408  1a15		       85 cc		      sta	temp2
    409  1a17		       a9 d5		      lda	#>(P0COLOR)
    410  1a19		       8d 68 10 	      sta	DF0HI
    411  1a1c
    412  1a1c							; ball
    413  1a1c		       a9 07		      lda	#<(P1GFX-1)
    414  1a1e		       18		      clc
    415  1a1f		       65 c1		      adc	bally
    416  1a21		       8d 43 10 	      sta	DF3TOP
    417  1a24		       38		      sec
    418  1a25		       65 c4		      adc	ballheight
    419  1a27		       8d 4b 10 	      sta	DF3BOT
    420  1a2a
    421  1a2a							; missile0
    422  1a2a		       a5 cc		      lda	temp2
    423  1a2c		       18		      clc
    424  1a2d		       65 bf		      adc	missile0y
    425  1a2f		       8d 40 10 	      sta	DF0TOP
    426  1a32		       38		      sec
    427  1a33		       65 c2		      adc	missile0height
    428  1a35		       8d 48 10 	      sta	DF0BOT
    429  1a38
    430  1a38
    431  1a38				   fuu
    432  1a38		       ad 84 02 	      lda	INTIM
    433  1a3b		       30 fb		      bmi	fuu
    434  1a3d		       85 02		      sta	WSYNC
    435  1a3f							;     ldy #$80
    436  1a3f							;     sty HMP0
    437  1a3f							;     sty HMP1
    438  1a3f							;     sty HMM0 
    439  1a3f							;     sty HMM1
    440  1a3f							;     sty HMBL
    441  1a3f							; relocated code above prior to vblank, to allow for Cosmic Ark starfield
    442  1a3f							; and/or skewed players
      0  1a3f					      sleep	17
      1  1a3f				   .CYCLES    SET	17
      2  1a3f
      3  1a3f				  -	      IF	.CYCLES < 2
      4  1a3f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a3f				  -	      ERR
      6  1a3f					      ENDIF
      7  1a3f
      8  1a3f					      IF	.CYCLES & 1
      9  1a3f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a3f		       04 00		      nop	0
     11  1a41				  -	      ELSE
     12  1a41				  -	      bit	VSYNC
     13  1a41					      ENDIF
     14  1a41				   .CYCLES    SET	.CYCLES - 3
     15  1a41					      ENDIF
     16  1a41
     17  1a41					      REPEAT	.CYCLES / 2
     18  1a41		       ea		      nop
     17  1a41					      REPEND
     18  1a42		       ea		      nop
     17  1a42					      REPEND
     18  1a43		       ea		      nop
     17  1a43					      REPEND
     18  1a44		       ea		      nop
     17  1a44					      REPEND
     18  1a45		       ea		      nop
     17  1a45					      REPEND
     18  1a46		       ea		      nop
     17  1a46					      REPEND
     18  1a47		       ea		      nop
     19  1a48					      REPEND
    444  1a48
    445  1a48		       a9 d3		      lda	#KERNEL_LINES
    446  1a4a		       8d 96 02 	      sta	TIM64T
    447  1a4d		       a9 01		      lda	#1
    448  1a4f		       85 27		      sta	VDELBL
    449  1a51		       85 25		      sta	VDELP0
    450  1a53
    451  1a53							; missile1
    452  1a53		       a9 07		      lda	#<(P1COLOR-1)
    453  1a55		       18		      clc
    454  1a56		       65 c0		      adc	missile1y
    455  1a58		       8d 41 10 	      sta	DF1TOP
    456  1a5b		       38		      sec
    457  1a5c		       65 c3		      adc	missile1height
    458  1a5e		       8d 49 10 	      sta	DF1BOT
    459  1a61
    460  1a61		       a9 00		      lda	#0
    461  1a63		       85 01		      sta	VBLANK
    462  1a65		       8d 58 10 	      sta	FASTFETCH
    463  1a68							;sleep 7
    464  1a68		       a9 12		      lda	#<DF2DATAW	; REVENG - added so GRP0 is at TOP
    465  1a6a		       85 1b		      STA	GRP0	; 36 (VDEL)   ; ""
      0  1a6c					      sleep	2	; ""
      1  1a6c				   .CYCLES    SET	2
      2  1a6c
      3  1a6c				  -	      IF	.CYCLES < 2
      4  1a6c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a6c				  -	      ERR
      6  1a6c					      ENDIF
      7  1a6c
      8  1a6c				  -	      IF	.CYCLES & 1
      9  1a6c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a6c				  -	      nop	0
     11  1a6c				  -	      ELSE
     12  1a6c				  -	      bit	VSYNC
     13  1a6c				  -	      ENDIF
     14  1a6c				  -.CYCLES    SET	.CYCLES - 3
     15  1a6c					      ENDIF
     16  1a6c
     17  1a6c					      REPEAT	.CYCLES / 2
     18  1a6c		       ea		      nop
     19  1a6d					      REPEND
    467  1a6d
    468  1a6d		       a9 18		      lda	#<DF0FRACDATA
    469  1a6f		       85 0e		      sta	PF1	; (PF1L)
    470  1a71
    471  1a71							; enter at cycle ??
    472  1a71				   loop
    473  1a71		       a9 08		      lda	#<DF0DATA	;74
    474  1a73		       85 06		      STA	COLUP0	; 1
    475  1a75		       a9 09		      lda	#<DF1DATA	;3
    476  1a77				   loop2
    477  1a77		       85 07		      STA	COLUP1	; 6
    478  1a79		       a9 0b		      lda	#<DF3DATA
    479  1a7b		       85 1c		      STA	GRP1	; 11
    480  1a7d		       a9 20		      lda	#<DF0FLAG
    481  1a7f		       85 1d		      STA	ENAM0	; 16
    482  1a81
    483  1a81		       a9 1e		      lda	#<DF6FRACDATA
    484  1a83		       85 09		      sta	COLUBK	; 21
    485  1a85		       a9 1c		      lda	#<DF4FRACDATA
    486  1a87		       85 08		      sta	COLUPF	; 26
    487  1a89		       a9 19		      lda	#<DF1FRACDATA
    488  1a8b		       85 0f		      sta	PF2	; 31 (PF2L)
    489  1a8d				   loop3
    490  1a8d		       a9 12		      lda	#<DF2DATAW
    491  1a8f		       85 1b		      STA	GRP0	; 36 (VDEL)
    492  1a91		       a9 23		      lda	#<DF3FLAG
    493  1a93		       85 1f		      STA	ENABL	; 41 (VDEL)
    494  1a95		       a2 70		      ldx	#$70	;in case we get kernel 6
    495  1a97		       a9 1a		      lda	#<DF2FRACDATA	;45
    496  1a99		       85 0f		      sta	PF2	; 48
    497  1a9b		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    498  1a9d		       a9 1b		      lda	#<DF3FRACDATA	;53
    499  1a9f		       85 0e		      sta	PF1	; 56
    500  1aa1		       a9 0c		      lda	#<DF4DATA	; 58 this is the repos info
    501  1aa3		       f0 44		      beq	repo	;60/61
    502  1aa5				   norepo		; 60
    503  1aa5		       a8		      tay		; 62
    504  1aa6		       a9 08		      lda	#<DF0DATA	; 64
    505  1aa8
    506  1aa8		       ae 84 02 	      ldx	INTIM	; 68 timed for 192 lines
    507  1aab		       f0 57		      beq	exitkernel	; 70/71
    508  1aad		       85 2a		      sta	HMOVE	; 73
    509  1aaf
    510  1aaf		       85 06		      STA	COLUP0	; 0
    511  1ab1		       a9 09		      lda	#<DF1DATA	;2
    512  1ab3		       85 07		      STA	COLUP1	;5
    513  1ab5		       a9 0b		      lda	#<DF3DATA
    514  1ab7		       85 1c		      STA	GRP1	; 10
    515  1ab9		       a9 21		      lda	#<DF1FLAG
    516  1abb		       85 1e		      STA	ENAM1	; 15
    517  1abd		       a9 18		      lda	#<DF0FRACDATA
    518  1abf		       85 0e		      sta	PF1	; 20 (PF1L)
    519  1ac1		       a9 19		      lda	#<DF1FRACDATA
    520  1ac3		       85 0f		      sta	PF2	; 25 (PF2L)
    521  1ac5		       a9 12		      lda	#<DF2DATAW
    522  1ac7		       85 1b		      STA	GRP0	; 30 (VDEL)
    523  1ac9		       a9 23		      lda	#<DF3FLAG
    524  1acb		       85 1f		      STA	ENABL	; 35 (VDEL)
    525  1acd		       88		      dey		; 37
    526  1ace		       8c 64 10 	      STY	DF4PUSH	; 41
    527  1ad1		       a0 80		      ldy	#$80	; 43 no movement next line
    528  1ad3		       a9 1a		      lda	#<DF2FRACDATA	;45
    529  1ad5		       85 0f		      sta	PF2	; 48
    530  1ad7		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    531  1ad9		       a9 1b		      lda	#<DF3FRACDATA	;53
    532  1adb		       85 0e		      sta	PF1	; 56
    533  1add					      ifnconst	DPC_kernel_options
    534  1add							;sleep 8 ; REVENG - timing is off - results in a garbled screen
      0  1add					      sleep	5	; this is better
      1  1add				   .CYCLES    SET	5
      2  1add
      3  1add				  -	      IF	.CYCLES < 2
      4  1add				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1add				  -	      ERR
      6  1add					      ENDIF
      7  1add
      8  1add					      IF	.CYCLES & 1
      9  1add					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1add		       04 00		      nop	0
     11  1adf				  -	      ELSE
     12  1adf				  -	      bit	VSYNC
     13  1adf					      ENDIF
     14  1adf				   .CYCLES    SET	.CYCLES - 3
     15  1adf					      ENDIF
     16  1adf
     17  1adf					      REPEAT	.CYCLES / 2
     18  1adf		       ea		      nop
     19  1ae0					      REPEND
    536  1ae0				  -	      else
    537  1ae0				  -	      bit	DPC_kernel_options
    538  1ae0				  -	      if	(DPC_kernel_options > $3F)
    539  1ae0				  -	      bmi	COLfound
    540  1ae0				  -	      else
    541  1ae0				  -	      bpl	COLfound
    542  1ae0				  -	      endif
    543  1ae0					      endif
    544  1ae0		       86 ce		      stx	temp4	; +3
    545  1ae2
    546  1ae2				   getbackearly
    547  1ae2		       a9 18		      lda	#<DF0FRACDATA	; +2
    548  1ae4		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    549  1ae6		       4c 71 5a 	      JMP	loop+$4000	; 72
    550  1ae9
    551  1ae9				  -	      ifconst	DPC_kernel_options
    552  1ae9				  -COLfound
    553  1ae9				  -	      lda	DF0FRACDATA
    554  1ae9				  -	      sta	PF1	; 69 (PF1L) too early?
    555  1ae9				  -	      JMP	loop+$4000	; 72
    556  1ae9					      endif
    557  1ae9
    558  1ae9				   repo
    559  1ae9		       ac 1f 10 	      ldy	DF7FRACDATA	; 65
    560  1aec		       a9 18		      lda	#<DF0FRACDATA	; 67 preload PF1L for next line
    561  1aee				  -	      if	((>repo) > (>norepo))
    562  1aee				  -	      STA	PF1
    563  1aee					      else
    564  1aee		       8d 0e 00 	      STA.w	PF1	; 71 ; sta.w if page doesn't wrap
    565  1af1					      endif
    566  1af1		       a9 08		      lda	#<DF0DATA	;73
    567  1af3		       85 06		      STA	COLUP0	; 0
    568  1af5		       a9 09		      lda	#<DF1DATA
    569  1af7		       85 07		      STA	COLUP1	;5
    570  1af9		       a9 0b		      lda	#<DF3DATA
    571  1afb		       85 1c		      STA	GRP1	; 10
    572  1afd		       a9 21		      lda	#<DF1FLAG
    573  1aff		       85 1e		      STA	ENAM1	; 15
    574  1b01							; repos info holds HMMx
    575  1b01		       6c 0d 10 	      jmp	(DF5DATA)	; 20 grabs df6/df7=lo/hi
    576  1b04
    577  1b04				   exitkernel		; exit the kernel
    578  1b04		       20 cc 5e 	      jsr	scorekernel+$4000	; 1
    579  1b07				   exit
    580  1b07		       a2 ff		      ldx	#255
    581  1b09		       8e 58 10 	      stx	FASTFETCH
    582  1b0c		       85 02		      sta	WSYNC
    583  1b0e					      ifconst	qtcontroller
    584  1b0e		       a5 ea		      lda	qtcontroller
    585  1b10		       4a		      lsr		; bit 0 in carry
    586  1b11		       a9 04		      lda	#4
    587  1b13		       6a		      ror		; carry into top of A
    588  1b14				  -	      else
    589  1b14				  -	      lda	#2
    590  1b14					      endif		; qtcontroller
    591  1b14		       85 01		      STA	VBLANK
    592  1b16		       a9 a7		      lda	#OVERSCAN_LINES
    593  1b18		       8d 96 02 	      sta	TIM64T
    594  1b1b		       38		      sec
    595  1b1c		       a9 d3		      lda	#KERNEL_LINES
    596  1b1e		       e5 ce		      sbc	temp4
    597  1b20		       aa		      tax
    598  1b21		       4a		      lsr
    599  1b22		       4a		      lsr
    600  1b23		       85 cd		      sta	temp3	; div4
    601  1b25		       4a		      lsr
    602  1b26		       4a		      lsr
    603  1b27		       85 cc		      sta	temp2	; div16
    604  1b29		       4a		      lsr
    605  1b2a		       85 cb		      sta	temp1	; div32
    606  1b2c		       18		      clc
    607  1b2d		       8a		      txa
    608  1b2e		       65 cc		      adc	temp2
    609  1b30		       65 cb		      adc	temp1
    610  1b32		       38		      sec
    611  1b33		       e5 cd		      sbc	temp3
    612  1b35		       85 ce		      sta	temp4	; approx line of first pf coll
      0  1b37					      RETURN
      1  1b37				  -	      ifnconst	bankswitch
      2  1b37				  -	      rts
      3  1b37					      else
      4  1b37		       4c e0 df 	      jmp	BS_return
      5  1b3a					      endif
    614  1b3a
    615  1b3a							; jmp exit
    616  1b3a
    617  1b3a							; kernels resp1 23/28/33/38/43/48/53/58/63/68/73
    618  1b3a
    619  1b3a				   kernel1
    620  1b3a		       85 11		      sta	RESP1	; 23
    621  1b3c		       a9 12		      lda	#<DF2DATAW
    622  1b3e		       85 1b		      STA	GRP0	; 28 (VDEL)
    623  1b40		       a9 19		      lda	#<DF1FRACDATA
    624  1b42		       85 0f		      STA	PF2	; 33
    625  1b44		       a9 23		      lda	#<DF3FLAG
    626  1b46		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b48					      sleep	5
      1  1b48				   .CYCLES    SET	5
      2  1b48
      3  1b48				  -	      IF	.CYCLES < 2
      4  1b48				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b48				  -	      ERR
      6  1b48					      ENDIF
      7  1b48
      8  1b48					      IF	.CYCLES & 1
      9  1b48					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b48		       04 00		      nop	0
     11  1b4a				  -	      ELSE
     12  1b4a				  -	      bit	VSYNC
     13  1b4a					      ENDIF
     14  1b4a				   .CYCLES    SET	.CYCLES - 3
     15  1b4a					      ENDIF
     16  1b4a
     17  1b4a					      REPEAT	.CYCLES / 2
     18  1b4a		       ea		      nop
     19  1b4b					      REPEND
    628  1b4b		       a9 1a		      lda	#<DF2FRACDATA	;45
    629  1b4d		       85 0f		      sta	PF2	; 48
    630  1b4f		       a9 1b		      lda	#<DF3FRACDATA	;50
    631  1b51		       85 0e		      sta	PF1	; 53
    632  1b53		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    633  1b55		       85 05		      STA	NUSIZ1	; 58
    634  1b57		       85 0c		      STA	REFP1	; 61
    635  1b59		       4c e2 1a 	      jmp	getbackearly	;64
    636  1b5c
    637  1b5c				   kernel2
    638  1b5c		       a9 12		      lda	#<DF2DATAW
    639  1b5e		       85 1b		      STA	GRP0	; 25 (VDEL)
    640  1b60		       85 11		      sta	RESP1	;28
    641  1b62		       a9 19		      lda	#<DF1FRACDATA
    642  1b64		       85 0f		      STA	PF2	; 33
    643  1b66		       a9 23		      lda	#<DF3FLAG
    644  1b68		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b6a					      sleep	5
      1  1b6a				   .CYCLES    SET	5
      2  1b6a
      3  1b6a				  -	      IF	.CYCLES < 2
      4  1b6a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b6a				  -	      ERR
      6  1b6a					      ENDIF
      7  1b6a
      8  1b6a					      IF	.CYCLES & 1
      9  1b6a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b6a		       04 00		      nop	0
     11  1b6c				  -	      ELSE
     12  1b6c				  -	      bit	VSYNC
     13  1b6c					      ENDIF
     14  1b6c				   .CYCLES    SET	.CYCLES - 3
     15  1b6c					      ENDIF
     16  1b6c
     17  1b6c					      REPEAT	.CYCLES / 2
     18  1b6c		       ea		      nop
     19  1b6d					      REPEND
    646  1b6d		       a9 1a		      lda	#<DF2FRACDATA	;45
    647  1b6f		       85 0f		      sta	PF2	; 48
    648  1b71		       a9 1b		      lda	#<DF3FRACDATA	;50
    649  1b73		       85 0e		      sta	PF1	; 53
    650  1b75		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    651  1b77		       85 05		      STA	NUSIZ1
    652  1b79		       85 0c		      STA	REFP1
    653  1b7b		       4c e2 1a 	      jmp	getbackearly	;64
    654  1b7e
    655  1b7e				   kernel3
    656  1b7e		       a9 12		      lda	#<DF2DATAW
    657  1b80		       85 1b		      STA	GRP0	; 25 (VDEL)
    658  1b82		       a9 19		      lda	#<DF1FRACDATA
    659  1b84		       85 0f		      STA	PF2	; 30
    660  1b86		       85 11		      sta	RESP1	;33
    661  1b88		       a9 23		      lda	#<DF3FLAG
    662  1b8a		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b8c					      sleep	5
      1  1b8c				   .CYCLES    SET	5
      2  1b8c
      3  1b8c				  -	      IF	.CYCLES < 2
      4  1b8c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b8c				  -	      ERR
      6  1b8c					      ENDIF
      7  1b8c
      8  1b8c					      IF	.CYCLES & 1
      9  1b8c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b8c		       04 00		      nop	0
     11  1b8e				  -	      ELSE
     12  1b8e				  -	      bit	VSYNC
     13  1b8e					      ENDIF
     14  1b8e				   .CYCLES    SET	.CYCLES - 3
     15  1b8e					      ENDIF
     16  1b8e
     17  1b8e					      REPEAT	.CYCLES / 2
     18  1b8e		       ea		      nop
     19  1b8f					      REPEND
    664  1b8f		       a9 1a		      lda	#<DF2FRACDATA	;45
    665  1b91		       85 0f		      sta	PF2	; 48
    666  1b93		       a9 1b		      lda	#<DF3FRACDATA	;50
    667  1b95		       85 0e		      sta	PF1	; 53
    668  1b97		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    669  1b99		       85 05		      STA	NUSIZ1
    670  1b9b		       85 0c		      STA	REFP1
    671  1b9d		       4c e2 1a 	      JMP	getbackearly	; 64
    672  1ba0
    673  1ba0				   kernel4
    674  1ba0		       a9 12		      lda	#<DF2DATAW
    675  1ba2		       85 1b		      STA	GRP0	; 25 (VDEL)
    676  1ba4		       a9 23		      lda	#<DF3FLAG
    677  1ba6		       85 1f		      STA	ENABL	; 30(VDEL)
    678  1ba8		       a9 19		      lda	#<DF1FRACDATA
    679  1baa		       85 0f		      STA	PF2	; 35
    680  1bac		       85 11		      sta	RESP1	;38
      0  1bae					      sleep	5
      1  1bae				   .CYCLES    SET	5
      2  1bae
      3  1bae				  -	      IF	.CYCLES < 2
      4  1bae				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bae				  -	      ERR
      6  1bae					      ENDIF
      7  1bae
      8  1bae					      IF	.CYCLES & 1
      9  1bae					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bae		       04 00		      nop	0
     11  1bb0				  -	      ELSE
     12  1bb0				  -	      bit	VSYNC
     13  1bb0					      ENDIF
     14  1bb0				   .CYCLES    SET	.CYCLES - 3
     15  1bb0					      ENDIF
     16  1bb0
     17  1bb0					      REPEAT	.CYCLES / 2
     18  1bb0		       ea		      nop
     19  1bb1					      REPEND
    682  1bb1		       a9 1a		      lda	#<DF2FRACDATA	;45
    683  1bb3		       85 0f		      sta	PF2	; 48
    684  1bb5		       a9 1b		      lda	#<DF3FRACDATA	;50
    685  1bb7		       85 0e		      sta	PF1	; 53
    686  1bb9		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    687  1bbb		       85 05		      STA	NUSIZ1	; 58
    688  1bbd		       85 0c		      STA	REFP1	; 61
    689  1bbf		       4c e2 1a 	      JMP	getbackearly	; 64
    690  1bc2
    691  1bc2				   kernel5
    692  1bc2		       a9 12		      lda	#<DF2DATAW
    693  1bc4		       85 1b		      STA	GRP0	; (VDEL)
    694  1bc6		       a9 23		      lda	#<DF3FLAG
    695  1bc8		       85 1f		      STA	ENABL	; (VDEL)
    696  1bca		       a9 19		      lda	#<DF1FRACDATA
    697  1bcc		       85 0f		      STA	PF2	; 35
      0  1bce					      sleep	5
      1  1bce				   .CYCLES    SET	5
      2  1bce
      3  1bce				  -	      IF	.CYCLES < 2
      4  1bce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bce				  -	      ERR
      6  1bce					      ENDIF
      7  1bce
      8  1bce					      IF	.CYCLES & 1
      9  1bce					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bce		       04 00		      nop	0
     11  1bd0				  -	      ELSE
     12  1bd0				  -	      bit	VSYNC
     13  1bd0					      ENDIF
     14  1bd0				   .CYCLES    SET	.CYCLES - 3
     15  1bd0					      ENDIF
     16  1bd0
     17  1bd0					      REPEAT	.CYCLES / 2
     18  1bd0		       ea		      nop
     19  1bd1					      REPEND
    699  1bd1		       85 11		      sta	RESP1	;43
    700  1bd3		       a9 1a		      lda	#<DF2FRACDATA	;45
    701  1bd5		       85 0f		      sta	PF2	; 48
    702  1bd7		       a9 1b		      lda	#<DF3FRACDATA	;50
    703  1bd9		       85 0e		      sta	PF1	; 53
    704  1bdb		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    705  1bdd		       85 05		      STA	NUSIZ1
    706  1bdf		       85 0c		      STA	REFP1
    707  1be1		       4c e2 1a 	      JMP	getbackearly	; 64
    708  1be4
    709  1be4				   kernel6
    710  1be4		       a9 12		      lda	#<DF2DATAW
    711  1be6		       85 1b		      STA	GRP0	; 25 (VDEL)
    712  1be8		       a9 23		      lda	#<DF3FLAG
    713  1bea		       85 1f		      STA	ENABL	; 30 (VDEL)
    714  1bec		       a9 19		      lda	#<DF1FRACDATA
    715  1bee		       85 0f		      STA	PF2	; 35
    716  1bf0		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    717  1bf2		       85 05		      STA	NUSIZ1	; 40
    718  1bf4		       85 0c		      STA	REFP1	; 43
    719  1bf6		       a9 1a		      lda	#<DF2FRACDATA	;45
    720  1bf8		       85 0f		      sta	PF2	; 48
    721  1bfa		       a9 1b		      lda	#<DF3FRACDATA	;50
    722  1bfc		       85 11		      sta	RESP1	;53
    723  1bfe							; do a move right by 15
    724  1bfe		       85 0e		      sta	PF1	; 56
    725  1c00		       86 21		      stx	HMP1	; 59
    726  1c02		       a9 19		      lda	#<DF1FRACDATA
    727  1c04		       85 0f		      sta	PF2	; 64 (PF2L)
    728  1c06		       a9 18		      lda	#<DF0FRACDATA
    729  1c08		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    730  1c0a		       a9 08		      lda	#<DF0DATA	; 71
    731  1c0c		       85 2a		      sta	HMOVE	; 74 adjust to +15 right
    732  1c0e
    733  1c0e		       85 06		      STA	COLUP0	; 1
    734  1c10		       a9 09		      lda	#<DF1DATA
    735  1c12		       85 07		      sta	COLUP1	; 6
    736  1c14		       a9 0b		      lda	#<DF3DATA
    737  1c16		       85 1c		      STA	GRP1	; 11
    738  1c18		       a9 20		      lda	#<DF0FLAG
    739  1c1a		       85 1d		      STA	ENAM0	; 16
    740  1c1c		       a9 1e		      lda	#<DF6FRACDATA
    741  1c1e		       85 09		      STA	COLUBK	; 21
    742  1c20		       a9 1c		      lda	#<DF4FRACDATA
    743  1c22		       85 08		      sta	COLUPF	; 26
      0  1c24					      sleep	2
      1  1c24				   .CYCLES    SET	2
      2  1c24
      3  1c24				  -	      IF	.CYCLES < 2
      4  1c24				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c24				  -	      ERR
      6  1c24					      ENDIF
      7  1c24
      8  1c24				  -	      IF	.CYCLES & 1
      9  1c24				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c24				  -	      nop	0
     11  1c24				  -	      ELSE
     12  1c24				  -	      bit	VSYNC
     13  1c24				  -	      ENDIF
     14  1c24				  -.CYCLES    SET	.CYCLES - 3
     15  1c24					      ENDIF
     16  1c24
     17  1c24					      REPEAT	.CYCLES / 2
     18  1c24		       ea		      nop
     19  1c25					      REPEND
    745  1c25		       4c 8d 1a 	      jmp	loop3	; 31
    746  1c28
    747  1c28				   kernel7
    748  1c28		       a9 12		      lda	#<DF2DATAW
    749  1c2a		       85 1b		      STA	GRP0	; 25 (VDEL)
    750  1c2c		       a9 23		      lda	#<DF3FLAG
    751  1c2e		       85 1f		      STA	ENABL	; 30 (VDEL)
    752  1c30		       a9 19		      lda	#<DF1FRACDATA
    753  1c32		       85 0f		      STA	PF2	; 35
    754  1c34		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    755  1c36		       85 05		      STA	NUSIZ1	; 40
    756  1c38		       85 0c		      STA	REFP1	; 43
    757  1c3a		       a9 1a		      lda	#<DF2FRACDATA	;45
    758  1c3c		       85 0f		      sta	PF2	; 48
      0  1c3e					      sleep	2
      1  1c3e				   .CYCLES    SET	2
      2  1c3e
      3  1c3e				  -	      IF	.CYCLES < 2
      4  1c3e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c3e				  -	      ERR
      6  1c3e					      ENDIF
      7  1c3e
      8  1c3e				  -	      IF	.CYCLES & 1
      9  1c3e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c3e				  -	      nop	0
     11  1c3e				  -	      ELSE
     12  1c3e				  -	      bit	VSYNC
     13  1c3e				  -	      ENDIF
     14  1c3e				  -.CYCLES    SET	.CYCLES - 3
     15  1c3e					      ENDIF
     16  1c3e
     17  1c3e					      REPEAT	.CYCLES / 2
     18  1c3e		       ea		      nop
     19  1c3f					      REPEND
    760  1c3f		       85 11		      sta	RESP1	;53
    761  1c41		       a9 1b		      lda	#<DF3FRACDATA	;55
    762  1c43		       85 0e		      sta	PF1	; 58
      0  1c45					      sleep	3
      1  1c45				   .CYCLES    SET	3
      2  1c45
      3  1c45				  -	      IF	.CYCLES < 2
      4  1c45				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c45				  -	      ERR
      6  1c45					      ENDIF
      7  1c45
      8  1c45					      IF	.CYCLES & 1
      9  1c45					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c45		       04 00		      nop	0
     11  1c47				  -	      ELSE
     12  1c47				  -	      bit	VSYNC
     13  1c47					      ENDIF
     14  1c47				   .CYCLES    SET	.CYCLES - 3
     15  1c47					      ENDIF
     16  1c47
     17  1c47				  -	      REPEAT	.CYCLES / 2
     18  1c47				  -	      nop
     19  1c47					      REPEND
    764  1c47		       4c e2 1a 	      JMP	getbackearly	; 64
    765  1c4a
    766  1c4a				   kernel8
    767  1c4a		       a9 12		      lda	#<DF2DATAW
    768  1c4c		       85 1b		      STA	GRP0	; (VDEL)
    769  1c4e		       a9 23		      lda	#<DF3FLAG
    770  1c50		       85 1f		      STA	ENABL	; (VDEL)
    771  1c52		       a9 19		      lda	#<DF1FRACDATA
    772  1c54		       85 0f		      STA	PF2	; 35
    773  1c56		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    774  1c58		       85 05		      STA	NUSIZ1	; 40
    775  1c5a		       85 0c		      STA	REFP1	; 43
    776  1c5c		       a9 1a		      lda	#<DF2FRACDATA	;45
    777  1c5e		       85 0f		      sta	PF2	; 48
    778  1c60		       a9 1b		      lda	#<DF3FRACDATA	;50
    779  1c62		       85 0e		      sta	PF1	; 53
      0  1c64					      sleep	2
      1  1c64				   .CYCLES    SET	2
      2  1c64
      3  1c64				  -	      IF	.CYCLES < 2
      4  1c64				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c64				  -	      ERR
      6  1c64					      ENDIF
      7  1c64
      8  1c64				  -	      IF	.CYCLES & 1
      9  1c64				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c64				  -	      nop	0
     11  1c64				  -	      ELSE
     12  1c64				  -	      bit	VSYNC
     13  1c64				  -	      ENDIF
     14  1c64				  -.CYCLES    SET	.CYCLES - 3
     15  1c64					      ENDIF
     16  1c64
     17  1c64					      REPEAT	.CYCLES / 2
     18  1c64		       ea		      nop
     19  1c65					      REPEND
    781  1c65		       85 11		      sta	RESP1	;58
      0  1c67					      sleep	3
      1  1c67				   .CYCLES    SET	3
      2  1c67
      3  1c67				  -	      IF	.CYCLES < 2
      4  1c67				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c67				  -	      ERR
      6  1c67					      ENDIF
      7  1c67
      8  1c67					      IF	.CYCLES & 1
      9  1c67					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c67		       04 00		      nop	0
     11  1c69				  -	      ELSE
     12  1c69				  -	      bit	VSYNC
     13  1c69					      ENDIF
     14  1c69				   .CYCLES    SET	.CYCLES - 3
     15  1c69					      ENDIF
     16  1c69
     17  1c69				  -	      REPEAT	.CYCLES / 2
     18  1c69				  -	      nop
     19  1c69					      REPEND
    783  1c69		       4c e2 1a 	      JMP	getbackearly	; 64
    784  1c6c
    785  1c6c				   kernel9
    786  1c6c		       a9 12		      lda	#<DF2DATAW
    787  1c6e		       85 1b		      STA	GRP0	; (VDEL)
    788  1c70		       a9 23		      lda	#<DF3FLAG
    789  1c72		       85 1f		      STA	ENABL	; (VDEL)
    790  1c74		       a9 19		      lda	#<DF1FRACDATA
    791  1c76		       85 0f		      STA	PF2	; 35
    792  1c78		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    793  1c7a		       85 05		      STA	NUSIZ1	; 40
    794  1c7c		       85 0c		      STA	REFP1	; 43
    795  1c7e		       a9 1a		      lda	#<DF2FRACDATA	;45
    796  1c80		       85 0f		      sta	PF2	; 48
    797  1c82		       a9 1b		      lda	#<DF3FRACDATA	;50
    798  1c84		       85 0e		      sta	PF1	; 53
      0  1c86					      sleep	5
      1  1c86				   .CYCLES    SET	5
      2  1c86
      3  1c86				  -	      IF	.CYCLES < 2
      4  1c86				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c86				  -	      ERR
      6  1c86					      ENDIF
      7  1c86
      8  1c86					      IF	.CYCLES & 1
      9  1c86					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c86		       04 00		      nop	0
     11  1c88				  -	      ELSE
     12  1c88				  -	      bit	VSYNC
     13  1c88					      ENDIF
     14  1c88				   .CYCLES    SET	.CYCLES - 3
     15  1c88					      ENDIF
     16  1c88
     17  1c88					      REPEAT	.CYCLES / 2
     18  1c88		       ea		      nop
     19  1c89					      REPEND
    800  1c89		       a9 18		      lda	#<DF0FRACDATA
    801  1c8b		       85 11		      sta	RESP1	;63
      0  1c8d					      sleep	3
      1  1c8d				   .CYCLES    SET	3
      2  1c8d
      3  1c8d				  -	      IF	.CYCLES < 2
      4  1c8d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c8d				  -	      ERR
      6  1c8d					      ENDIF
      7  1c8d
      8  1c8d					      IF	.CYCLES & 1
      9  1c8d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c8d		       04 00		      nop	0
     11  1c8f				  -	      ELSE
     12  1c8f				  -	      bit	VSYNC
     13  1c8f					      ENDIF
     14  1c8f				   .CYCLES    SET	.CYCLES - 3
     15  1c8f					      ENDIF
     16  1c8f
     17  1c8f				  -	      REPEAT	.CYCLES / 2
     18  1c8f				  -	      nop
     19  1c8f					      REPEND
    803  1c8f		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    804  1c91		       4c 71 1a 	      jmp	loop	;72
    805  1c94
    806  1c94				   kernel10
    807  1c94		       a9 12		      lda	#<DF2DATAW
    808  1c96		       85 1b		      STA	GRP0	; 25 (VDEL)
    809  1c98		       a9 23		      lda	#<DF3FLAG
    810  1c9a		       85 1f		      STA	ENABL	; 30 (VDEL)
    811  1c9c		       a9 19		      lda	#<DF1FRACDATA
    812  1c9e		       85 0f		      STA	PF2	; 35
    813  1ca0		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    814  1ca2		       85 05		      STA	NUSIZ1	; 40
    815  1ca4		       85 0c		      STA	REFP1	; 43
    816  1ca6		       a9 1a		      lda	#<DF2FRACDATA	;45
    817  1ca8		       85 0f		      sta	PF2	; 48
    818  1caa		       a9 1b		      lda	#<DF3FRACDATA	;50
    819  1cac		       85 0e		      sta	PF1	; 53
      0  1cae					      sleep	6
      1  1cae				   .CYCLES    SET	6
      2  1cae
      3  1cae				  -	      IF	.CYCLES < 2
      4  1cae				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cae				  -	      ERR
      6  1cae					      ENDIF
      7  1cae
      8  1cae				  -	      IF	.CYCLES & 1
      9  1cae				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cae				  -	      nop	0
     11  1cae				  -	      ELSE
     12  1cae				  -	      bit	VSYNC
     13  1cae				  -	      ENDIF
     14  1cae				  -.CYCLES    SET	.CYCLES - 3
     15  1cae					      ENDIF
     16  1cae
     17  1cae					      REPEAT	.CYCLES / 2
     18  1cae		       ea		      nop
     17  1cae					      REPEND
     18  1caf		       ea		      nop
     17  1caf					      REPEND
     18  1cb0		       ea		      nop
     19  1cb1					      REPEND
    821  1cb1		       a9 18		      lda	#<DF0FRACDATA
    822  1cb3		       ae 08 10 	      LDX	DF0DATA	; 65
    823  1cb6		       85 11		      sta	RESP1	; 68
    824  1cb8		       85 0e		      STA	PF1	; 71
    825  1cba		       a9 09		      lda	#<DF1DATA	; 74
    826  1cbc		       86 06		      STX	COLUP0	; 0
    827  1cbe		       4c 77 1a 	      jmp	loop2	; 3
    828  1cc1
    829  1cc1				   kernel11
    830  1cc1		       a9 12		      lda	#<DF2DATAW
    831  1cc3		       85 1b		      STA	GRP0	; (VDEL)
    832  1cc5		       a9 23		      lda	#<DF3FLAG
    833  1cc7		       85 1f		      STA	ENABL	; (VDEL)
    834  1cc9		       a9 19		      lda	#<DF1FRACDATA
    835  1ccb		       85 0f		      STA	PF2	; 35
    836  1ccd		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    837  1ccf		       85 05		      STA	NUSIZ1
    838  1cd1		       85 0c		      STA	REFP1
    839  1cd3		       a9 1a		      lda	#<DF2FRACDATA	;45
    840  1cd5		       85 0f		      sta	PF2	; 48
    841  1cd7		       a9 1b		      lda	#<DF3FRACDATA	;50
    842  1cd9		       85 0e		      sta	PF1	; 53
      0  1cdb					      sleep	3
      1  1cdb				   .CYCLES    SET	3
      2  1cdb
      3  1cdb				  -	      IF	.CYCLES < 2
      4  1cdb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cdb				  -	      ERR
      6  1cdb					      ENDIF
      7  1cdb
      8  1cdb					      IF	.CYCLES & 1
      9  1cdb					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cdb		       04 00		      nop	0
     11  1cdd				  -	      ELSE
     12  1cdd				  -	      bit	VSYNC
     13  1cdd					      ENDIF
     14  1cdd				   .CYCLES    SET	.CYCLES - 3
     15  1cdd					      ENDIF
     16  1cdd
     17  1cdd				  -	      REPEAT	.CYCLES / 2
     18  1cdd				  -	      nop
     19  1cdd					      REPEND
    844  1cdd		       a9 19		      lda	#<DF1FRACDATA	;45
    845  1cdf		       85 0f		      sta	PF2	; 61
    846  1ce1		       ae 08 10 	      LDX	DF0DATA	; 65
    847  1ce4
    848  1ce4		       a9 18		      lda	#<DF0FRACDATA	; 67
    849  1ce6		       85 0e		      sta	PF1	; 70
    850  1ce8		       85 11		      sta	RESP1	; 73
    851  1cea		       86 06		      STX	COLUP0	; 0
    852  1cec		       a9 09		      lda	#<DF1DATA	; 2
    853  1cee		       85 07		      sta	COLUP1	; 5
    854  1cf0		       a9 0b		      lda	#<DF3DATA
    855  1cf2		       85 1c		      STA	GRP1	; 10
    856  1cf4		       a9 20		      lda	#<DF0FLAG
    857  1cf6		       85 1d		      STA	ENAM0	; 25
    858  1cf8		       a9 1e		      lda	#<DF6FRACDATA
    859  1cfa		       85 09		      STA	COLUBK	; 20
    860  1cfc		       a9 1c		      lda	#<DF4FRACDATA
    861  1cfe		       85 08		      sta	COLUPF	; 25
      0  1d00					      sleep	3
      1  1d00				   .CYCLES    SET	3
      2  1d00
      3  1d00				  -	      IF	.CYCLES < 2
      4  1d00				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1d00				  -	      ERR
      6  1d00					      ENDIF
      7  1d00
      8  1d00					      IF	.CYCLES & 1
      9  1d00					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1d00		       04 00		      nop	0
     11  1d02				  -	      ELSE
     12  1d02				  -	      bit	VSYNC
     13  1d02					      ENDIF
     14  1d02				   .CYCLES    SET	.CYCLES - 3
     15  1d02					      ENDIF
     16  1d02
     17  1d02				  -	      REPEAT	.CYCLES / 2
     18  1d02				  -	      nop
     19  1d02					      REPEND
    863  1d02		       4c 8d 1a 	      jmp	loop3	; 31
    864  1d05
    865  1d05				   set_fetchers
    866  1d05		       ad 70 1d 	      lda	dflow
    867  1d08		       8d 50 10 	      sta	DF0LOW
    868  1d0b		       ad 78 1d 	      lda	dfhigh
    869  1d0e		       8d 68 10 	      sta	DF0HI
    870  1d11
    871  1d11		       ad 71 1d 	      lda	dflow+1
    872  1d14		       8d 51 10 	      sta	DF1LOW
    873  1d17		       ad 79 1d 	      lda	dfhigh+1
    874  1d1a		       8d 69 10 	      sta	DF1HI
    875  1d1d
    876  1d1d		       ad 72 1d 	      lda	dflow+2
    877  1d20		       8d 52 10 	      sta	DF2LOW
    878  1d23		       ad 7a 1d 	      lda	dfhigh+2
    879  1d26		       8d 6a 10 	      sta	DF2HI
    880  1d29
    881  1d29				   set_fetchers36		; sets just 3-6
    882  1d29		       ad 73 1d 	      lda	dflow+3
    883  1d2c		       8d 53 10 	      sta	DF3LOW
    884  1d2f		       ad 7b 1d 	      lda	dfhigh+3
    885  1d32		       8d 6b 10 	      sta	DF3HI
    886  1d35
    887  1d35		       ad 74 1d 	      lda	dflow+4
    888  1d38		       8d 54 10 	      sta	DF4LOW
    889  1d3b		       ad 7c 1d 	      lda	dfhigh+4
    890  1d3e		       8d 6c 10 	      sta	DF4HI
    891  1d41
    892  1d41		       ad 75 1d 	      lda	dflow+5
    893  1d44		       8d 55 10 	      sta	DF5LOW
    894  1d47		       ad 7d 1d 	      lda	dfhigh+5
    895  1d4a		       8d 6d 10 	      sta	DF5HI
    896  1d4d
    897  1d4d		       ad 76 1d 	      lda	dflow+6
    898  1d50		       8d 56 10 	      sta	DF6LOW
    899  1d53		       ad 7e 1d 	      lda	dfhigh+6
    900  1d56		       8d 6e 10 	      sta	DF6HI
    901  1d59
    902  1d59		       60		      rts
    903  1d5a
    904  1d5a							;9d bad
    905  1d5a							; the below isn't quite right
    906  1d5a							;DF0DATA: COLUP0
    907  1d5a							;DF1DATA: COLUP1
    908  1d5a							;DF2DATAW: GRP0
    909  1d5a							;DF3DATA: GRP1 
    910  1d5a							;DF4DATA: 2lk lines until repos/HMP1
    911  1d5a							;DF5DATA: low byte of repo kernels (xpos mod 15)
    912  1d5a							;DF6DATA: High byte of repo kernels (x pos div 15)
    913  1d5a							;DF7DATA: Programmer's stack
    914  1d5a							;DF0FRACDATA: PF1L
    915  1d5a							;DF1FRACDATA: PF2L
    916  1d5a							;DF4FRACDATA: COLUPF
    917  1d5a							;DF2FRACDATA: PF2R
    918  1d5a							;DF3FRACDATA: PF2L
    919  1d5a							;DF5FRACDATA: Sprite NUSIZ1/REFP1 (only during repos)
    920  1d5a							;DF6FRACDATA: COLUBK
    921  1d5a							;DF7FRACDATA: HMP1
    922  1d5a							;DF3FLAG: kernel exit loop ?? (use flags instead?)
    923  1d5a							;DF0FLAG: ENAM0
    924  1d5a							;DF1FLAG: ENAM1 
    925  1d5a							;DF3FLAG: ENABL 
    926  1d5a
    927  1d5a				   fetcher_address_table
    928  1d5a				   kernello
    929  1d5a		       3a		      .byte.b	<kernel1
    930  1d5b		       5c		      .byte.b	<kernel2
    931  1d5c		       7e		      .byte.b	<kernel3
    932  1d5d		       a0		      .byte.b	<kernel4
    933  1d5e		       c2		      .byte.b	<kernel5
    934  1d5f		       e4		      .byte.b	<kernel6
    935  1d60		       28		      .byte.b	<kernel7
    936  1d61		       4a		      .byte.b	<kernel8
    937  1d62		       6c		      .byte.b	<kernel9
    938  1d63		       94		      .byte.b	<kernel10
    939  1d64		       c1		      .byte.b	<kernel11
    940  1d65				   kernelhi
    941  1d65		       1b		      .byte.b	>kernel1
    942  1d66		       1b		      .byte.b	>kernel2
    943  1d67		       1b		      .byte.b	>kernel3
    944  1d68		       1b		      .byte.b	>kernel4
    945  1d69		       1b		      .byte.b	>kernel5
    946  1d6a		       1b		      .byte.b	>kernel6
    947  1d6b		       1c		      .byte.b	>kernel7
    948  1d6c		       1c		      .byte.b	>kernel8
    949  1d6d		       1c		      .byte.b	>kernel9
    950  1d6e		       1c		      .byte.b	>kernel10
    951  1d6f		       1c		      .byte.b	>kernel11
    952  1d70				   dflow
    953  1d70		       08		      .byte.b	<P0COLOR
    954  1d71		       08		      .byte.b	<P1COLOR
    955  1d72		       08		      .byte.b	<P0GFX
    956  1d73		       08		      .byte.b	<P1GFX
    957  1d74		       2d		      .byte.b	<P1SKIP
    958  1d75		       08		      .byte.b	<JUMPTABLELO
    959  1d76		       14		      .byte.b	<JUMPTABLEHI
    960  1d77		       a5		      .byte.b	<USERSTACK
    961  1d78				   dfhigh
    962  1d78		       05		      .byte.b	(>P0COLOR) & $0F
    963  1d79		       03		      .byte.b	(>P1COLOR) & $0F
    964  1d7a		       04		      .byte.b	(>P0GFX) & $0F
    965  1d7b		       02		      .byte.b	(>P1GFX) & $0F
    966  1d7c		       0b		      .byte.b	(>P1SKIP) & $0F
    967  1d7d		       0b		      .byte.b	(>JUMPTABLELO) & $0F
    968  1d7e		       0b		      .byte.b	(>JUMPTABLEHI) & $0F
    969  1d7f		       0d		      .byte.b	(>USERSTACK) & $0F
    970  1d80				   dffraclow
    971  1d80		       08		      .byte.b	<PF1L
    972  1d81		       08		      .byte.b	<PF2L
    973  1d82		       08		      .byte.b	<PF1R
    974  1d83		       08		      .byte.b	<PF2R
    975  1d84		       08		      .byte.b	<PFCOLS
    976  1d85		       39		      .byte.b	<NUSIZREFP
    977  1d86		       a5		      .byte.b	<BKCOLS
    978  1d87		       20		      .byte.b	<P1HMP
    979  1d88				   dffrachi
    980  1d88		       06		      .byte.b	(>PF1L) & $0F
    981  1d89		       07		      .byte.b	(>PF2L) & $0F
    982  1d8a		       08		      .byte.b	(>PF1R) & $0F
    983  1d8b		       09		      .byte.b	(>PF2R) & $0F
    984  1d8c		       0a		      .byte.b	(>PFCOLS) & $0F
    985  1d8d		       0b		      .byte.b	(>NUSIZREFP) & $0F
    986  1d8e		       0b		      .byte.b	(>BKCOLS) & $0F
    987  1d8f		       0b		      .byte.b	(>P1HMP) & $0F
    988  1d90				   scorepointer
    989  1d90		       94		      .byte.b	<scoretable
    990  1d91		       08		      .byte.b	((>scoretable) & $0f) | (((>scoretable) / 2) & $70)
    991  1d92				   scoresetup		; pointers to digit graphics
    992  1d92		       45		      .byte.b	<scoredata
    993  1d93		       0b		      .byte.b	(>scoredata) & $0F
    994  1d94				   Hmval		; 112 wuz first
    995  1d94		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240
    996  1d9c				   Hmval74
    997  1d9c		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128
    998  1da3		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96
    999  1db3		       50 40 30 20*	      .byte.b	80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80
   1000  1dc3		       40 30 20 10*	      .byte.b	64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64
   1001  1dd3		       30 20 10 01*	      .byte.b	48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48
   1002  1de3		       20 10 01 f0*	      .byte.b	32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32
   1003  1df3		       10 01 f0 e0*	      .byte.b	16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16
   1004  1e03		       01 f0 e0 d0*	      .byte.b	1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1
   1005  1e13		       f0 e0 d0 c0*	      .byte.b	240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240
   1006  1e23		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192
   1007  1e35		       b0 a0 90 80*	      .byte.b	176,160,144,128,16,1,240,224
   1008  1e3d
   1009  1e3d
   1010  1e3d				   kernel_setup
   1011  1e3d							;--position P0, top P1, M0, M1, BL
   1012  1e3d		       a2 00		      ldx	#0	; first sprite displayed
   1013  1e3f		       b5 85		      lda	SpriteGfxIndex,x
   1014  1e41		       aa		      tax
   1015  1e42		       b5 90		      lda	player1x,x
   1016  1e44		       c9 a0		      cmp	#160
   1017  1e46		       90 0a		      bcc	nostorep1
   1018  1e48		       c9 d0		      cmp	#208
   1019  1e4a		       b0 02		      bcs	ksadjustdown
   1020  1e4c							; 160-208: minus 160
   1021  1e4c							;add 160 is like minus 96
   1022  1e4c							; so minus 64
   1023  1e4c		       e9 3f		      sbc	#63	;cc
   1024  1e4e				   ksadjustdown
   1025  1e4e							; 209-255: add 160 
   1026  1e4e		       69 9f		      adc	#159	; cs
   1027  1e50		       95 90		      sta	player1x,x
   1028  1e52				   nostorep1
   1029  1e52		       85 02		      sta	WSYNC
   1030  1e54		       a2 04		      ldx	#4
   1031  1e56		       85 81		      sta	topP1x	; cache top p1
   1032  1e58				   HorPosLoop
   1033  1e58		       b5 80		      lda	player0x,X
   1034  1e5a		       38		      sec
   1035  1e5b				   DivideLoop
   1036  1e5b		       e9 0f		      sbc	#15
   1037  1e5d		       b0 fc		      bcs	DivideLoop
      0  1e5f					      sleep	4
      1  1e5f				   .CYCLES    SET	4
      2  1e5f
      3  1e5f				  -	      IF	.CYCLES < 2
      4  1e5f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1e5f				  -	      ERR
      6  1e5f					      ENDIF
      7  1e5f
      8  1e5f				  -	      IF	.CYCLES & 1
      9  1e5f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1e5f				  -	      nop	0
     11  1e5f				  -	      ELSE
     12  1e5f				  -	      bit	VSYNC
     13  1e5f				  -	      ENDIF
     14  1e5f				  -.CYCLES    SET	.CYCLES - 3
     15  1e5f					      ENDIF
     16  1e5f
     17  1e5f					      REPEAT	.CYCLES / 2
     18  1e5f		       ea		      nop
     17  1e5f					      REPEND
     18  1e60		       ea		      nop
     19  1e61					      REPEND
   1039  1e61		       95 10		      sta	RESP0,X
   1040  1e63		       85 02		      sta	WSYNC
   1041  1e65		       ca		      dex		;2
   1042  1e66		       10 f0		      bpl	HorPosLoop	;4/5
   1043  1e68
   1044  1e68		       a4 80		      ldy	player0x	; 7
   1045  1e6a		       b9 94 1d 	      lda	Hmval,y	; 11
   1046  1e6d		       85 20		      sta	HMP0	; 14
   1047  1e6f
   1048  1e6f		       a4 81		      ldy	player0x+1
   1049  1e71		       b9 94 1d 	      lda	Hmval,y
   1050  1e74		       85 21		      sta	HMP0+1	; 24
   1051  1e76
   1052  1e76		       a4 82		      ldy	player0x+2
   1053  1e78		       b9 94 1d 	      lda	Hmval,y
   1054  1e7b		       85 22		      sta	HMP0+2	; 34
   1055  1e7d
   1056  1e7d		       a4 83		      ldy	player0x+3
   1057  1e7f		       b9 94 1d 	      lda	Hmval,y
   1058  1e82		       85 23		      sta	HMP0+3	; 44
   1059  1e84
   1060  1e84		       a4 84		      ldy	player0x+4
   1061  1e86		       b9 94 1d 	      lda	Hmval,y
   1062  1e89		       85 24		      sta	HMP0+4	; 54
   1063  1e8b
   1064  1e8b		       85 02		      sta	WSYNC
   1065  1e8d		       85 2a		      sta	HMOVE
   1066  1e8f
   1067  1e8f				   myrts
   1068  1e8f		       60		      rts
   1069  1e90
   1070  1e90
   1071  1e90				   pfsetup
   1072  1e90
   1073  1e90		       84 cb		      sty	temp1
   1074  1e92		       85 cc		      sta	temp2
   1075  1e94		       86 cd		      stx	temp3
   1076  1e96		       a2 03		      ldx	#3
   1077  1e98				   pfsetupp
   1078  1e98		       bd 80 1d 	      lda	dffraclow,x
   1079  1e9b		       9d 50 10 	      sta	DF0LOW,x
   1080  1e9e		       bd 88 1d 	      lda	dffrachi,x
   1081  1ea1		       9d 68 10 	      sta	DF0HI,x
   1082  1ea4		       a5 cc		      lda	temp2
   1083  1ea6		       8d 59 10 	      sta	PARAMETER
   1084  1ea9		       a5 cd		      lda	temp3
   1085  1eab		       8d 59 10 	      sta	PARAMETER
   1086  1eae		       8e 59 10 	      stx	PARAMETER
   1087  1eb1		       8c 59 10 	      sty	PARAMETER
   1088  1eb4		       a9 01		      LDA	#1
   1089  1eb6		       8d 5a 10 	      sta	CALLFUNCTION
   1090  1eb9		       18		      clc
   1091  1eba		       a5 cc		      lda	temp2
   1092  1ebc		       65 cb		      adc	temp1
   1093  1ebe		       85 cc		      sta	temp2
   1094  1ec0		       a5 cd		      lda	temp3
   1095  1ec2		       69 00		      adc	#0
   1096  1ec4		       85 cd		      sta	temp3
   1097  1ec6		       ca		      dex
   1098  1ec7		       10 cf		      bpl	pfsetupp
      0  1ec9					      RETURN
      1  1ec9				  -	      ifnconst	bankswitch
      2  1ec9				  -	      rts
      3  1ec9					      else
      4  1ec9		       4c e0 df 	      jmp	BS_return
      5  1ecc					      endif
   1100  1ecc
   1101  1ecc
   1102  1ecc				   scorekernel
   1103  1ecc				  -	      ifconst	minikernel
   1104  1ecc				  -			;; disable fast fetch, call the minikernel, and re-enable fast fetch
   1105  1ecc				  -	      lda	#255
   1106  1ecc				  -	      sta	FASTFETCH
   1107  1ecc				  -	      jsr	minikernel
   1108  1ecc				  -	      lda	#0
   1109  1ecc				  -	      sta.w	FASTFETCH
   1110  1ecc					      endif
   1111  1ecc		       a6 eb		      ldx	scorecolor
   1112  1ece		       86 06		      stx	COLUP0
   1113  1ed0		       86 07		      stx	COLUP1
   1114  1ed2		       a2 00		      ldx	#0
   1115  1ed4		       86 0e		      STx	PF1
   1116  1ed6		       86 0b		      stx	REFP0
   1117  1ed8		       86 0c		      stx	REFP1
   1118  1eda		       86 1b		      STx	GRP0
   1119  1edc		       86 1c		      STx	GRP1
   1120  1ede		       86 0f		      STx	PF2
   1121  1ee0		       86 2b		      stx	HMCLR
   1122  1ee2		       86 1d		      stx	ENAM0
   1123  1ee4		       86 1e		      stx	ENAM1
   1124  1ee6		       86 1f		      stx	ENABL
   1125  1ee8
   1126  1ee8
   1127  1ee8				  -	      ifconst	pfscore
   1128  1ee8				  -	      lda	pfscorecolor
   1129  1ee8				  -	      sta	COLUPF
   1130  1ee8					      endif
   1131  1ee8
   1132  1ee8				  -	      ifconst	noscore
   1133  1ee8				  -	      ldx	#10
   1134  1ee8				  -noscoreloop
   1135  1ee8				  -	      sta	WSYNC
   1136  1ee8				  -	      dex
   1137  1ee8				  -	      bpl	noscoreloop
   1138  1ee8				  -	      rts
   1139  1ee8					      else
   1140  1ee8
   1141  1ee8		       85 2b		      sta	HMCLR
   1142  1eea		       a2 f0		      ldx	#$f0
   1143  1eec		       86 20		      stx	HMP0
   1144  1eee
   1145  1eee							; set up fetchers 0-5 to handle score digits
   1146  1eee		       a2 45		      ldx	#<(scoredata)
   1147  1ef0		       8e 56 10 	      stx	DF6LOW
   1148  1ef3		       a2 0b		      ldx	#(>(scoredata)) & $0F
   1149  1ef5		       8e 6e 10 	      stx	DF6HI
   1150  1ef8		       a2 4d		      ldx	#<(scoredata+8)
   1151  1efa		       8e 50 10 	      stx	DF0LOW
   1152  1efd		       a2 0b		      ldx	#(>(scoredata+8)) & $0F
   1153  1eff		       8e 68 10 	      stx	DF0HI
   1154  1f02		       a2 55		      ldx	#<(scoredata+16)
   1155  1f04		       8e 51 10 	      stx	DF1LOW
   1156  1f07							; cycle 0??
   1157  1f07		       a2 0b		      ldx	#(>(scoredata+16)) & $0F
   1158  1f09		       8e 69 10 	      stx	DF1HI
   1159  1f0c		       a2 5d		      ldx	#<(scoredata+24)
   1160  1f0e		       8e 52 10 	      stx	DF2LOW
   1161  1f11		       a2 0b		      ldx	#(>(scoredata+24)) & $0F
   1162  1f13		       8e 6a 10 	      stx	DF2HI
   1163  1f16
   1164  1f16		       85 02		      sta	WSYNC
   1165  1f18		       a2 00		      ldx	#0
   1166  1f1a		       86 1b		      STx	GRP0
   1167  1f1c		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1168  1f1e
   1169  1f1e		       a2 65		      ldx	#<(scoredata+32)
   1170  1f20		       8e 53 10 	      stx	DF3LOW
   1171  1f23		       a2 0b		      ldx	#(>(scoredata+32)) & $0F
   1172  1f25		       8e 6b 10 	      stx	DF3HI
   1173  1f28		       a2 6d		      ldx	#<(scoredata+40)
   1174  1f2a		       8e 54 10 	      stx	DF4LOW
   1175  1f2d		       a2 0b		      ldx	#(>(scoredata+40)) & $0F
   1176  1f2f		       8e 6c 10 	      stx	DF4HI
   1177  1f32
   1178  1f32		       a0 07		      LDY	#7
   1179  1f34		       a2 03		      LDx	#$03
   1180  1f36		       84 25		      STY	VDELP0
   1181  1f38		       85 10		      STA	RESP0
   1182  1f3a		       85 11		      STA	RESP1
   1183  1f3c		       84 cb		      sty	temp1
   1184  1f3e
   1185  1f3e		       86 04		      STx	NUSIZ0
   1186  1f40		       86 05		      STx	NUSIZ1
   1187  1f42		       86 26		      STx	VDELP1
   1188  1f44		       a2 75		      ldx	#<(scoredata+48)
   1189  1f46		       8e 55 10 	      stx	DF5LOW
   1190  1f49		       a2 0b		      ldx	#(>(scoredata+48)) & $0F
   1191  1f4b		       8e 6d 10 	      stx	DF5HI
   1192  1f4e		       8d 2a 00 	      STA.w	HMOVE	; cycle 73 ?
   1193  1f51				   scoreloop
   1194  1f51		       a9 0e		      lda	#<DF6DATA	;59
   1195  1f53		       85 06		      sta	COLUP0	;62
   1196  1f55		       85 07		      sta	COLUP1	;65
   1197  1f57		       a9 09		      lda	#<DF1DATA	;75
   1198  1f59		       85 1b		      sta	GRP0	;2
   1199  1f5b		       a9 08		      lda	#<DF0DATA	;4
   1200  1f5d		       85 1c		      sta	GRP1	;7
   1201  1f5f		       a9 0b		      lda	#<DF3DATA	;9
   1202  1f61		       85 1b		      sta	GRP0	;12
   1203  1f63
   1204  1f63							; REVENG - rearranged to correct pf write timing and A register overwrite
   1205  1f63				  -	      ifconst	pfscore
   1206  1f63				  -	      lda	pfscore1
   1207  1f63				  -	      sta	PF1
   1208  1f63					      else
      0  1f63					      sleep	6
      1  1f63				   .CYCLES    SET	6
      2  1f63
      3  1f63				  -	      IF	.CYCLES < 2
      4  1f63				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f63				  -	      ERR
      6  1f63					      ENDIF
      7  1f63
      8  1f63				  -	      IF	.CYCLES & 1
      9  1f63				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f63				  -	      nop	0
     11  1f63				  -	      ELSE
     12  1f63				  -	      bit	VSYNC
     13  1f63				  -	      ENDIF
     14  1f63				  -.CYCLES    SET	.CYCLES - 3
     15  1f63					      ENDIF
     16  1f63
     17  1f63					      REPEAT	.CYCLES / 2
     18  1f63		       ea		      nop
     17  1f63					      REPEND
     18  1f64		       ea		      nop
     17  1f64					      REPEND
     18  1f65		       ea		      nop
     19  1f66					      REPEND
   1210  1f66					      endif
      0  1f66					      sleep	5
      1  1f66				   .CYCLES    SET	5
      2  1f66
      3  1f66				  -	      IF	.CYCLES < 2
      4  1f66				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f66				  -	      ERR
      6  1f66					      ENDIF
      7  1f66
      8  1f66					      IF	.CYCLES & 1
      9  1f66					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f66		       04 00		      nop	0
     11  1f68				  -	      ELSE
     12  1f68				  -	      bit	VSYNC
     13  1f68					      ENDIF
     14  1f68				   .CYCLES    SET	.CYCLES - 3
     15  1f68					      ENDIF
     16  1f68
     17  1f68					      REPEAT	.CYCLES / 2
     18  1f68		       ea		      nop
     19  1f69					      REPEND
   1212  1f69		       ae 0a 10 	      ldx	DF2DATA	;16
   1213  1f6c		       ac 0d 10 	      ldy	DF5DATA	;20
   1214  1f6f		       a9 0c		      lda	#<DF4DATA	;22 
   1215  1f71
   1216  1f71		       86 1c		      stx	GRP1	;40
   1217  1f73		       84 1b		      sty	GRP0	;43
   1218  1f75		       85 1c		      sta	GRP1	;46
   1219  1f77		       85 1b		      sta	GRP0	;49
   1220  1f79				  -	      ifconst	pfscore
   1221  1f79				  -	      lda	pfscore2
   1222  1f79				  -	      sta	PF1
   1223  1f79					      else
      0  1f79					      sleep	6
      1  1f79				   .CYCLES    SET	6
      2  1f79
      3  1f79				  -	      IF	.CYCLES < 2
      4  1f79				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f79				  -	      ERR
      6  1f79					      ENDIF
      7  1f79
      8  1f79				  -	      IF	.CYCLES & 1
      9  1f79				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f79				  -	      nop	0
     11  1f79				  -	      ELSE
     12  1f79				  -	      bit	VSYNC
     13  1f79				  -	      ENDIF
     14  1f79				  -.CYCLES    SET	.CYCLES - 3
     15  1f79					      ENDIF
     16  1f79
     17  1f79					      REPEAT	.CYCLES / 2
     18  1f79		       ea		      nop
     17  1f79					      REPEND
     18  1f7a		       ea		      nop
     17  1f7a					      REPEND
     18  1f7b		       ea		      nop
     19  1f7c					      REPEND
   1225  1f7c					      endif
   1226  1f7c							; sleep 2 ;57
      0  1f7c					      sleep	6
      1  1f7c				   .CYCLES    SET	6
      2  1f7c
      3  1f7c				  -	      IF	.CYCLES < 2
      4  1f7c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f7c				  -	      ERR
      6  1f7c					      ENDIF
      7  1f7c
      8  1f7c				  -	      IF	.CYCLES & 1
      9  1f7c				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f7c				  -	      nop	0
     11  1f7c				  -	      ELSE
     12  1f7c				  -	      bit	VSYNC
     13  1f7c				  -	      ENDIF
     14  1f7c				  -.CYCLES    SET	.CYCLES - 3
     15  1f7c					      ENDIF
     16  1f7c
     17  1f7c					      REPEAT	.CYCLES / 2
     18  1f7c		       ea		      nop
     17  1f7c					      REPEND
     18  1f7d		       ea		      nop
     17  1f7d					      REPEND
     18  1f7e		       ea		      nop
     19  1f7f					      REPEND
   1228  1f7f		       c6 cb		      dec	temp1	;70
   1229  1f81		       10 ce		      bpl	scoreloop	;72/73
   1230  1f83		       a2 00		      LDx	#0
   1231  1f85		       86 0e		      stx	PF1
   1232  1f87		       86 1b		      STx	GRP0
   1233  1f89		       86 1c		      STx	GRP1
   1234  1f8b		       86 25		      STx	VDELP0
   1235  1f8d		       86 26		      STx	VDELP1	;do we need these
   1236  1f8f		       86 04		      STx	NUSIZ0
   1237  1f91		       86 05		      STx	NUSIZ1
   1238  1f93
   1239  1f93		       60		      rts
   1240  1f94
   1241  1f94
   1242  1f94					      endif		; noscore
   1243  1f94				   game
   1244  1f94				   .
   1245  1f94							; 
   1246  1f94
   1247  1f94				   .L00 		;  temp1  =  temp1
   1248  1f94
   1249  1f94		       a5 cb		      LDA	temp1
   1250  1f96		       85 cb		      STA	temp1
   1251  1f98				   .L01 		;  set kernel DPC + 
   1252  1f98
   1253  1f98				   .L02 		;  set tv ntsc
   1254  1f98
   1255  1f98				   .L03 		;  set smartbranching on
   1256  1f98
   1257  1f98				   .
   1258  1f98							; 
   1259  1f98
   1260  1f98				   .
   1261  1f98							; 
   1262  1f98
   1263  1f98				   .
   1264  1f98							; 
   1265  1f98
   1266  1f98				   .L04 		;  goto init bank2
   1267  1f98
   1268  1f98		       85 81		      sta	temp7
   1269  1f9a		       a9 30		      lda	#>(.init-1)
   1270  1f9c		       48		      pha
   1271  1f9d		       a9 a3		      lda	#<(.init-1)
   1272  1f9f		       48		      pha
   1273  1fa0		       a5 81		      lda	temp7
   1274  1fa2		       48		      pha
   1275  1fa3		       8a		      txa
   1276  1fa4		       48		      pha
   1277  1fa5		       a2 02		      ldx	#2
   1278  1fa7		       4c ee df 	      jmp	BS_jsr
   1279  1faa				   .
   1280  1faa							; 
   1281  1faa
   1282  1faa				   .L05 		;  bank 2
   1283  1faa
   1284  1faa					      if	ECHO1
      42 bytes of ROM space left in bank 1
   1285  1faa					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1286  1faa					      endif
   1287  1faa		       00 01	   ECHO1      =	1
   1288  1fd4					      ORG	$1FF4-bscode_length
   1289  1fd4					      RORG	$1FF4-bscode_length
   1290  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1291  1fd6					      ifconst	FASTFETCH	; using DPC+
   1292  1fd6		       8e 58 10 	      stx	FASTFETCH
   1293  1fd9					      endif
   1294  1fd9		       9a		      txs
   1295  1fda				  -	      if	bankswitch == 64
   1296  1fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1297  1fda					      else
   1298  1fda		       a9 18		      lda	#>(start-1)
   1299  1fdc					      endif
   1300  1fdc		       48		      pha
   1301  1fdd		       a9 eb		      lda	#<(start-1)
   1302  1fdf		       48		      pha
   1303  1fe0		       48		      pha
   1304  1fe1		       8a		      txa
   1305  1fe2		       48		      pha
   1306  1fe3		       ba		      tsx
   1307  1fe4					      if	bankswitch != 64
   1308  1fe4		       b5 04		      lda	4,x	; get high byte of return address
   1309  1fe6		       2a		      rol
   1310  1fe7		       2a		      rol
   1311  1fe8		       2a		      rol
   1312  1fe9		       2a		      rol
   1313  1fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1314  1fec		       aa		      tax
   1315  1fed		       e8		      inx
   1316  1fee				  -	      else
   1317  1fee				  -	      lda	4,x	; get high byte of return address
   1318  1fee				  -	      tay
   1319  1fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1320  1fee				  -	      sta	4,x
   1321  1fee				  -	      tya
   1322  1fee				  -	      lsr
   1323  1fee				  -	      lsr
   1324  1fee				  -	      lsr
   1325  1fee				  -	      lsr
   1326  1fee				  -	      tax
   1327  1fee				  -	      inx
   1328  1fee					      endif
   1329  1fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1330  1ff1		       68		      pla
   1331  1ff2		       aa		      tax
   1332  1ff3		       68		      pla
   1333  1ff4		       60		      rts
   1334  1ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1335  1ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1336  1ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1337  1ff5					      endif
   1338  1ffc					      ORG	$1FFC
   1339  1ffc					      RORG	$1FFC
   1340  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1341  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1342  2000					      ORG	$2000
   1343  2000					      RORG	$3000
   1344  2000				   HMdiv
   1345  2000		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0
   1346  2007		       01 01 01 01*	      .byte.b	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
   1347  2017		       02 02 02 02*	      .byte.b	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3
   1348  2027		       03 03 03 03*	      .byte.b	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4
   1349  2037		       04 04 04 04*	      .byte.b	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5
   1350  2047		       05 05 05 05*	      .byte.b	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6
   1351  2057		       06 06 06 06*	      .byte.b	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   1352  2067		       07 07 07 07*	      .byte.b	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
   1353  2077		       08 08 08 08*	      .byte.b	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9
   1354  2087		       09 09 09 09*	      .byte.b	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10
   1355  2097		       0a 0a 0a 0a*	      .byte.b	10,10,10,10,10,10,0,0,0
   1356  20a0				   .L06 		;  temp1  =  temp1
   1357  20a0
   1358  20a0		       a5 cb		      LDA	temp1
   1359  20a2		       85 cb		      STA	temp1
   1360  20a4				   .init
   1361  20a4							; init
   1362  20a4
   1363  20a4				   .
   1364  20a4							; 
   1365  20a4
   1366  20a4				   .L07 		;  bkcolors:
   1367  20a4
   1368  20a4		       a9 a5		      LDA	#<BKCOLS
   1369  20a6		       8d 50 10 	      STA	DF0LOW
   1370  20a9		       a9 0b		      LDA	#(>BKCOLS) & $0F
   1371  20ab		       8d 68 10 	      STA	DF0HI
   1372  20ae		       a9 ac		      LDA	#<backgroundcolorL07
   1373  20b0		       8d 59 10 	      STA	PARAMETER
   1374  20b3		       a9 61		      LDA	#((>backgroundcolorL07) & $0f) | (((>backgroundcolorL07) / 2) & $70)
   1375  20b5		       8d 59 10 	      STA	PARAMETER
   1376  20b8		       a9 00		      LDA	#0
   1377  20ba		       8d 59 10 	      STA	PARAMETER
   1378  20bd		       a9 01		      LDA	#1
   1379  20bf		       8d 59 10 	      STA	PARAMETER
   1380  20c2		       a9 01		      LDA	#1
   1381  20c4		       8d 5a 10 	      STA	CALLFUNCTION
   1382  20c7				   .
   1383  20c7							; 
   1384  20c7
   1385  20c7				   .
   1386  20c7							; 
   1387  20c7
   1388  20c7				   .L08 		;  if !INPT0{7}  &&  INPT1{7} then quadtariDetected
   1389  20c7
   1390  20c7		       24 08		      BIT	INPT0
   1391  20c9		       30 04		      BMI	.skipL08
   1392  20cb				   .condpart0
   1393  20cb		       24 09		      BIT	INPT1
   1394  20cd					      if	((* - .quadtariDetected) < 127) && ((* - .quadtariDetected) > -128)
   1395  20cd		       30 2b		      bmi	.quadtariDetected
   1396  20cf				  -	      else
   1397  20cf				  -	      bpl	.0skipquadtariDetected
   1398  20cf				  -	      jmp	.quadtariDetected
   1399  20cf				  -.0skipquadtariDetected
   1400  20cf					      endif
   1401  20cf				   .skipL08
   1402  20cf				   .L09 		;  if !INPT2{7}  &&  INPT3{7} then quadtariDetected
   1403  20cf
   1404  20cf		       24 0a		      BIT	INPT2
   1405  20d1		       30 04		      BMI	.skipL09
   1406  20d3				   .condpart1
   1407  20d3		       24 0b		      BIT	INPT3
   1408  20d5					      if	((* - .quadtariDetected) < 127) && ((* - .quadtariDetected) > -128)
   1409  20d5		       30 23		      bmi	.quadtariDetected
   1410  20d7				  -	      else
   1411  20d7				  -	      bpl	.1skipquadtariDetected
   1412  20d7				  -	      jmp	.quadtariDetected
   1413  20d7				  -.1skipquadtariDetected
   1414  20d7					      endif
   1415  20d7				   .skipL09
   1416  20d7				   .
   1417  20d7							; 
   1418  20d7
   1419  20d7				   .L010		;  bkcolors:
   1420  20d7
   1421  20d7		       a9 a5		      LDA	#<BKCOLS
   1422  20d9		       8d 50 10 	      STA	DF0LOW
   1423  20dc		       a9 0b		      LDA	#(>BKCOLS) & $0F
   1424  20de		       8d 68 10 	      STA	DF0HI
   1425  20e1		       a9 ad		      LDA	#<backgroundcolorL010
   1426  20e3		       8d 59 10 	      STA	PARAMETER
   1427  20e6		       a9 61		      LDA	#((>backgroundcolorL010) & $0f) | (((>backgroundcolorL010) / 2) & $70)
   1428  20e8		       8d 59 10 	      STA	PARAMETER
   1429  20eb		       a9 00		      LDA	#0
   1430  20ed		       8d 59 10 	      STA	PARAMETER
   1431  20f0		       a9 01		      LDA	#1
   1432  20f2		       8d 59 10 	      STA	PARAMETER
   1433  20f5		       a9 01		      LDA	#1
   1434  20f7		       8d 5a 10 	      STA	CALLFUNCTION
   1435  20fa				   .quadtariDetected
   1436  20fa							; quadtariDetected
   1437  20fa
   1438  20fa				   .
   1439  20fa							; 
   1440  20fa
   1441  20fa				   .L011		;  const scorepointers = player1x
   1442  20fa
   1443  20fa				   .L012		;  rem *** The selected game number. The game selection minikernel displays 
   1444  20fa
   1445  20fa				   .L013		;  rem *** this variable
   1446  20fa
   1447  20fa				   .L014		;  dim gamenumber = y
   1448  20fa
   1449  20fa				   .L015		;  gamenumber = 1
   1450  20fa
   1451  20fa		       a9 01		      LDA	#1
   1452  20fc		       85 e9		      STA	gamenumber
   1453  20fe				   .
   1454  20fe							; 
   1455  20fe
   1456  20fe				   .L016		;  rem *** this debounce variable is used to slow down the game number selection
   1457  20fe
   1458  20fe				   .L017		;  dim swdebounce = b
   1459  20fe
   1460  20fe				   .L018		;  swdebounce = 0
   1461  20fe
   1462  20fe		       a9 00		      LDA	#0
   1463  2100		       85 d2		      STA	swdebounce
   1464  2102				   .
   1465  2102							; 
   1466  2102
   1467  2102				   .L019		;  rem *** this turns on the score fading effect. it looks especially pretty
   1468  2102
   1469  2102				   .L020		;  rem *** if you do a "scorecolor=scorecolor+1" every 2nd or 4th frame.
   1470  2102
   1471  2102				   .L021		;  const scorefade = 1
   1472  2102
   1473  2102				   .L022		;  scorecolor = $1a
   1474  2102
   1475  2102		       a9 1a		      LDA	#$1a
   1476  2104		       85 eb		      STA	scorecolor
   1477  2106				   .
   1478  2106							; 
   1479  2106
   1480  2106				   .titleLoop
   1481  2106							; titleLoop
   1482  2106
   1483  2106				   .
   1484  2106							; 
   1485  2106
   1486  2106				   .
   1487  2106							; 
   1488  2106
   1489  2106				   .
   1490  2106							; 
   1491  2106
   1492  2106				   .
   1493  2106							; 
   1494  2106
   1495  2106				   .
   1496  2106							; 
   1497  2106
   1498  2106				   .
   1499  2106							; 
   1500  2106
   1501  2106				   .
   1502  2106							; 
   1503  2106
   1504  2106				   .
   1505  2106							; 
   1506  2106
   1507  2106				   .
   1508  2106							; 
   1509  2106
   1510  2106				   .
   1511  2106							; 
   1512  2106
   1513  2106				   .gamestart
   1514  2106							; gamestart
   1515  2106
   1516  2106				   .
   1517  2106							; 
   1518  2106
   1519  2106				   .L023		;  player0:
   1520  2106
   1521  2106		       a2 ae		      LDX	#<playerL023_0
   1522  2108		       86 bd		      STX	player0pointerlo
   1523  210a		       a9 61		      LDA	#((>playerL023_0) & $0f) | (((>playerL023_0) / 2) & $70)
   1524  210c		       85 be		      STA	player0pointerhi
   1525  210e		       a9 08		      LDA	#8
   1526  2110		       85 a5		      STA	player0height
   1527  2112				   .
   1528  2112							; 
   1529  2112
   1530  2112				   .L024		;  player0color:
   1531  2112
   1532  2112		       a2 b6		      LDX	#<playercolorL024_0
   1533  2114		       86 a3		      STX	player0color
   1534  2116		       a9 61		      LDA	#((>playercolorL024_0) & $0f) | (((>playercolorL024_0) / 2) & $70)
   1535  2118		       85 a4		      STA	player0color+1
   1536  211a				   .
   1537  211a							; 
   1538  211a
   1539  211a				   .L025		;  player1-2:
   1540  211a
   1541  211a		       a9 e2		      lda	#<(playerpointers+0)
   1542  211c		       8d 50 10 	      sta	DF0LOW
   1543  211f		       a9 01		      lda	#(>(playerpointers+0)) & $0F
   1544  2121		       8d 68 10 	      sta	DF0HI
   1545  2124		       a2 be		      LDX	#<playerL025_1
   1546  2126		       8e 78 10 	      STX	DF0WRITE
   1547  2129		       a9 61		      LDA	#((>playerL025_1) & $0f) | (((>playerL025_1) / 2) & $70)
   1548  212b		       8d 78 10 	      STA	DF0WRITE
   1549  212e		       8e 78 10 	      STX	DF0WRITE
   1550  2131		       8d 78 10 	      STA	DF0WRITE
   1551  2134		       a9 08		      LDA	#8
   1552  2136		       85 a6		      STA	player1height
   1553  2138		       85 a7		      STA	player2height
   1554  213a				   .
   1555  213a							; 
   1556  213a
   1557  213a				   .L026		;  player1color:
   1558  213a
   1559  213a		       a9 f4		      lda	#<(playerpointers+18)
   1560  213c		       8d 50 10 	      sta	DF0LOW
   1561  213f		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   1562  2141		       8d 68 10 	      sta	DF0HI
   1563  2144		       a2 c6		      LDX	#<playercolorL026_1
   1564  2146		       8e 78 10 	      STX	DF0WRITE
   1565  2149		       a9 61		      LDA	#((>playercolorL026_1) & $0f) | (((>playercolorL026_1) / 2) & $70)
   1566  214b		       8d 78 10 	      STA	DF0WRITE
   1567  214e				   .
   1568  214e							; 
   1569  214e
   1570  214e				   .
   1571  214e							; 
   1572  214e
   1573  214e				   .
   1574  214e							; 
   1575  214e
   1576  214e				   .L027		;  playfield: 
   1577  214e
   1578  214e		       a0 16		      ldy	#22
   1579  2150		       a9 ce		      LDA	#<PF_data1
   1580  2152		       a2 61		      LDX	#((>PF_data1) & $0f) | (((>PF_data1) / 2) & $70)
   1581  2154		       85 81		      sta	temp7
   1582  2156		       a9 31		      lda	#>(ret_point1-1)
   1583  2158		       48		      pha
   1584  2159		       a9 6b		      lda	#<(ret_point1-1)
   1585  215b		       48		      pha
   1586  215c		       a9 1e		      lda	#>(pfsetup-1)
   1587  215e		       48		      pha
   1588  215f		       a9 8f		      lda	#<(pfsetup-1)
   1589  2161		       48		      pha
   1590  2162		       a5 81		      lda	temp7
   1591  2164		       48		      pha
   1592  2165		       8a		      txa
   1593  2166		       48		      pha
   1594  2167		       a2 01		      ldx	#1
   1595  2169		       4c ee df 	      jmp	BS_jsr
   1596  216c				   ret_point1
   1597  216c				   .L028		;  pfcolors:
   1598  216c
   1599  216c		       a9 08		      LDA	#<PFCOLS
   1600  216e		       8d 50 10 	      STA	DF0LOW
   1601  2171		       a9 0a		      LDA	#(>PFCOLS) & $0F
   1602  2173		       8d 68 10 	      STA	DF0HI
   1603  2176		       a9 26		      LDA	#<playfieldcolorL028
   1604  2178		       8d 59 10 	      STA	PARAMETER
   1605  217b		       a9 62		      LDA	#((>playfieldcolorL028) & $0f) | (((>playfieldcolorL028) / 2) & $70)
   1606  217d		       8d 59 10 	      STA	PARAMETER
   1607  2180		       a9 00		      LDA	#0
   1608  2182		       8d 59 10 	      STA	PARAMETER
   1609  2185		       a9 01		      LDA	#1
   1610  2187		       8d 59 10 	      STA	PARAMETER
   1611  218a		       a9 01		      LDA	#1
   1612  218c		       8d 5a 10 	      STA	CALLFUNCTION
   1613  218f				   .
   1614  218f							; 
   1615  218f
   1616  218f				   .
   1617  218f							; 
   1618  218f
   1619  218f				   .
   1620  218f							; 
   1621  218f
   1622  218f				   .
   1623  218f							; 
   1624  218f
   1625  218f				   .
   1626  218f							; 
   1627  218f
   1628  218f				   .
   1629  218f							; 
   1630  218f
   1631  218f				   .
   1632  218f							; 
   1633  218f
   1634  218f				   .
   1635  218f							; 
   1636  218f
   1637  218f				   .
   1638  218f							; 
   1639  218f
   1640  218f				   .
   1641  218f							; 
   1642  218f
   1643  218f				   .
   1644  218f							; 
   1645  218f
   1646  218f				   .
   1647  218f							; 
   1648  218f
   1649  218f				   .
   1650  218f							; 
   1651  218f
   1652  218f				   .
   1653  218f							; 
   1654  218f
   1655  218f				   .
   1656  218f							; 
   1657  218f
   1658  218f				   .
   1659  218f							; 
   1660  218f
   1661  218f				   .
   1662  218f							; 
   1663  218f
   1664  218f				   .
   1665  218f							; 
   1666  218f
   1667  218f				   .
   1668  218f							; 
   1669  218f
   1670  218f				   .
   1671  218f							; 
   1672  218f
   1673  218f				   .
   1674  218f							; 
   1675  218f
   1676  218f				   .
   1677  218f							; 
   1678  218f
   1679  218f				   .
   1680  218f							; 
   1681  218f
   1682  218f				   .
   1683  218f							; 
   1684  218f
   1685  218f				   .
   1686  218f							; 
   1687  218f
   1688  218f				   .
   1689  218f							; 
   1690  218f
   1691  218f				   .
   1692  218f							; 
   1693  218f
   1694  218f				   .
   1695  218f							; 
   1696  218f
   1697  218f				   .
   1698  218f							; 
   1699  218f
   1700  218f				   .
   1701  218f							; 
   1702  218f
   1703  218f				   .
   1704  218f							; 
   1705  218f
   1706  218f				   .
   1707  218f							; 
   1708  218f
   1709  218f				   .
   1710  218f							; 
   1711  218f
   1712  218f				   .
   1713  218f							; 
   1714  218f
   1715  218f				   .
   1716  218f							; 
   1717  218f
   1718  218f				   .
   1719  218f							; 
   1720  218f
   1721  218f				   .
   1722  218f							; 
   1723  218f
   1724  218f				   .
   1725  218f							; 
   1726  218f
   1727  218f				   .
   1728  218f							; 
   1729  218f
   1730  218f				   .
   1731  218f							; 
   1732  218f
   1733  218f				   .
   1734  218f							; 
   1735  218f
   1736  218f				   .
   1737  218f							; 
   1738  218f
   1739  218f				   .
   1740  218f							; 
   1741  218f
   1742  218f				   .
   1743  218f							; 
   1744  218f
   1745  218f				   .
   1746  218f							; 
   1747  218f
   1748  218f				   .
   1749  218f							; 
   1750  218f
   1751  218f				   .
   1752  218f							; 
   1753  218f
   1754  218f				   .
   1755  218f							; 
   1756  218f
   1757  218f				   .
   1758  218f							; 
   1759  218f
   1760  218f				   .
   1761  218f							; 
   1762  218f
   1763  218f				   .
   1764  218f							; 
   1765  218f
   1766  218f				   .
   1767  218f							; 
   1768  218f
   1769  218f				   .L029		;  bkcolors:
   1770  218f
   1771  218f		       a9 a5		      LDA	#<BKCOLS
   1772  2191		       8d 50 10 	      STA	DF0LOW
   1773  2194		       a9 0b		      LDA	#(>BKCOLS) & $0F
   1774  2196		       8d 68 10 	      STA	DF0HI
   1775  2199		       a9 27		      LDA	#<backgroundcolorL029
   1776  219b		       8d 59 10 	      STA	PARAMETER
   1777  219e		       a9 62		      LDA	#((>backgroundcolorL029) & $0f) | (((>backgroundcolorL029) / 2) & $70)
   1778  21a0		       8d 59 10 	      STA	PARAMETER
   1779  21a3		       a9 00		      LDA	#0
   1780  21a5		       8d 59 10 	      STA	PARAMETER
   1781  21a8		       a9 57		      LDA	#87
   1782  21aa		       8d 59 10 	      STA	PARAMETER
   1783  21ad		       a9 01		      LDA	#1
   1784  21af		       8d 5a 10 	      STA	CALLFUNCTION
   1785  21b2				   .
   1786  21b2							; 
   1787  21b2
   1788  21b2				   .
   1789  21b2							; 
   1790  21b2
   1791  21b2				   .
   1792  21b2							; 
   1793  21b2
   1794  21b2				   .
   1795  21b2							; 
   1796  21b2
   1797  21b2				   .L030		;  player0x  =  24
   1798  21b2
   1799  21b2		       a9 18		      LDA	#24
   1800  21b4		       85 80		      STA	player0x
   1801  21b6				   .L031		;  player0y  =  16
   1802  21b6
   1803  21b6		       a9 10		      LDA	#16
   1804  21b8		       85 99		      STA	player0y
   1805  21ba				   .
   1806  21ba							; 
   1807  21ba
   1808  21ba				   .L032		;  player1x  =  132
   1809  21ba
   1810  21ba		       a9 84		      LDA	#132
   1811  21bc		       85 90		      STA	player1x
   1812  21be				   .L033		;  player1y  =  16
   1813  21be
   1814  21be		       a9 10		      LDA	#16
   1815  21c0		       85 9a		      STA	player1y
   1816  21c2				   .
   1817  21c2							; 
   1818  21c2
   1819  21c2				   .
   1820  21c2							; 
   1821  21c2
   1822  21c2				   .
   1823  21c2							; 
   1824  21c2
   1825  21c2				   .
   1826  21c2							; 
   1827  21c2
   1828  21c2				   .L034		;  ballx  =  25
   1829  21c2
   1830  21c2		       a9 19		      LDA	#25
   1831  21c4		       85 84		      STA	ballx
   1832  21c6				   .L035		;  bally  =  152
   1833  21c6
   1834  21c6		       a9 98		      LDA	#152
   1835  21c8		       85 c1		      STA	bally
   1836  21ca				   .L036		;  ballheight	=  8
   1837  21ca
   1838  21ca		       a9 08		      LDA	#8
   1839  21cc		       85 c4		      STA	ballheight
   1840  21ce				   .L037		;  CTRLPF  =  $21
   1841  21ce
   1842  21ce		       a9 21		      LDA	#$21
   1843  21d0		       85 0a		      STA	CTRLPF
   1844  21d2				   .
   1845  21d2							; 
   1846  21d2
   1847  21d2				   .L038		;  missile0x  =  133
   1848  21d2
   1849  21d2		       a9 85		      LDA	#133
   1850  21d4		       85 82		      STA	missile0x
   1851  21d6				   .L039		;  missile0y  =  152
   1852  21d6
   1853  21d6		       a9 98		      LDA	#152
   1854  21d8		       85 bf		      STA	missile0y
   1855  21da				   .L040		;  missile0height  =  8
   1856  21da
   1857  21da		       a9 08		      LDA	#8
   1858  21dc		       85 c2		      STA	missile0height
   1859  21de				   .
   1860  21de							; 
   1861  21de
   1862  21de				   .L041		;  COLUM0  =  $7a
   1863  21de
   1864  21de		       a9 7a		      LDA	#$7a
   1865  21e0		       85 bb		      STA	COLUM0
   1866  21e2				   .
   1867  21e2							; 
   1868  21e2
   1869  21e2				   .
   1870  21e2							; 
   1871  21e2
   1872  21e2				   .
   1873  21e2							; 
   1874  21e2
   1875  21e2				   .
   1876  21e2							; 
   1877  21e2
   1878  21e2				   .
   1879  21e2							; 
   1880  21e2
   1881  21e2				   .
   1882  21e2							; 
   1883  21e2
   1884  21e2				   .
   1885  21e2							; 
   1886  21e2
   1887  21e2				   .
   1888  21e2							; 
   1889  21e2
   1890  21e2				   .
   1891  21e2							; 
   1892  21e2
   1893  21e2				   .L042		;  dim pfX  =	temp3
   1894  21e2
   1895  21e2				   .L043		;  dim pfY  =	temp4
   1896  21e2
   1897  21e2				   .L044		;  dim tempX  =  temp5
   1898  21e2
   1899  21e2				   .L045		;  dim tempY  =  temp6
   1900  21e2
   1901  21e2				   .
   1902  21e2							; 
   1903  21e2
   1904  21e2				   .
   1905  21e2							; 
   1906  21e2
   1907  21e2				   .L046		;  const objectHeightMinusOne	=  7
   1908  21e2
   1909  21e2				   .L047		;  const objectWidthMinusOne  =  3
   1910  21e2
   1911  21e2				   .
   1912  21e2							; 
   1913  21e2
   1914  21e2							;.pfPixelHeight.8.
   1915  21e2				   .L048		;  def pfPixelHeight = 8
   1916  21e2
   1917  21e2							;.pfPixelWidth.4.
   1918  21e2				   .L049		;  def pfPixelWidth = 4
   1919  21e2
   1920  21e2				   .
   1921  21e2							; 
   1922  21e2
   1923  21e2				   .L050		;  const pfOffset  =  16
   1924  21e2
   1925  21e2				   .
   1926  21e2							; 
   1927  21e2
   1928  21e2				   .L051		;  const tileHeightMask  =  %00000111
   1929  21e2
   1930  21e2				   .L052		;  const tileWidthMask  =  %00000011
   1931  21e2
   1932  21e2				   .
   1933  21e2							; 
   1934  21e2
   1935  21e2				   .L053		;  const tileHeight  =  8
   1936  21e2
   1937  21e2				   .L054		;  const tileWidth  =	4
   1938  21e2
   1939  21e2				   .
   1940  21e2							; 
   1941  21e2
   1942  21e2				   .
   1943  21e2							; 
   1944  21e2
   1945  21e2				   .
   1946  21e2							; 
   1947  21e2
   1948  21e2				   .
   1949  21e2							; 
   1950  21e2
   1951  21e2				   .
   1952  21e2							; 
   1953  21e2
   1954  21e2				   .
   1955  21e2							; 
   1956  21e2
   1957  21e2				   .
   1958  21e2							; 
   1959  21e2
   1960  21e2				   .
   1961  21e2							; 
   1962  21e2
   1963  21e2				   .
   1964  21e2							; 
   1965  21e2
   1966  21e2				   .
   1967  21e2							; 
   1968  21e2
   1969  21e2				   .L055		;  DF6FRACINC	=  255
   1970  21e2
   1971  21e2		       a9 ff		      LDA	#255
   1972  21e4		       8d 3e 10 	      STA	DF6FRACINC
   1973  21e7				   .L056		;  DF4FRACINC	=  0
   1974  21e7
   1975  21e7		       a9 00		      LDA	#0
   1976  21e9		       8d 3c 10 	      STA	DF4FRACINC
   1977  21ec				   .L057		;  DF0FRACINC	=  32  :  DF1FRACINC  =  32  :	DF2FRACINC  =  32  :  DF3FRACINC  =  32
   1978  21ec
   1979  21ec		       a9 20		      LDA	#32
   1980  21ee		       8d 38 10 	      STA	DF0FRACINC
   1981  21f1		       8d 39 10 	      STA	DF1FRACINC
   1982  21f4		       8d 3a 10 	      STA	DF2FRACINC
   1983  21f7		       8d 3b 10 	      STA	DF3FRACINC
   1984  21fa				   .
   1985  21fa							; 
   1986  21fa
   1987  21fa				   .L058		;  NUSIZ0  =  $20
   1988  21fa
   1989  21fa		       a9 20		      LDA	#$20
   1990  21fc		       85 04		      STA	NUSIZ0
   1991  21fe				   .L059		;  drawscreen
   1992  21fe
   1993  21fe		       85 81		      sta	temp7
   1994  2200		       a9 32		      lda	#>(ret_point2-1)
   1995  2202		       48		      pha
   1996  2203		       a9 15		      lda	#<(ret_point2-1)
   1997  2205		       48		      pha
   1998  2206		       a9 19		      lda	#>(drawscreen-1)
   1999  2208		       48		      pha
   2000  2209		       a9 50		      lda	#<(drawscreen-1)
   2001  220b		       48		      pha
   2002  220c		       a5 81		      lda	temp7
   2003  220e		       48		      pha
   2004  220f		       8a		      txa
   2005  2210		       48		      pha
   2006  2211		       a2 01		      ldx	#1
   2007  2213		       4c ee df 	      jmp	BS_jsr
   2008  2216				   ret_point2
   2009  2216				   .
   2010  2216							; 
   2011  2216
   2012  2216				   .L060		;  dim directionP1  =	a
   2013  2216
   2014  2216				   .L061		;  directionP1  =  0
   2015  2216
   2016  2216		       a9 00		      LDA	#0
   2017  2218		       85 d1		      STA	directionP1
   2018  221a				   .
   2019  221a							; 
   2020  221a
   2021  221a				   .L062		;  dim directionP2  =	b
   2022  221a
   2023  221a				   .L063		;  directionP2  =  0
   2024  221a
   2025  221a		       a9 00		      LDA	#0
   2026  221c		       85 d2		      STA	directionP2
   2027  221e				   .
   2028  221e							; 
   2029  221e
   2030  221e				   .L064		;  dim directionP3  =	c
   2031  221e
   2032  221e				   .L065		;  directionP3  =  0
   2033  221e
   2034  221e		       a9 00		      LDA	#0
   2035  2220		       85 d3		      STA	directionP3
   2036  2222				   .
   2037  2222							; 
   2038  2222
   2039  2222				   .L066		;  dim directionP4  =	d
   2040  2222
   2041  2222				   .L067		;  directionP4  =  0
   2042  2222
   2043  2222		       a9 00		      LDA	#0
   2044  2224		       85 d4		      STA	directionP4
   2045  2226				   .
   2046  2226							; 
   2047  2226
   2048  2226				   .
   2049  2226							; 
   2050  2226
   2051  2226							;.gameOver.e{0}.
   2052  2226				   .L068		;  def gameOver = e{0}
   2053  2226
   2054  2226				   .L069		;  gameOver  =  0
   2055  2226
   2056  2226		       a5 d5		      LDA	e
   2057  2228		       29 fe		      AND	#254
   2058  222a		       85 d5		      STA	e
   2059  222c				   .
   2060  222c							; 
   2061  222c
   2062  222c							;.resetRestrainer.e{1}.
   2063  222c				   .L070		;  def resetRestrainer = e{1}
   2064  222c
   2065  222c				   .L071		;  resetRestrainer  =	0
   2066  222c
   2067  222c		       a5 d5		      LDA	e
   2068  222e		       29 fd		      AND	#253
   2069  2230		       85 d5		      STA	e
   2070  2232				   .
   2071  2232							; 
   2072  2232
   2073  2232							;.flip.e{2}.
   2074  2232				   .L072		;  def flip = e{2}
   2075  2232
   2076  2232				   .L073		;  flip  =  0
   2077  2232
   2078  2232		       a5 d5		      LDA	e
   2079  2234		       29 fb		      AND	#251
   2080  2236		       85 d5		      STA	e
   2081  2238				   .
   2082  2238							; 
   2083  2238
   2084  2238							;.p1Collision.f{1}.
   2085  2238				   .L074		;  def p1Collision = f{1}
   2086  2238
   2087  2238							;.p2Collision.f{2}.
   2088  2238				   .L075		;  def p2Collision = f{2}
   2089  2238
   2090  2238							;.p3Collision.f{3}.
   2091  2238				   .L076		;  def p3Collision = f{3}
   2092  2238
   2093  2238							;.p4Collision.f{4}.
   2094  2238				   .L077		;  def p4Collision = f{4}
   2095  2238
   2096  2238				   .L078		;  f  =  0
   2097  2238
   2098  2238		       a9 00		      LDA	#0
   2099  223a		       85 d6		      STA	f
   2100  223c				   .
   2101  223c							; 
   2102  223c
   2103  223c				   .L079		;  dim previusXPos  =	g
   2104  223c
   2105  223c				   .L080		;  dim previusYPos  =	h
   2106  223c
   2107  223c				   .
   2108  223c							; 
   2109  223c
   2110  223c				   .
   2111  223c							; 
   2112  223c
   2113  223c				   .
   2114  223c							; 
   2115  223c
   2116  223c				   .L081		;  dim moveDelay  =  i
   2117  223c
   2118  223c				   .L082		;  moveDelay  =  0
   2119  223c
   2120  223c		       a9 00		      LDA	#0
   2121  223e		       85 d9		      STA	moveDelay
   2122  2240				   .
   2123  2240							; 
   2124  2240
   2125  2240				   .L083		;  dim delayInc  =  j
   2126  2240
   2127  2240				   .L084		;  delayInc  =  1
   2128  2240
   2129  2240		       a9 01		      LDA	#1
   2130  2242		       85 da		      STA	delayInc
   2131  2244				   .
   2132  2244							; 
   2133  2244
   2134  2244				   .L085		;  dim moveCounter  =	k
   2135  2244
   2136  2244				   .L086		;  moveCounter  =  0
   2137  2244
   2138  2244		       a9 00		      LDA	#0
   2139  2246		       85 db		      STA	moveCounter
   2140  2248				   .
   2141  2248							; 
   2142  2248
   2143  2248				   .
   2144  2248							; 
   2145  2248
   2146  2248				   .
   2147  2248							; 
   2148  2248
   2149  2248				   .
   2150  2248							; 
   2151  2248
   2152  2248				   .
   2153  2248							; 
   2154  2248
   2155  2248				   .L087		;  directionP2  =  3
   2156  2248
   2157  2248		       a9 03		      LDA	#3
   2158  224a		       85 d2		      STA	directionP2
   2159  224c				   .
   2160  224c							; 
   2161  224c
   2162  224c				   .
   2163  224c							; 
   2164  224c
   2165  224c				   .
   2166  224c							; 
   2167  224c
   2168  224c				   .
   2169  224c							; 
   2170  224c
   2171  224c				   .
   2172  224c							; 
   2173  224c
   2174  224c				   .
   2175  224c							; 
   2176  224c
   2177  224c				   .
   2178  224c							; 
   2179  224c
   2180  224c				   .
   2181  224c							; 
   2182  224c
   2183  224c				   .
   2184  224c							; 
   2185  224c
   2186  224c				   .L088		;  dim qtcontroller  =  z
   2187  224c
   2188  224c				   .main
   2189  224c							; main
   2190  224c
   2191  224c				   .
   2192  224c							; 
   2193  224c
   2194  224c				   .
   2195  224c							; 
   2196  224c
   2197  224c				   .
   2198  224c							; 
   2199  224c
   2200  224c				   .
   2201  224c							; 
   2202  224c
   2203  224c				   .
   2204  224c							; 
   2205  224c
   2206  224c				   .
   2207  224c							; 
   2208  224c
   2209  224c				   .L089		;  if qtcontroller then goto skipControllers_1_2
   2210  224c
   2211  224c		       a5 ea		      LDA	qtcontroller
   2212  224e		       f0 03		      BEQ	.skipL089
   2213  2250				   .condpart2
   2214  2250		       4c ae 32 	      jmp	.skipControllers_1_2
   2215  2253
   2216  2253				   .skipL089
   2217  2253				   .
   2218  2253							; 
   2219  2253
   2220  2253				   .
   2221  2253							; 
   2222  2253
   2223  2253				   .L090		;  if !joy0up then skipUp1
   2224  2253
   2225  2253		       a9 10		      lda	#$10
   2226  2255		       2c 80 02 	      bit	SWCHA
   2227  2258					      if	((* - .skipUp1) < 127) && ((* - .skipUp1) > -128)
   2228  2258		       d0 04		      BNE	.skipUp1
   2229  225a				  -	      else
   2230  225a				  -	      beq	.2skipskipUp1
   2231  225a				  -	      jmp	.skipUp1
   2232  225a				  -.2skipskipUp1
   2233  225a					      endif
   2234  225a				   .L091		;  directionP1  =  1
   2235  225a
   2236  225a		       a9 01		      LDA	#1
   2237  225c		       85 d1		      STA	directionP1
   2238  225e				   .skipUp1
   2239  225e							; skipUp1
   2240  225e
   2241  225e				   .
   2242  225e							; 
   2243  225e
   2244  225e				   .L092		;  if !joy0down then skipDown1
   2245  225e
   2246  225e		       a9 20		      lda	#$20
   2247  2260		       2c 80 02 	      bit	SWCHA
   2248  2263					      if	((* - .skipDown1) < 127) && ((* - .skipDown1) > -128)
   2249  2263		       d0 04		      BNE	.skipDown1
   2250  2265				  -	      else
   2251  2265				  -	      beq	.3skipskipDown1
   2252  2265				  -	      jmp	.skipDown1
   2253  2265				  -.3skipskipDown1
   2254  2265					      endif
   2255  2265				   .L093		;  directionP1  =  2
   2256  2265
   2257  2265		       a9 02		      LDA	#2
   2258  2267		       85 d1		      STA	directionP1
   2259  2269				   .skipDown1
   2260  2269							; skipDown1
   2261  2269
   2262  2269				   .
   2263  2269							; 
   2264  2269
   2265  2269				   .L094		;  if !joy0left then skipLeft1
   2266  2269
   2267  2269		       2c 80 02 	      bit	SWCHA
   2268  226c					      if	((* - .skipLeft1) < 127) && ((* - .skipLeft1) > -128)
   2269  226c		       70 04		      bvs	.skipLeft1
   2270  226e				  -	      else
   2271  226e				  -	      bvc	.4skipskipLeft1
   2272  226e				  -	      jmp	.skipLeft1
   2273  226e				  -.4skipskipLeft1
   2274  226e					      endif
   2275  226e				   .L095		;  directionP1  =  3
   2276  226e
   2277  226e		       a9 03		      LDA	#3
   2278  2270		       85 d1		      STA	directionP1
   2279  2272				   .skipLeft1
   2280  2272							; skipLeft1
   2281  2272
   2282  2272				   .
   2283  2272							; 
   2284  2272
   2285  2272				   .L096		;  if !joy0right then skipRight1
   2286  2272
   2287  2272		       2c 80 02 	      bit	SWCHA
   2288  2275					      if	((* - .skipRight1) < 127) && ((* - .skipRight1) > -128)
   2289  2275		       30 04		      bmi	.skipRight1
   2290  2277				  -	      else
   2291  2277				  -	      bpl	.5skipskipRight1
   2292  2277				  -	      jmp	.skipRight1
   2293  2277				  -.5skipskipRight1
   2294  2277					      endif
   2295  2277				   .L097		;  directionP1  =  4
   2296  2277
   2297  2277		       a9 04		      LDA	#4
   2298  2279		       85 d1		      STA	directionP1
   2299  227b				   .skipRight1
   2300  227b							; skipRight1
   2301  227b
   2302  227b				   .
   2303  227b							; 
   2304  227b
   2305  227b				   .
   2306  227b							; 
   2307  227b
   2308  227b				   .L098		;  if !joy1up then skipUp2
   2309  227b
   2310  227b		       a9 01		      lda	#1
   2311  227d		       2c 80 02 	      bit	SWCHA
   2312  2280					      if	((* - .skipUp2) < 127) && ((* - .skipUp2) > -128)
   2313  2280		       d0 04		      BNE	.skipUp2
   2314  2282				  -	      else
   2315  2282				  -	      beq	.6skipskipUp2
   2316  2282				  -	      jmp	.skipUp2
   2317  2282				  -.6skipskipUp2
   2318  2282					      endif
   2319  2282				   .L099		;  directionP2  =  1
   2320  2282
   2321  2282		       a9 01		      LDA	#1
   2322  2284		       85 d2		      STA	directionP2
   2323  2286				   .skipUp2
   2324  2286							; skipUp2
   2325  2286
   2326  2286				   .
   2327  2286							; 
   2328  2286
   2329  2286				   .L0100		;  if !joy1down then skipDown2
   2330  2286
   2331  2286		       a9 02		      lda	#2
   2332  2288		       2c 80 02 	      bit	SWCHA
   2333  228b					      if	((* - .skipDown2) < 127) && ((* - .skipDown2) > -128)
   2334  228b		       d0 04		      BNE	.skipDown2
   2335  228d				  -	      else
   2336  228d				  -	      beq	.7skipskipDown2
   2337  228d				  -	      jmp	.skipDown2
   2338  228d				  -.7skipskipDown2
   2339  228d					      endif
   2340  228d				   .L0101		;  directionP2  =  2
   2341  228d
   2342  228d		       a9 02		      LDA	#2
   2343  228f		       85 d2		      STA	directionP2
   2344  2291				   .skipDown2
   2345  2291							; skipDown2
   2346  2291
   2347  2291				   .
   2348  2291							; 
   2349  2291
   2350  2291				   .L0102		;  if !joy1left then skipLeft2
   2351  2291
   2352  2291		       a9 04		      lda	#4
   2353  2293		       2c 80 02 	      bit	SWCHA
   2354  2296					      if	((* - .skipLeft2) < 127) && ((* - .skipLeft2) > -128)
   2355  2296		       d0 04		      BNE	.skipLeft2
   2356  2298				  -	      else
   2357  2298				  -	      beq	.8skipskipLeft2
   2358  2298				  -	      jmp	.skipLeft2
   2359  2298				  -.8skipskipLeft2
   2360  2298					      endif
   2361  2298				   .L0103		;  directionP2  =  3
   2362  2298
   2363  2298		       a9 03		      LDA	#3
   2364  229a		       85 d2		      STA	directionP2
   2365  229c				   .skipLeft2
   2366  229c							; skipLeft2
   2367  229c
   2368  229c				   .
   2369  229c							; 
   2370  229c
   2371  229c				   .L0104		;  if !joy1right then skipRight2
   2372  229c
   2373  229c		       a9 08		      lda	#8
   2374  229e		       2c 80 02 	      bit	SWCHA
   2375  22a1					      if	((* - .skipRight2) < 127) && ((* - .skipRight2) > -128)
   2376  22a1		       d0 04		      BNE	.skipRight2
   2377  22a3				  -	      else
   2378  22a3				  -	      beq	.9skipskipRight2
   2379  22a3				  -	      jmp	.skipRight2
   2380  22a3				  -.9skipskipRight2
   2381  22a3					      endif
   2382  22a3				   .L0105		;  directionP2  =  4
   2383  22a3
   2384  22a3		       a9 04		      LDA	#4
   2385  22a5		       85 d2		      STA	directionP2
   2386  22a7				   .skipRight2
   2387  22a7							; skipRight2
   2388  22a7
   2389  22a7				   .
   2390  22a7							; 
   2391  22a7
   2392  22a7				   .L0106		;  qtcontroller  =  1
   2393  22a7
   2394  22a7		       a9 01		      LDA	#1
   2395  22a9		       85 ea		      STA	qtcontroller
   2396  22ab				   .L0107		;  goto skipControllers_3_4
   2397  22ab
   2398  22ab		       4c 06 33 	      jmp	.skipControllers_3_4
   2399  22ae
   2400  22ae				   .skipControllers_1_2
   2401  22ae							; skipControllers_1_2
   2402  22ae
   2403  22ae				   .
   2404  22ae							; 
   2405  22ae
   2406  22ae				   .
   2407  22ae							; 
   2408  22ae
   2409  22ae				   .L0108		;  if !joy0up then skipUp3
   2410  22ae
   2411  22ae		       a9 10		      lda	#$10
   2412  22b0		       2c 80 02 	      bit	SWCHA
   2413  22b3					      if	((* - .skipUp3) < 127) && ((* - .skipUp3) > -128)
   2414  22b3		       d0 04		      BNE	.skipUp3
   2415  22b5				  -	      else
   2416  22b5				  -	      beq	.10skipskipUp3
   2417  22b5				  -	      jmp	.skipUp3
   2418  22b5				  -.10skipskipUp3
   2419  22b5					      endif
   2420  22b5				   .L0109		;  directionP3  =  1
   2421  22b5
   2422  22b5		       a9 01		      LDA	#1
   2423  22b7		       85 d3		      STA	directionP3
   2424  22b9				   .skipUp3
   2425  22b9							; skipUp3
   2426  22b9
   2427  22b9				   .
   2428  22b9							; 
   2429  22b9
   2430  22b9				   .L0110		;  if !joy0down then skipDown3
   2431  22b9
   2432  22b9		       a9 20		      lda	#$20
   2433  22bb		       2c 80 02 	      bit	SWCHA
   2434  22be					      if	((* - .skipDown3) < 127) && ((* - .skipDown3) > -128)
   2435  22be		       d0 04		      BNE	.skipDown3
   2436  22c0				  -	      else
   2437  22c0				  -	      beq	.11skipskipDown3
   2438  22c0				  -	      jmp	.skipDown3
   2439  22c0				  -.11skipskipDown3
   2440  22c0					      endif
   2441  22c0				   .L0111		;  directionP3  =  2
   2442  22c0
   2443  22c0		       a9 02		      LDA	#2
   2444  22c2		       85 d3		      STA	directionP3
   2445  22c4				   .skipDown3
   2446  22c4							; skipDown3
   2447  22c4
   2448  22c4				   .
   2449  22c4							; 
   2450  22c4
   2451  22c4				   .L0112		;  if !joy0left then skipLeft3
   2452  22c4
   2453  22c4		       2c 80 02 	      bit	SWCHA
   2454  22c7					      if	((* - .skipLeft3) < 127) && ((* - .skipLeft3) > -128)
   2455  22c7		       70 04		      bvs	.skipLeft3
   2456  22c9				  -	      else
   2457  22c9				  -	      bvc	.12skipskipLeft3
   2458  22c9				  -	      jmp	.skipLeft3
   2459  22c9				  -.12skipskipLeft3
   2460  22c9					      endif
   2461  22c9				   .L0113		;  directionP3  =  3
   2462  22c9
   2463  22c9		       a9 03		      LDA	#3
   2464  22cb		       85 d3		      STA	directionP3
   2465  22cd				   .skipLeft3
   2466  22cd							; skipLeft3
   2467  22cd
   2468  22cd				   .
   2469  22cd							; 
   2470  22cd
   2471  22cd				   .L0114		;  if !joy0right then skipRight3
   2472  22cd
   2473  22cd		       2c 80 02 	      bit	SWCHA
   2474  22d0					      if	((* - .skipRight3) < 127) && ((* - .skipRight3) > -128)
   2475  22d0		       30 04		      bmi	.skipRight3
   2476  22d2				  -	      else
   2477  22d2				  -	      bpl	.13skipskipRight3
   2478  22d2				  -	      jmp	.skipRight3
   2479  22d2				  -.13skipskipRight3
   2480  22d2					      endif
   2481  22d2				   .L0115		;  directionP3  =  4
   2482  22d2
   2483  22d2		       a9 04		      LDA	#4
   2484  22d4		       85 d3		      STA	directionP3
   2485  22d6				   .skipRight3
   2486  22d6							; skipRight3
   2487  22d6
   2488  22d6				   .
   2489  22d6							; 
   2490  22d6
   2491  22d6				   .
   2492  22d6							; 
   2493  22d6
   2494  22d6				   .L0116		;  if !joy1up then skipUp4
   2495  22d6
   2496  22d6		       a9 01		      lda	#1
   2497  22d8		       2c 80 02 	      bit	SWCHA
   2498  22db					      if	((* - .skipUp4) < 127) && ((* - .skipUp4) > -128)
   2499  22db		       d0 04		      BNE	.skipUp4
   2500  22dd				  -	      else
   2501  22dd				  -	      beq	.14skipskipUp4
   2502  22dd				  -	      jmp	.skipUp4
   2503  22dd				  -.14skipskipUp4
   2504  22dd					      endif
   2505  22dd				   .L0117		;  directionP4  =  1
   2506  22dd
   2507  22dd		       a9 01		      LDA	#1
   2508  22df		       85 d4		      STA	directionP4
   2509  22e1				   .skipUp4
   2510  22e1							; skipUp4
   2511  22e1
   2512  22e1				   .
   2513  22e1							; 
   2514  22e1
   2515  22e1				   .L0118		;  if !joy1down then skipDown4
   2516  22e1
   2517  22e1		       a9 02		      lda	#2
   2518  22e3		       2c 80 02 	      bit	SWCHA
   2519  22e6					      if	((* - .skipDown4) < 127) && ((* - .skipDown4) > -128)
   2520  22e6		       d0 04		      BNE	.skipDown4
   2521  22e8				  -	      else
   2522  22e8				  -	      beq	.15skipskipDown4
   2523  22e8				  -	      jmp	.skipDown4
   2524  22e8				  -.15skipskipDown4
   2525  22e8					      endif
   2526  22e8				   .L0119		;  directionP4  =  2
   2527  22e8
   2528  22e8		       a9 02		      LDA	#2
   2529  22ea		       85 d4		      STA	directionP4
   2530  22ec				   .skipDown4
   2531  22ec							; skipDown4
   2532  22ec
   2533  22ec				   .
   2534  22ec							; 
   2535  22ec
   2536  22ec				   .L0120		;  if !joy1left then skipLeft4
   2537  22ec
   2538  22ec		       a9 04		      lda	#4
   2539  22ee		       2c 80 02 	      bit	SWCHA
   2540  22f1					      if	((* - .skipLeft4) < 127) && ((* - .skipLeft4) > -128)
   2541  22f1		       d0 04		      BNE	.skipLeft4
   2542  22f3				  -	      else
   2543  22f3				  -	      beq	.16skipskipLeft4
   2544  22f3				  -	      jmp	.skipLeft4
   2545  22f3				  -.16skipskipLeft4
   2546  22f3					      endif
   2547  22f3				   .L0121		;  directionP4  =  3
   2548  22f3
   2549  22f3		       a9 03		      LDA	#3
   2550  22f5		       85 d4		      STA	directionP4
   2551  22f7				   .skipLeft4
   2552  22f7							; skipLeft4
   2553  22f7
   2554  22f7				   .
   2555  22f7							; 
   2556  22f7
   2557  22f7				   .L0122		;  if !joy1right then skipRight4
   2558  22f7
   2559  22f7		       a9 08		      lda	#8
   2560  22f9		       2c 80 02 	      bit	SWCHA
   2561  22fc					      if	((* - .skipRight4) < 127) && ((* - .skipRight4) > -128)
   2562  22fc		       d0 04		      BNE	.skipRight4
   2563  22fe				  -	      else
   2564  22fe				  -	      beq	.17skipskipRight4
   2565  22fe				  -	      jmp	.skipRight4
   2566  22fe				  -.17skipskipRight4
   2567  22fe					      endif
   2568  22fe				   .L0123		;  directionP4  =  4
   2569  22fe
   2570  22fe		       a9 04		      LDA	#4
   2571  2300		       85 d4		      STA	directionP4
   2572  2302				   .skipRight4
   2573  2302							; skipRight4
   2574  2302
   2575  2302				   .
   2576  2302							; 
   2577  2302
   2578  2302				   .L0124		;  qtcontroller  =  0
   2579  2302
   2580  2302		       a9 00		      LDA	#0
   2581  2304		       85 ea		      STA	qtcontroller
   2582  2306				   .skipControllers_3_4
   2583  2306							; skipControllers_3_4
   2584  2306
   2585  2306				   .
   2586  2306							; 
   2587  2306
   2588  2306				   .
   2589  2306							; 
   2590  2306
   2591  2306				   .
   2592  2306							; 
   2593  2306
   2594  2306				   .L0125		;  moveDelay  =  moveDelay  +	delayInc
   2595  2306
   2596  2306		       a5 d9		      LDA	moveDelay
   2597  2308		       18		      CLC
   2598  2309		       65 da		      ADC	delayInc
   2599  230b		       85 d9		      STA	moveDelay
   2600  230d				   .
   2601  230d							; 
   2602  230d
   2603  230d				   .
   2604  230d							; 
   2605  230d
   2606  230d				   .L0126		;  if moveDelay  <  40 then skipMove
   2607  230d
   2608  230d		       a5 d9		      LDA	moveDelay
   2609  230f		       c9 28		      CMP	#40
   2610  2311				  -	      if	((* - .skipMove) < 127) && ((* - .skipMove) > -128)
   2611  2311				  -	      bcc	.skipMove
   2612  2311					      else
   2613  2311		       b0 03		      bcs	.18skipskipMove
   2614  2313		       4c 9a 33 	      jmp	.skipMove
   2615  2316				   .18skipskipMove
   2616  2316					      endif
   2617  2316				   .
   2618  2316							; 
   2619  2316
   2620  2316				   .L0127		;  moveCounter  =  moveCounter  +  1
   2621  2316
   2622  2316		       e6 db		      INC	moveCounter
   2623  2318				   .L0128		;  if moveCounter  =  16  &&  delayInc  <  4 then delayInc  =	delayInc  +  1	:  moveCounter	=  0
   2624  2318
   2625  2318		       a5 db		      LDA	moveCounter
   2626  231a		       c9 10		      CMP	#16
   2627  231c		       d0 0c		      BNE	.skipL0128
   2628  231e				   .condpart3
   2629  231e		       a5 da		      LDA	delayInc
   2630  2320		       c9 04		      CMP	#4
   2631  2322		       b0 06		      BCS	.skip3then
   2632  2324				   .condpart4
   2633  2324		       e6 da		      INC	delayInc
   2634  2326		       a9 00		      LDA	#0
   2635  2328		       85 db		      STA	moveCounter
   2636  232a				   .skip3then
   2637  232a				   .skipL0128
   2638  232a				   .
   2639  232a							; 
   2640  232a
   2641  232a				   .
   2642  232a							; 
   2643  232a
   2644  232a				   .
   2645  232a							; 
   2646  232a
   2647  232a				   .
   2648  232a							; 
   2649  232a
   2650  232a				   .
   2651  232a							; 
   2652  232a
   2653  232a				   .
   2654  232a							; 
   2655  232a
   2656  232a				   .
   2657  232a							; 
   2658  232a
   2659  232a				   .
   2660  232a							; 
   2661  232a
   2662  232a				   .
   2663  232a							; 
   2664  232a
   2665  232a				   .L0129		;  previusYPos  =  player1y  :  previusXPos  =  player1x
   2666  232a
   2667  232a		       a5 9a		      LDA	player1y
   2668  232c		       85 d8		      STA	previusYPos
   2669  232e		       a5 90		      LDA	player1x
   2670  2330		       85 d7		      STA	previusXPos
   2671  2332				   .L0130		;  if directionP2  =  1 then player1y	=  player1y  -	8
   2672  2332
   2673  2332		       a5 d2		      LDA	directionP2
   2674  2334		       c9 01		      CMP	#1
   2675  2336		       d0 07		      BNE	.skipL0130
   2676  2338				   .condpart5
   2677  2338		       a5 9a		      LDA	player1y
   2678  233a		       38		      SEC
   2679  233b		       e9 08		      SBC	#8
   2680  233d		       85 9a		      STA	player1y
   2681  233f				   .skipL0130
   2682  233f				   .L0131		;  if directionP2  =  2 then player1y	=  player1y  +	8
   2683  233f
   2684  233f		       a5 d2		      LDA	directionP2
   2685  2341		       c9 02		      CMP	#2
   2686  2343		       d0 07		      BNE	.skipL0131
   2687  2345				   .condpart6
   2688  2345		       a5 9a		      LDA	player1y
   2689  2347		       18		      CLC
   2690  2348		       69 08		      ADC	#8
   2691  234a		       85 9a		      STA	player1y
   2692  234c				   .skipL0131
   2693  234c				   .L0132		;  if directionP2  =  3 then player1x	=  player1x  -	4
   2694  234c
   2695  234c		       a5 d2		      LDA	directionP2
   2696  234e		       c9 03		      CMP	#3
   2697  2350		       d0 07		      BNE	.skipL0132
   2698  2352				   .condpart7
   2699  2352		       a5 90		      LDA	player1x
   2700  2354		       38		      SEC
   2701  2355		       e9 04		      SBC	#4
   2702  2357		       85 90		      STA	player1x
   2703  2359				   .skipL0132
   2704  2359				   .L0133		;  if directionP2  =  4 then player1x	=  player1x  +	4
   2705  2359
   2706  2359		       a5 d2		      LDA	directionP2
   2707  235b		       c9 04		      CMP	#4
   2708  235d		       d0 07		      BNE	.skipL0133
   2709  235f				   .condpart8
   2710  235f		       a5 90		      LDA	player1x
   2711  2361		       18		      CLC
   2712  2362		       69 04		      ADC	#4
   2713  2364		       85 90		      STA	player1x
   2714  2366				   .skipL0133
   2715  2366				   .L0134		;  tempY  =  player1y	:  tempX  =  player1x  :  gosub collisionCheck
   2716  2366
   2717  2366		       a5 9a		      LDA	player1y
   2718  2368		       85 d0		      STA	tempY
   2719  236a		       a5 90		      LDA	player1x
   2720  236c		       85 cf		      STA	tempX
   2721  236e		       20 8e 34 	      jsr	.collisionCheck
   2722  2371
   2723  2371				   .L0135		;  if temp1  =  1 then p2Collision  =	1
   2724  2371
   2725  2371		       a5 cb		      LDA	temp1
   2726  2373		       c9 01		      CMP	#1
   2727  2375		       d0 06		      BNE	.skipL0135
   2728  2377				   .condpart9
   2729  2377		       a5 d6		      LDA	f
   2730  2379		       09 04		      ORA	#4
   2731  237b		       85 d6		      STA	f
   2732  237d				   .skipL0135
   2733  237d				   .
   2734  237d							; 
   2735  237d
   2736  237d				   .
   2737  237d							; 
   2738  237d
   2739  237d				   .
   2740  237d							; 
   2741  237d
   2742  237d				   .
   2743  237d							; 
   2744  237d
   2745  237d				   .
   2746  237d							; 
   2747  237d
   2748  237d				   .
   2749  237d							; 
   2750  237d
   2751  237d				   .
   2752  237d							; 
   2753  237d
   2754  237d				   .
   2755  237d							; 
   2756  237d
   2757  237d				   .
   2758  237d							; 
   2759  237d
   2760  237d				   .
   2761  237d							; 
   2762  237d
   2763  237d				   .
   2764  237d							; 
   2765  237d
   2766  237d				   .
   2767  237d							; 
   2768  237d
   2769  237d				   .
   2770  237d							; 
   2771  237d
   2772  237d				   .
   2773  237d							; 
   2774  237d
   2775  237d				   .
   2776  237d							; 
   2777  237d
   2778  237d				   .
   2779  237d							; 
   2780  237d
   2781  237d				   .
   2782  237d							; 
   2783  237d
   2784  237d				   .L0136		;  if f then gameOver	=  1
   2785  237d
   2786  237d		       a5 d6		      LDA	f
   2787  237f		       f0 06		      BEQ	.skipL0136
   2788  2381				   .condpart10
   2789  2381		       a5 d5		      LDA	e
   2790  2383		       09 01		      ORA	#1
   2791  2385		       85 d5		      STA	e
   2792  2387				   .skipL0136
   2793  2387				   .
   2794  2387							; 
   2795  2387
   2796  2387				   .L0137		;  AUDC0  =  1
   2797  2387
   2798  2387		       a9 01		      LDA	#1
   2799  2389		       85 15		      STA	AUDC0
   2800  238b				   .L0138		;  AUDV0  =  10
   2801  238b
   2802  238b		       a9 0a		      LDA	#10
   2803  238d		       85 19		      STA	AUDV0
   2804  238f				   .L0139		;  AUDF0  =  10  -  delayInc
   2805  238f
   2806  238f		       a9 0a		      LDA	#10
   2807  2391		       38		      SEC
   2808  2392		       e5 da		      SBC	delayInc
   2809  2394		       85 17		      STA	AUDF0
   2810  2396				   .
   2811  2396							; 
   2812  2396
   2813  2396				   .L0140		;  moveDelay  =  0
   2814  2396
   2815  2396		       a9 00		      LDA	#0
   2816  2398		       85 d9		      STA	moveDelay
   2817  239a				   .skipMove
   2818  239a							; skipMove
   2819  239a
   2820  239a				   .
   2821  239a							; 
   2822  239a
   2823  239a				   .
   2824  239a							; 
   2825  239a
   2826  239a				   .
   2827  239a							; 
   2828  239a
   2829  239a				   .
   2830  239a							; 
   2831  239a
   2832  239a				   .loop
   2833  239a							; loop
   2834  239a
   2835  239a				   .L0141		;  DF6FRACINC	=  255
   2836  239a
   2837  239a		       a9 ff		      LDA	#255
   2838  239c		       8d 3e 10 	      STA	DF6FRACINC
   2839  239f				   .L0142		;  DF4FRACINC	=  0
   2840  239f
   2841  239f		       a9 00		      LDA	#0
   2842  23a1		       8d 3c 10 	      STA	DF4FRACINC
   2843  23a4				   .L0143		;  DF0FRACINC	=  32  :  DF1FRACINC  =  32  :	DF2FRACINC  =  32  :  DF3FRACINC  =  32
   2844  23a4
   2845  23a4		       a9 20		      LDA	#32
   2846  23a6		       8d 38 10 	      STA	DF0FRACINC
   2847  23a9		       8d 39 10 	      STA	DF1FRACINC
   2848  23ac		       8d 3a 10 	      STA	DF2FRACINC
   2849  23af		       8d 3b 10 	      STA	DF3FRACINC
   2850  23b2				   .
   2851  23b2							; 
   2852  23b2
   2853  23b2				   .L0144		;  NUSIZ0  =  $20
   2854  23b2
   2855  23b2		       a9 20		      LDA	#$20
   2856  23b4		       85 04		      STA	NUSIZ0
   2857  23b6				   .L0145		;  drawscreen
   2858  23b6
   2859  23b6		       85 81		      sta	temp7
   2860  23b8		       a9 33		      lda	#>(ret_point3-1)
   2861  23ba		       48		      pha
   2862  23bb		       a9 cd		      lda	#<(ret_point3-1)
   2863  23bd		       48		      pha
   2864  23be		       a9 19		      lda	#>(drawscreen-1)
   2865  23c0		       48		      pha
   2866  23c1		       a9 50		      lda	#<(drawscreen-1)
   2867  23c3		       48		      pha
   2868  23c4		       a5 81		      lda	temp7
   2869  23c6		       48		      pha
   2870  23c7		       8a		      txa
   2871  23c8		       48		      pha
   2872  23c9		       a2 01		      ldx	#1
   2873  23cb		       4c ee df 	      jmp	BS_jsr
   2874  23ce				   ret_point3
   2875  23ce				   .L0146		;  AUDV0  =  0
   2876  23ce
   2877  23ce		       a9 00		      LDA	#0
   2878  23d0		       85 19		      STA	AUDV0
   2879  23d2				   .
   2880  23d2							; 
   2881  23d2
   2882  23d2				   .L0147		;  flip  =  !flip
   2883  23d2
   2884  23d2		       a5 d5		      LDA	e
   2885  23d4		       29 04		      AND	#4
   2886  23d6		       08		      PHP
   2887  23d7		       a5 d5		      LDA	e
   2888  23d9		       29 fb		      AND	#251
   2889  23db		       28		      PLP
   2890  23dc		       d0 02		      .byte.b	$D0, $02
   2891  23de		       09 04		      ORA	#4
   2892  23e0		       85 d5		      STA	e
   2893  23e2				   .
   2894  23e2							; 
   2895  23e2
   2896  23e2				   .
   2897  23e2							; 
   2898  23e2
   2899  23e2				   .
   2900  23e2							; 
   2901  23e2
   2902  23e2				   .
   2903  23e2							; 
   2904  23e2
   2905  23e2				   .L0148		;  if flip then goto skipEven
   2906  23e2
   2907  23e2		       a5 d5		      LDA	e
   2908  23e4		       29 04		      AND	#4
   2909  23e6		       f0 03		      BEQ	.skipL0148
   2910  23e8				   .condpart11
   2911  23e8		       4c 2c 34 	      jmp	.skipEven
   2912  23eb
   2913  23eb				   .skipL0148
   2914  23eb				   .L0149		;  tempX  =  ballx
   2915  23eb
   2916  23eb		       a5 84		      LDA	ballx
   2917  23ed		       85 cf		      STA	tempX
   2918  23ef				   .L0150		;  tempY  =  bally
   2919  23ef
   2920  23ef		       a5 c1		      LDA	bally
   2921  23f1		       85 d0		      STA	tempY
   2922  23f3				   .
   2923  23f3							; 
   2924  23f3
   2925  23f3				   .L0151		;  ballx  =  missile0x
   2926  23f3
   2927  23f3		       a5 82		      LDA	missile0x
   2928  23f5		       85 84		      STA	ballx
   2929  23f7				   .L0152		;  bally  =  missile0y
   2930  23f7
   2931  23f7		       a5 bf		      LDA	missile0y
   2932  23f9		       85 c1		      STA	bally
   2933  23fb				   .L0153		;  missile0x  =  player1x  +  1
   2934  23fb
   2935  23fb		       a5 90		      LDA	player1x
   2936  23fd		       18		      CLC
   2937  23fe		       69 01		      ADC	#1
   2938  2400		       85 82		      STA	missile0x
   2939  2402				   .L0154		;  missile0y  =  player1y
   2940  2402
   2941  2402		       a5 9a		      LDA	player1y
   2942  2404		       85 bf		      STA	missile0y
   2943  2406				   .L0155		;  player1x  =  tempX	-  1
   2944  2406
   2945  2406		       a5 cf		      LDA	tempX
   2946  2408		       38		      SEC
   2947  2409		       e9 01		      SBC	#1
   2948  240b		       85 90		      STA	player1x
   2949  240d				   .L0156		;  player1y  =  tempY
   2950  240d
   2951  240d		       a5 d0		      LDA	tempY
   2952  240f		       85 9a		      STA	player1y
   2953  2411				   .
   2954  2411							; 
   2955  2411
   2956  2411				   .L0157		;  player1color:
   2957  2411
   2958  2411		       a9 f4		      lda	#<(playerpointers+18)
   2959  2413		       8d 50 10 	      sta	DF0LOW
   2960  2416		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   2961  2418		       8d 68 10 	      sta	DF0HI
   2962  241b		       a2 7e		      LDX	#<playercolorL0157_1
   2963  241d		       8e 78 10 	      STX	DF0WRITE
   2964  2420		       a9 62		      LDA	#((>playercolorL0157_1) & $0f) | (((>playercolorL0157_1) / 2) & $70)
   2965  2422		       8d 78 10 	      STA	DF0WRITE
   2966  2425				   .
   2967  2425							; 
   2968  2425
   2969  2425				   .L0158		;  missile1x  =  13
   2970  2425
   2971  2425		       a9 0d		      LDA	#13
   2972  2427		       85 83		      STA	missile1x
   2973  2429				   .
   2974  2429							; 
   2975  2429
   2976  2429				   .L0159		;  goto skipOdd
   2977  2429
   2978  2429		       4c 6a 34 	      jmp	.skipOdd
   2979  242c
   2980  242c				   .
   2981  242c							; 
   2982  242c
   2983  242c				   .
   2984  242c							; 
   2985  242c
   2986  242c				   .
   2987  242c							; 
   2988  242c
   2989  242c				   .
   2990  242c							; 
   2991  242c
   2992  242c				   .skipEven
   2993  242c							; skipEven
   2994  242c
   2995  242c				   .L0160		;  tempX  =  player1x
   2996  242c
   2997  242c		       a5 90		      LDA	player1x
   2998  242e		       85 cf		      STA	tempX
   2999  2430				   .L0161		;  tempY  =  player1y
   3000  2430
   3001  2430		       a5 9a		      LDA	player1y
   3002  2432		       85 d0		      STA	tempY
   3003  2434				   .
   3004  2434							; 
   3005  2434
   3006  2434				   .L0162		;  player1x  =  missile0x  -  1
   3007  2434
   3008  2434		       a5 82		      LDA	missile0x
   3009  2436		       38		      SEC
   3010  2437		       e9 01		      SBC	#1
   3011  2439		       85 90		      STA	player1x
   3012  243b				   .L0163		;  player1y  =  missile0y
   3013  243b
   3014  243b		       a5 bf		      LDA	missile0y
   3015  243d		       85 9a		      STA	player1y
   3016  243f				   .L0164		;  missile0x  =  ballx
   3017  243f
   3018  243f		       a5 84		      LDA	ballx
   3019  2441		       85 82		      STA	missile0x
   3020  2443				   .L0165		;  missile0y  =  bally
   3021  2443
   3022  2443		       a5 c1		      LDA	bally
   3023  2445		       85 bf		      STA	missile0y
   3024  2447				   .L0166		;  ballx  =  tempX  +	1
   3025  2447
   3026  2447		       a5 cf		      LDA	tempX
   3027  2449		       18		      CLC
   3028  244a		       69 01		      ADC	#1
   3029  244c		       85 84		      STA	ballx
   3030  244e				   .L0167		;  bally  =  tempY
   3031  244e
   3032  244e		       a5 d0		      LDA	tempY
   3033  2450		       85 c1		      STA	bally
   3034  2452				   .
   3035  2452							; 
   3036  2452
   3037  2452				   .L0168		;  player1color:
   3038  2452
   3039  2452		       a9 f4		      lda	#<(playerpointers+18)
   3040  2454		       8d 50 10 	      sta	DF0LOW
   3041  2457		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   3042  2459		       8d 68 10 	      sta	DF0HI
   3043  245c		       a2 86		      LDX	#<playercolorL0168_1
   3044  245e		       8e 78 10 	      STX	DF0WRITE
   3045  2461		       a9 62		      LDA	#((>playercolorL0168_1) & $0f) | (((>playercolorL0168_1) / 2) & $70)
   3046  2463		       8d 78 10 	      STA	DF0WRITE
   3047  2466				   .
   3048  2466							; 
   3049  2466
   3050  2466				   .L0169		;  missile1x  =  145
   3051  2466
   3052  2466		       a9 91		      LDA	#145
   3053  2468		       85 83		      STA	missile1x
   3054  246a				   .skipOdd
   3055  246a							; skipOdd
   3056  246a
   3057  246a				   .
   3058  246a							; 
   3059  246a
   3060  246a				   .
   3061  246a							; 
   3062  246a
   3063  246a				   .
   3064  246a							; 
   3065  246a
   3066  246a				   .
   3067  246a							; 
   3068  246a
   3069  246a				   .
   3070  246a							; 
   3071  246a
   3072  246a				   .
   3073  246a							; 
   3074  246a
   3075  246a				   .
   3076  246a							; 
   3077  246a
   3078  246a				   .
   3079  246a							; 
   3080  246a
   3081  246a				   .
   3082  246a							; 
   3083  246a
   3084  246a				   .
   3085  246a							; 
   3086  246a
   3087  246a				   .
   3088  246a							; 
   3089  246a
   3090  246a				   .
   3091  246a							; 
   3092  246a
   3093  246a				   .
   3094  246a							; 
   3095  246a
   3096  246a				   .
   3097  246a							; 
   3098  246a
   3099  246a				   .
   3100  246a							; 
   3101  246a
   3102  246a				   .L0170		;  if switchreset then resetRestrainer  =  1 else if resetRestrainer then goto init
   3103  246a
   3104  246a		       a9 01		      lda	#1
   3105  246c		       2c 82 02 	      bit	SWCHB
   3106  246f		       d0 09		      BNE	.skipL0170
   3107  2471				   .condpart12
   3108  2471		       a5 d5		      LDA	e
   3109  2473		       09 02		      ORA	#2
   3110  2475		       85 d5		      STA	e
   3111  2477		       4c 83 34 	      jmp	.skipelse0
   3112  247a				   .skipL0170
   3113  247a		       a5 d5		      LDA	e
   3114  247c		       29 02		      AND	#2
   3115  247e		       f0 03		      BEQ	.skipelse
   3116  2480				   .condpart13
   3117  2480		       4c a4 30 	      jmp	.init
   3118  2483
   3119  2483				   .skipelse
   3120  2483				   .skipelse0
   3121  2483				   .
   3122  2483							; 
   3123  2483
   3124  2483				   .
   3125  2483							; 
   3126  2483
   3127  2483				   .L0171		;  if gameOver then loop
   3128  2483
   3129  2483		       a5 d5		      LDA	e
   3130  2485		       4a		      LSR
   3131  2486				  -	      if	((* - .loop) < 127) && ((* - .loop) > -128)
   3132  2486				  -	      bcs	.loop
   3133  2486					      else
   3134  2486		       90 03		      bcc	.19skiploop
   3135  2488		       4c 9a 33 	      jmp	.loop
   3136  248b				   .19skiploop
   3137  248b					      endif
   3138  248b				   .L0172		;  goto main
   3139  248b
   3140  248b		       4c 4c 32 	      jmp	.main
   3141  248e
   3142  248e				   .
   3143  248e							; 
   3144  248e
   3145  248e				   .
   3146  248e							; 
   3147  248e
   3148  248e				   .
   3149  248e							; 
   3150  248e
   3151  248e				   .collisionCheck
   3152  248e							; collisionCheck
   3153  248e
   3154  248e				   .
   3155  248e							; 
   3156  248e
   3157  248e				   .L0173		;  temp1  =  0
   3158  248e
   3159  248e		       a9 00		      LDA	#0
   3160  2490		       85 cb		      STA	temp1
   3161  2492				   .
   3162  2492							; 
   3163  2492
   3164  2492				   .L0174		;  pfY  =  tempY  /  8
   3165  2492
   3166  2492		       a5 d0		      LDA	tempY
   3167  2494		       4a		      lsr
   3168  2495		       4a		      lsr
   3169  2496		       4a		      lsr
   3170  2497		       85 ce		      STA	pfY
   3171  2499				   .L0175		;  pfX  =   ( tempX  -  pfOffset )   /  4
   3172  2499
   3173  2499							; complex statement detected
   3174  2499		       a5 cf		      LDA	tempX
   3175  249b		       38		      SEC
   3176  249c		       e9 10		      SBC	#pfOffset
   3177  249e		       4a		      lsr
   3178  249f		       4a		      lsr
   3179  24a0		       85 cd		      STA	pfX
   3180  24a2				   .L0176		;  if pfread ( pfX ,  pfY )  then temp1  =  1
   3181  24a2
   3182  24a2		       a9 a4		      lda	#<C_function
   3183  24a4		       8d 50 10 	      sta	DF0LOW
   3184  24a7		       a9 01		      lda	#(>C_function) & $0F
   3185  24a9		       8d 68 10 	      sta	DF0HI
   3186  24ac		       a9 18		      lda	#24
   3187  24ae		       8d 78 10 	      sta	DF0WRITE
   3188  24b1		       a5 cd		      LDA	pfX
   3189  24b3		       8d 78 10 	      STA	DF0WRITE
   3190  24b6		       a4 ce		      LDY	pfY
   3191  24b8		       8c 78 10 	      STY	DF0WRITE
   3192  24bb		       a9 ff		      lda	#255
   3193  24bd		       8d 5a 10 	      sta	CALLFUNCTION
   3194  24c0		       ad 08 10 	      LDA	DF0DATA
   3195  24c3		       d0 04		      BNE	.skipL0176
   3196  24c5				   .condpart14
   3197  24c5		       a9 01		      LDA	#1
   3198  24c7		       85 cb		      STA	temp1
   3199  24c9				   .skipL0176
   3200  24c9				   .L0177		;  gosub pfPixelOn
   3201  24c9
   3202  24c9		       20 cd 34 	      jsr	.pfPixelOn
   3203  24cc
   3204  24cc				   .L0178		;  return thisbank
   3205  24cc
   3206  24cc		       60		      RTS
   3207  24cd				   .
   3208  24cd							; 
   3209  24cd
   3210  24cd				   .
   3211  24cd							; 
   3212  24cd
   3213  24cd				   .
   3214  24cd							; 
   3215  24cd
   3216  24cd				   .
   3217  24cd							; 
   3218  24cd
   3219  24cd				   .
   3220  24cd							; 
   3221  24cd
   3222  24cd				   .pfPixelOn
   3223  24cd							; pfPixelOn
   3224  24cd
   3225  24cd				   .L0179		;  pfY  =  previusYPos  /  8
   3226  24cd
   3227  24cd		       a5 d8		      LDA	previusYPos
   3228  24cf		       4a		      lsr
   3229  24d0		       4a		      lsr
   3230  24d1		       4a		      lsr
   3231  24d2		       85 ce		      STA	pfY
   3232  24d4				   .L0180		;  pfX  =   ( previusXPos -  pfOffset )   /  4
   3233  24d4
   3234  24d4							; complex statement detected
   3235  24d4		       a5 d7		      LDA	previusXPos
   3236  24d6		       38		      SEC
   3237  24d7		       e9 10		      SBC	#pfOffset
   3238  24d9		       4a		      lsr
   3239  24da		       4a		      lsr
   3240  24db		       85 cd		      STA	pfX
   3241  24dd				   .L0181		;  pfpixel pfX pfY on
   3242  24dd
   3243  24dd		       a9 a4		      lda	#<C_function
   3244  24df		       8d 50 10 	      sta	DF0LOW
   3245  24e2		       a9 01		      lda	#(>C_function) & $0F
   3246  24e4		       8d 68 10 	      sta	DF0HI
   3247  24e7		       a2 0c		      LDX	#12
   3248  24e9		       8e 78 10 	      STX	DF0WRITE
   3249  24ec		       8e 78 10 	      STX	DF0WRITE
   3250  24ef		       a4 ce		      LDY	pfY
   3251  24f1		       8c 78 10 	      STY	DF0WRITE
   3252  24f4		       a5 cd		      LDA	pfX
   3253  24f6		       8d 78 10 	      STA	DF0WRITE
   3254  24f9		       a9 ff		      lda	#255
   3255  24fb		       8d 5a 10 	      sta	CALLFUNCTION
   3256  24fe				   .
   3257  24fe							; 
   3258  24fe
   3259  24fe				   .L0182		;  return thisbank
   3260  24fe
   3261  24fe		       60		      RTS
   3262  24ff				   .
   3263  24ff							; 
   3264  24ff
   3265  24ff				   .
   3266  24ff							; 
   3267  24ff
   3268  24ff				   .L0183		;  data quadtari_detection
   3269  24ff
   3270  24ff		       4c 0a 35 	      JMP	.skipL0183
   3271  2502				   quadtari_detection
   3272  2502		       1b 1f 0b 0e*	      .byte.b	$1B, $1F, $0B, $0E, $1E, $0B, $1C, $13
   3273  250a
   3274  250a				   .skipL0183
   3275  250a				   .
   3276  250a							; 
   3277  250a
   3278  250a				   .
   3279  250a							; 
   3280  250a
   3281  250a				   .L0184		;  bank 3
   3282  250a
   3283  250a					      if	ECHO2
      2762 bytes of ROM space left in bank 2
   3284  250a					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   3285  250a					      endif
   3286  250a		       00 01	   ECHO2      =	1
   3287  2fd4					      ORG	$2FF4-bscode_length
   3288  2fd4					      RORG	$3FF4-bscode_length
   3289  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   3290  2fd6					      ifconst	FASTFETCH	; using DPC+
   3291  2fd6		       8e 58 10 	      stx	FASTFETCH
   3292  2fd9					      endif
   3293  2fd9		       9a		      txs
   3294  2fda				  -	      if	bankswitch == 64
   3295  2fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3296  2fda					      else
   3297  2fda		       a9 18		      lda	#>(start-1)
   3298  2fdc					      endif
   3299  2fdc		       48		      pha
   3300  2fdd		       a9 eb		      lda	#<(start-1)
   3301  2fdf		       48		      pha
   3302  2fe0		       48		      pha
   3303  2fe1		       8a		      txa
   3304  2fe2		       48		      pha
   3305  2fe3		       ba		      tsx
   3306  2fe4					      if	bankswitch != 64
   3307  2fe4		       b5 04		      lda	4,x	; get high byte of return address
   3308  2fe6		       2a		      rol
   3309  2fe7		       2a		      rol
   3310  2fe8		       2a		      rol
   3311  2fe9		       2a		      rol
   3312  2fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3313  2fec		       aa		      tax
   3314  2fed		       e8		      inx
   3315  2fee				  -	      else
   3316  2fee				  -	      lda	4,x	; get high byte of return address
   3317  2fee				  -	      tay
   3318  2fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3319  2fee				  -	      sta	4,x
   3320  2fee				  -	      tya
   3321  2fee				  -	      lsr
   3322  2fee				  -	      lsr
   3323  2fee				  -	      lsr
   3324  2fee				  -	      lsr
   3325  2fee				  -	      tax
   3326  2fee				  -	      inx
   3327  2fee					      endif
   3328  2fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3329  2ff1		       68		      pla
   3330  2ff2		       aa		      tax
   3331  2ff3		       68		      pla
   3332  2ff4		       60		      rts
   3333  2ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3334  2ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3335  2ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3336  2ff5					      endif
   3337  2ffc					      ORG	$2FFC
   3338  2ffc					      RORG	$3FFC
   3339  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   3340  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   3341  3000					      ORG	$3000
   3342  3000					      RORG	$5000
   3343  3000					      repeat	129
   3344  3000		       00		      .byte.b	0
   3343  3000					      repend
   3344  3001		       00		      .byte.b	0
   3343  3001					      repend
   3344  3002		       00		      .byte.b	0
   3343  3002					      repend
   3344  3003		       00		      .byte.b	0
   3343  3003					      repend
   3344  3004		       00		      .byte.b	0
   3343  3004					      repend
   3344  3005		       00		      .byte.b	0
   3343  3005					      repend
   3344  3006		       00		      .byte.b	0
   3343  3006					      repend
   3344  3007		       00		      .byte.b	0
   3343  3007					      repend
   3344  3008		       00		      .byte.b	0
   3343  3008					      repend
   3344  3009		       00		      .byte.b	0
   3343  3009					      repend
   3344  300a		       00		      .byte.b	0
   3343  300a					      repend
   3344  300b		       00		      .byte.b	0
   3343  300b					      repend
   3344  300c		       00		      .byte.b	0
   3343  300c					      repend
   3344  300d		       00		      .byte.b	0
   3343  300d					      repend
   3344  300e		       00		      .byte.b	0
   3343  300e					      repend
   3344  300f		       00		      .byte.b	0
   3343  300f					      repend
   3344  3010		       00		      .byte.b	0
   3343  3010					      repend
   3344  3011		       00		      .byte.b	0
   3343  3011					      repend
   3344  3012		       00		      .byte.b	0
   3343  3012					      repend
   3344  3013		       00		      .byte.b	0
   3343  3013					      repend
   3344  3014		       00		      .byte.b	0
   3343  3014					      repend
   3344  3015		       00		      .byte.b	0
   3343  3015					      repend
   3344  3016		       00		      .byte.b	0
   3343  3016					      repend
   3344  3017		       00		      .byte.b	0
   3343  3017					      repend
   3344  3018		       00		      .byte.b	0
   3343  3018					      repend
   3344  3019		       00		      .byte.b	0
   3343  3019					      repend
   3344  301a		       00		      .byte.b	0
   3343  301a					      repend
   3344  301b		       00		      .byte.b	0
   3343  301b					      repend
   3344  301c		       00		      .byte.b	0
   3343  301c					      repend
   3344  301d		       00		      .byte.b	0
   3343  301d					      repend
   3344  301e		       00		      .byte.b	0
   3343  301e					      repend
   3344  301f		       00		      .byte.b	0
   3343  301f					      repend
   3344  3020		       00		      .byte.b	0
   3343  3020					      repend
   3344  3021		       00		      .byte.b	0
   3343  3021					      repend
   3344  3022		       00		      .byte.b	0
   3343  3022					      repend
   3344  3023		       00		      .byte.b	0
   3343  3023					      repend
   3344  3024		       00		      .byte.b	0
   3343  3024					      repend
   3344  3025		       00		      .byte.b	0
   3343  3025					      repend
   3344  3026		       00		      .byte.b	0
   3343  3026					      repend
   3344  3027		       00		      .byte.b	0
   3343  3027					      repend
   3344  3028		       00		      .byte.b	0
   3343  3028					      repend
   3344  3029		       00		      .byte.b	0
   3343  3029					      repend
   3344  302a		       00		      .byte.b	0
   3343  302a					      repend
   3344  302b		       00		      .byte.b	0
   3343  302b					      repend
   3344  302c		       00		      .byte.b	0
   3343  302c					      repend
   3344  302d		       00		      .byte.b	0
   3343  302d					      repend
   3344  302e		       00		      .byte.b	0
   3343  302e					      repend
   3344  302f		       00		      .byte.b	0
   3343  302f					      repend
   3344  3030		       00		      .byte.b	0
   3343  3030					      repend
   3344  3031		       00		      .byte.b	0
   3343  3031					      repend
   3344  3032		       00		      .byte.b	0
   3343  3032					      repend
   3344  3033		       00		      .byte.b	0
   3343  3033					      repend
   3344  3034		       00		      .byte.b	0
   3343  3034					      repend
   3344  3035		       00		      .byte.b	0
   3343  3035					      repend
   3344  3036		       00		      .byte.b	0
   3343  3036					      repend
   3344  3037		       00		      .byte.b	0
   3343  3037					      repend
   3344  3038		       00		      .byte.b	0
   3343  3038					      repend
   3344  3039		       00		      .byte.b	0
   3343  3039					      repend
   3344  303a		       00		      .byte.b	0
   3343  303a					      repend
   3344  303b		       00		      .byte.b	0
   3343  303b					      repend
   3344  303c		       00		      .byte.b	0
   3343  303c					      repend
   3344  303d		       00		      .byte.b	0
   3343  303d					      repend
   3344  303e		       00		      .byte.b	0
   3343  303e					      repend
   3344  303f		       00		      .byte.b	0
   3343  303f					      repend
   3344  3040		       00		      .byte.b	0
   3343  3040					      repend
   3344  3041		       00		      .byte.b	0
   3343  3041					      repend
   3344  3042		       00		      .byte.b	0
   3343  3042					      repend
   3344  3043		       00		      .byte.b	0
   3343  3043					      repend
   3344  3044		       00		      .byte.b	0
   3343  3044					      repend
   3344  3045		       00		      .byte.b	0
   3343  3045					      repend
   3344  3046		       00		      .byte.b	0
   3343  3046					      repend
   3344  3047		       00		      .byte.b	0
   3343  3047					      repend
   3344  3048		       00		      .byte.b	0
   3343  3048					      repend
   3344  3049		       00		      .byte.b	0
   3343  3049					      repend
   3344  304a		       00		      .byte.b	0
   3343  304a					      repend
   3344  304b		       00		      .byte.b	0
   3343  304b					      repend
   3344  304c		       00		      .byte.b	0
   3343  304c					      repend
   3344  304d		       00		      .byte.b	0
   3343  304d					      repend
   3344  304e		       00		      .byte.b	0
   3343  304e					      repend
   3344  304f		       00		      .byte.b	0
   3343  304f					      repend
   3344  3050		       00		      .byte.b	0
   3343  3050					      repend
   3344  3051		       00		      .byte.b	0
   3343  3051					      repend
   3344  3052		       00		      .byte.b	0
   3343  3052					      repend
   3344  3053		       00		      .byte.b	0
   3343  3053					      repend
   3344  3054		       00		      .byte.b	0
   3343  3054					      repend
   3344  3055		       00		      .byte.b	0
   3343  3055					      repend
   3344  3056		       00		      .byte.b	0
   3343  3056					      repend
   3344  3057		       00		      .byte.b	0
   3343  3057					      repend
   3344  3058		       00		      .byte.b	0
   3343  3058					      repend
   3344  3059		       00		      .byte.b	0
   3343  3059					      repend
   3344  305a		       00		      .byte.b	0
   3343  305a					      repend
   3344  305b		       00		      .byte.b	0
   3343  305b					      repend
   3344  305c		       00		      .byte.b	0
   3343  305c					      repend
   3344  305d		       00		      .byte.b	0
   3343  305d					      repend
   3344  305e		       00		      .byte.b	0
   3343  305e					      repend
   3344  305f		       00		      .byte.b	0
   3343  305f					      repend
   3344  3060		       00		      .byte.b	0
   3343  3060					      repend
   3344  3061		       00		      .byte.b	0
   3343  3061					      repend
   3344  3062		       00		      .byte.b	0
   3343  3062					      repend
   3344  3063		       00		      .byte.b	0
   3343  3063					      repend
   3344  3064		       00		      .byte.b	0
   3343  3064					      repend
   3344  3065		       00		      .byte.b	0
   3343  3065					      repend
   3344  3066		       00		      .byte.b	0
   3343  3066					      repend
   3344  3067		       00		      .byte.b	0
   3343  3067					      repend
   3344  3068		       00		      .byte.b	0
   3343  3068					      repend
   3344  3069		       00		      .byte.b	0
   3343  3069					      repend
   3344  306a		       00		      .byte.b	0
   3343  306a					      repend
   3344  306b		       00		      .byte.b	0
   3343  306b					      repend
   3344  306c		       00		      .byte.b	0
   3343  306c					      repend
   3344  306d		       00		      .byte.b	0
   3343  306d					      repend
   3344  306e		       00		      .byte.b	0
   3343  306e					      repend
   3344  306f		       00		      .byte.b	0
   3343  306f					      repend
   3344  3070		       00		      .byte.b	0
   3343  3070					      repend
   3344  3071		       00		      .byte.b	0
   3343  3071					      repend
   3344  3072		       00		      .byte.b	0
   3343  3072					      repend
   3344  3073		       00		      .byte.b	0
   3343  3073					      repend
   3344  3074		       00		      .byte.b	0
   3343  3074					      repend
   3344  3075		       00		      .byte.b	0
   3343  3075					      repend
   3344  3076		       00		      .byte.b	0
   3343  3076					      repend
   3344  3077		       00		      .byte.b	0
   3343  3077					      repend
   3344  3078		       00		      .byte.b	0
   3343  3078					      repend
   3344  3079		       00		      .byte.b	0
   3343  3079					      repend
   3344  307a		       00		      .byte.b	0
   3343  307a					      repend
   3344  307b		       00		      .byte.b	0
   3343  307b					      repend
   3344  307c		       00		      .byte.b	0
   3343  307c					      repend
   3344  307d		       00		      .byte.b	0
   3343  307d					      repend
   3344  307e		       00		      .byte.b	0
   3343  307e					      repend
   3344  307f		       00		      .byte.b	0
   3343  307f					      repend
   3344  3080		       00		      .byte.b	0
   3345  3081					      repend
   3346  3081				   .L0185		;  temp1 = temp1
   3347  3081
   3348  3081		       a5 cb		      LDA	temp1
   3349  3083		       85 cb		      STA	temp1
   3350  3085				   .
   3351  3085							; 
   3352  3085
   3353  3085				   .L0186		;  asm
   3354  3085
   3355  3085							;include "titlescreen/asm/titlescreen.asm"
   3356  3085
   3357  3085				   .
   3358  3085							; 
   3359  3085
   3360  3085				   .
   3361  3085							; 
   3362  3085
   3363  3085				   .L0187		;  bank 4
   3364  3085
   3365  3085					      if	ECHO3
      3919 bytes of ROM space left in bank 3
   3366  3085					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   3367  3085					      endif
   3368  3085		       00 01	   ECHO3      =	1
   3369  3fd4					      ORG	$3FF4-bscode_length
   3370  3fd4					      RORG	$5FF4-bscode_length
   3371  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   3372  3fd6					      ifconst	FASTFETCH	; using DPC+
   3373  3fd6		       8e 58 10 	      stx	FASTFETCH
   3374  3fd9					      endif
   3375  3fd9		       9a		      txs
   3376  3fda				  -	      if	bankswitch == 64
   3377  3fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3378  3fda					      else
   3379  3fda		       a9 18		      lda	#>(start-1)
   3380  3fdc					      endif
   3381  3fdc		       48		      pha
   3382  3fdd		       a9 eb		      lda	#<(start-1)
   3383  3fdf		       48		      pha
   3384  3fe0		       48		      pha
   3385  3fe1		       8a		      txa
   3386  3fe2		       48		      pha
   3387  3fe3		       ba		      tsx
   3388  3fe4					      if	bankswitch != 64
   3389  3fe4		       b5 04		      lda	4,x	; get high byte of return address
   3390  3fe6		       2a		      rol
   3391  3fe7		       2a		      rol
   3392  3fe8		       2a		      rol
   3393  3fe9		       2a		      rol
   3394  3fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3395  3fec		       aa		      tax
   3396  3fed		       e8		      inx
   3397  3fee				  -	      else
   3398  3fee				  -	      lda	4,x	; get high byte of return address
   3399  3fee				  -	      tay
   3400  3fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3401  3fee				  -	      sta	4,x
   3402  3fee				  -	      tya
   3403  3fee				  -	      lsr
   3404  3fee				  -	      lsr
   3405  3fee				  -	      lsr
   3406  3fee				  -	      lsr
   3407  3fee				  -	      tax
   3408  3fee				  -	      inx
   3409  3fee					      endif
   3410  3fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3411  3ff1		       68		      pla
   3412  3ff2		       aa		      tax
   3413  3ff3		       68		      pla
   3414  3ff4		       60		      rts
   3415  3ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3416  3ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3417  3ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3418  3ff5					      endif
   3419  3ffc					      ORG	$3FFC
   3420  3ffc					      RORG	$5FFC
   3421  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   3422  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   3423  4000					      ORG	$4000
   3424  4000					      RORG	$7000
   3425  4000					      repeat	129
   3426  4000		       00		      .byte.b	0
   3425  4000					      repend
   3426  4001		       00		      .byte.b	0
   3425  4001					      repend
   3426  4002		       00		      .byte.b	0
   3425  4002					      repend
   3426  4003		       00		      .byte.b	0
   3425  4003					      repend
   3426  4004		       00		      .byte.b	0
   3425  4004					      repend
   3426  4005		       00		      .byte.b	0
   3425  4005					      repend
   3426  4006		       00		      .byte.b	0
   3425  4006					      repend
   3426  4007		       00		      .byte.b	0
   3425  4007					      repend
   3426  4008		       00		      .byte.b	0
   3425  4008					      repend
   3426  4009		       00		      .byte.b	0
   3425  4009					      repend
   3426  400a		       00		      .byte.b	0
   3425  400a					      repend
   3426  400b		       00		      .byte.b	0
   3425  400b					      repend
   3426  400c		       00		      .byte.b	0
   3425  400c					      repend
   3426  400d		       00		      .byte.b	0
   3425  400d					      repend
   3426  400e		       00		      .byte.b	0
   3425  400e					      repend
   3426  400f		       00		      .byte.b	0
   3425  400f					      repend
   3426  4010		       00		      .byte.b	0
   3425  4010					      repend
   3426  4011		       00		      .byte.b	0
   3425  4011					      repend
   3426  4012		       00		      .byte.b	0
   3425  4012					      repend
   3426  4013		       00		      .byte.b	0
   3425  4013					      repend
   3426  4014		       00		      .byte.b	0
   3425  4014					      repend
   3426  4015		       00		      .byte.b	0
   3425  4015					      repend
   3426  4016		       00		      .byte.b	0
   3425  4016					      repend
   3426  4017		       00		      .byte.b	0
   3425  4017					      repend
   3426  4018		       00		      .byte.b	0
   3425  4018					      repend
   3426  4019		       00		      .byte.b	0
   3425  4019					      repend
   3426  401a		       00		      .byte.b	0
   3425  401a					      repend
   3426  401b		       00		      .byte.b	0
   3425  401b					      repend
   3426  401c		       00		      .byte.b	0
   3425  401c					      repend
   3426  401d		       00		      .byte.b	0
   3425  401d					      repend
   3426  401e		       00		      .byte.b	0
   3425  401e					      repend
   3426  401f		       00		      .byte.b	0
   3425  401f					      repend
   3426  4020		       00		      .byte.b	0
   3425  4020					      repend
   3426  4021		       00		      .byte.b	0
   3425  4021					      repend
   3426  4022		       00		      .byte.b	0
   3425  4022					      repend
   3426  4023		       00		      .byte.b	0
   3425  4023					      repend
   3426  4024		       00		      .byte.b	0
   3425  4024					      repend
   3426  4025		       00		      .byte.b	0
   3425  4025					      repend
   3426  4026		       00		      .byte.b	0
   3425  4026					      repend
   3426  4027		       00		      .byte.b	0
   3425  4027					      repend
   3426  4028		       00		      .byte.b	0
   3425  4028					      repend
   3426  4029		       00		      .byte.b	0
   3425  4029					      repend
   3426  402a		       00		      .byte.b	0
   3425  402a					      repend
   3426  402b		       00		      .byte.b	0
   3425  402b					      repend
   3426  402c		       00		      .byte.b	0
   3425  402c					      repend
   3426  402d		       00		      .byte.b	0
   3425  402d					      repend
   3426  402e		       00		      .byte.b	0
   3425  402e					      repend
   3426  402f		       00		      .byte.b	0
   3425  402f					      repend
   3426  4030		       00		      .byte.b	0
   3425  4030					      repend
   3426  4031		       00		      .byte.b	0
   3425  4031					      repend
   3426  4032		       00		      .byte.b	0
   3425  4032					      repend
   3426  4033		       00		      .byte.b	0
   3425  4033					      repend
   3426  4034		       00		      .byte.b	0
   3425  4034					      repend
   3426  4035		       00		      .byte.b	0
   3425  4035					      repend
   3426  4036		       00		      .byte.b	0
   3425  4036					      repend
   3426  4037		       00		      .byte.b	0
   3425  4037					      repend
   3426  4038		       00		      .byte.b	0
   3425  4038					      repend
   3426  4039		       00		      .byte.b	0
   3425  4039					      repend
   3426  403a		       00		      .byte.b	0
   3425  403a					      repend
   3426  403b		       00		      .byte.b	0
   3425  403b					      repend
   3426  403c		       00		      .byte.b	0
   3425  403c					      repend
   3426  403d		       00		      .byte.b	0
   3425  403d					      repend
   3426  403e		       00		      .byte.b	0
   3425  403e					      repend
   3426  403f		       00		      .byte.b	0
   3425  403f					      repend
   3426  4040		       00		      .byte.b	0
   3425  4040					      repend
   3426  4041		       00		      .byte.b	0
   3425  4041					      repend
   3426  4042		       00		      .byte.b	0
   3425  4042					      repend
   3426  4043		       00		      .byte.b	0
   3425  4043					      repend
   3426  4044		       00		      .byte.b	0
   3425  4044					      repend
   3426  4045		       00		      .byte.b	0
   3425  4045					      repend
   3426  4046		       00		      .byte.b	0
   3425  4046					      repend
   3426  4047		       00		      .byte.b	0
   3425  4047					      repend
   3426  4048		       00		      .byte.b	0
   3425  4048					      repend
   3426  4049		       00		      .byte.b	0
   3425  4049					      repend
   3426  404a		       00		      .byte.b	0
   3425  404a					      repend
   3426  404b		       00		      .byte.b	0
   3425  404b					      repend
   3426  404c		       00		      .byte.b	0
   3425  404c					      repend
   3426  404d		       00		      .byte.b	0
   3425  404d					      repend
   3426  404e		       00		      .byte.b	0
   3425  404e					      repend
   3426  404f		       00		      .byte.b	0
   3425  404f					      repend
   3426  4050		       00		      .byte.b	0
   3425  4050					      repend
   3426  4051		       00		      .byte.b	0
   3425  4051					      repend
   3426  4052		       00		      .byte.b	0
   3425  4052					      repend
   3426  4053		       00		      .byte.b	0
   3425  4053					      repend
   3426  4054		       00		      .byte.b	0
   3425  4054					      repend
   3426  4055		       00		      .byte.b	0
   3425  4055					      repend
   3426  4056		       00		      .byte.b	0
   3425  4056					      repend
   3426  4057		       00		      .byte.b	0
   3425  4057					      repend
   3426  4058		       00		      .byte.b	0
   3425  4058					      repend
   3426  4059		       00		      .byte.b	0
   3425  4059					      repend
   3426  405a		       00		      .byte.b	0
   3425  405a					      repend
   3426  405b		       00		      .byte.b	0
   3425  405b					      repend
   3426  405c		       00		      .byte.b	0
   3425  405c					      repend
   3426  405d		       00		      .byte.b	0
   3425  405d					      repend
   3426  405e		       00		      .byte.b	0
   3425  405e					      repend
   3426  405f		       00		      .byte.b	0
   3425  405f					      repend
   3426  4060		       00		      .byte.b	0
   3425  4060					      repend
   3426  4061		       00		      .byte.b	0
   3425  4061					      repend
   3426  4062		       00		      .byte.b	0
   3425  4062					      repend
   3426  4063		       00		      .byte.b	0
   3425  4063					      repend
   3426  4064		       00		      .byte.b	0
   3425  4064					      repend
   3426  4065		       00		      .byte.b	0
   3425  4065					      repend
   3426  4066		       00		      .byte.b	0
   3425  4066					      repend
   3426  4067		       00		      .byte.b	0
   3425  4067					      repend
   3426  4068		       00		      .byte.b	0
   3425  4068					      repend
   3426  4069		       00		      .byte.b	0
   3425  4069					      repend
   3426  406a		       00		      .byte.b	0
   3425  406a					      repend
   3426  406b		       00		      .byte.b	0
   3425  406b					      repend
   3426  406c		       00		      .byte.b	0
   3425  406c					      repend
   3426  406d		       00		      .byte.b	0
   3425  406d					      repend
   3426  406e		       00		      .byte.b	0
   3425  406e					      repend
   3426  406f		       00		      .byte.b	0
   3425  406f					      repend
   3426  4070		       00		      .byte.b	0
   3425  4070					      repend
   3426  4071		       00		      .byte.b	0
   3425  4071					      repend
   3426  4072		       00		      .byte.b	0
   3425  4072					      repend
   3426  4073		       00		      .byte.b	0
   3425  4073					      repend
   3426  4074		       00		      .byte.b	0
   3425  4074					      repend
   3426  4075		       00		      .byte.b	0
   3425  4075					      repend
   3426  4076		       00		      .byte.b	0
   3425  4076					      repend
   3426  4077		       00		      .byte.b	0
   3425  4077					      repend
   3426  4078		       00		      .byte.b	0
   3425  4078					      repend
   3426  4079		       00		      .byte.b	0
   3425  4079					      repend
   3426  407a		       00		      .byte.b	0
   3425  407a					      repend
   3426  407b		       00		      .byte.b	0
   3425  407b					      repend
   3426  407c		       00		      .byte.b	0
   3425  407c					      repend
   3426  407d		       00		      .byte.b	0
   3425  407d					      repend
   3426  407e		       00		      .byte.b	0
   3425  407e					      repend
   3426  407f		       00		      .byte.b	0
   3425  407f					      repend
   3426  4080		       00		      .byte.b	0
   3427  4081					      repend
   3428  4081				   .L0188		;  temp1 = temp1
   3429  4081
   3430  4081		       a5 cb		      LDA	temp1
   3431  4083		       85 cb		      STA	temp1
   3432  4085				   .
   3433  4085							; 
   3434  4085
   3435  4085				   .L0189		;  bank 5
   3436  4085
   3437  4085					      if	ECHO4
      3919 bytes of ROM space left in bank 4
   3438  4085					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   3439  4085					      endif
   3440  4085		       00 01	   ECHO4      =	1
   3441  4fd4					      ORG	$4FF4-bscode_length
   3442  4fd4					      RORG	$7FF4-bscode_length
   3443  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   3444  4fd6					      ifconst	FASTFETCH	; using DPC+
   3445  4fd6		       8e 58 10 	      stx	FASTFETCH
   3446  4fd9					      endif
   3447  4fd9		       9a		      txs
   3448  4fda				  -	      if	bankswitch == 64
   3449  4fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3450  4fda					      else
   3451  4fda		       a9 18		      lda	#>(start-1)
   3452  4fdc					      endif
   3453  4fdc		       48		      pha
   3454  4fdd		       a9 eb		      lda	#<(start-1)
   3455  4fdf		       48		      pha
   3456  4fe0		       48		      pha
   3457  4fe1		       8a		      txa
   3458  4fe2		       48		      pha
   3459  4fe3		       ba		      tsx
   3460  4fe4					      if	bankswitch != 64
   3461  4fe4		       b5 04		      lda	4,x	; get high byte of return address
   3462  4fe6		       2a		      rol
   3463  4fe7		       2a		      rol
   3464  4fe8		       2a		      rol
   3465  4fe9		       2a		      rol
   3466  4fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3467  4fec		       aa		      tax
   3468  4fed		       e8		      inx
   3469  4fee				  -	      else
   3470  4fee				  -	      lda	4,x	; get high byte of return address
   3471  4fee				  -	      tay
   3472  4fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3473  4fee				  -	      sta	4,x
   3474  4fee				  -	      tya
   3475  4fee				  -	      lsr
   3476  4fee				  -	      lsr
   3477  4fee				  -	      lsr
   3478  4fee				  -	      lsr
   3479  4fee				  -	      tax
   3480  4fee				  -	      inx
   3481  4fee					      endif
   3482  4fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3483  4ff1		       68		      pla
   3484  4ff2		       aa		      tax
   3485  4ff3		       68		      pla
   3486  4ff4		       60		      rts
   3487  4ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3488  4ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3489  4ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3490  4ff5					      endif
   3491  4ffc					      ORG	$4FFC
   3492  4ffc					      RORG	$7FFC
   3493  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   3494  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   3495  5000					      ORG	$5000
   3496  5000					      RORG	$9000
   3497  5000					      repeat	129
   3498  5000		       00		      .byte.b	0
   3497  5000					      repend
   3498  5001		       00		      .byte.b	0
   3497  5001					      repend
   3498  5002		       00		      .byte.b	0
   3497  5002					      repend
   3498  5003		       00		      .byte.b	0
   3497  5003					      repend
   3498  5004		       00		      .byte.b	0
   3497  5004					      repend
   3498  5005		       00		      .byte.b	0
   3497  5005					      repend
   3498  5006		       00		      .byte.b	0
   3497  5006					      repend
   3498  5007		       00		      .byte.b	0
   3497  5007					      repend
   3498  5008		       00		      .byte.b	0
   3497  5008					      repend
   3498  5009		       00		      .byte.b	0
   3497  5009					      repend
   3498  500a		       00		      .byte.b	0
   3497  500a					      repend
   3498  500b		       00		      .byte.b	0
   3497  500b					      repend
   3498  500c		       00		      .byte.b	0
   3497  500c					      repend
   3498  500d		       00		      .byte.b	0
   3497  500d					      repend
   3498  500e		       00		      .byte.b	0
   3497  500e					      repend
   3498  500f		       00		      .byte.b	0
   3497  500f					      repend
   3498  5010		       00		      .byte.b	0
   3497  5010					      repend
   3498  5011		       00		      .byte.b	0
   3497  5011					      repend
   3498  5012		       00		      .byte.b	0
   3497  5012					      repend
   3498  5013		       00		      .byte.b	0
   3497  5013					      repend
   3498  5014		       00		      .byte.b	0
   3497  5014					      repend
   3498  5015		       00		      .byte.b	0
   3497  5015					      repend
   3498  5016		       00		      .byte.b	0
   3497  5016					      repend
   3498  5017		       00		      .byte.b	0
   3497  5017					      repend
   3498  5018		       00		      .byte.b	0
   3497  5018					      repend
   3498  5019		       00		      .byte.b	0
   3497  5019					      repend
   3498  501a		       00		      .byte.b	0
   3497  501a					      repend
   3498  501b		       00		      .byte.b	0
   3497  501b					      repend
   3498  501c		       00		      .byte.b	0
   3497  501c					      repend
   3498  501d		       00		      .byte.b	0
   3497  501d					      repend
   3498  501e		       00		      .byte.b	0
   3497  501e					      repend
   3498  501f		       00		      .byte.b	0
   3497  501f					      repend
   3498  5020		       00		      .byte.b	0
   3497  5020					      repend
   3498  5021		       00		      .byte.b	0
   3497  5021					      repend
   3498  5022		       00		      .byte.b	0
   3497  5022					      repend
   3498  5023		       00		      .byte.b	0
   3497  5023					      repend
   3498  5024		       00		      .byte.b	0
   3497  5024					      repend
   3498  5025		       00		      .byte.b	0
   3497  5025					      repend
   3498  5026		       00		      .byte.b	0
   3497  5026					      repend
   3498  5027		       00		      .byte.b	0
   3497  5027					      repend
   3498  5028		       00		      .byte.b	0
   3497  5028					      repend
   3498  5029		       00		      .byte.b	0
   3497  5029					      repend
   3498  502a		       00		      .byte.b	0
   3497  502a					      repend
   3498  502b		       00		      .byte.b	0
   3497  502b					      repend
   3498  502c		       00		      .byte.b	0
   3497  502c					      repend
   3498  502d		       00		      .byte.b	0
   3497  502d					      repend
   3498  502e		       00		      .byte.b	0
   3497  502e					      repend
   3498  502f		       00		      .byte.b	0
   3497  502f					      repend
   3498  5030		       00		      .byte.b	0
   3497  5030					      repend
   3498  5031		       00		      .byte.b	0
   3497  5031					      repend
   3498  5032		       00		      .byte.b	0
   3497  5032					      repend
   3498  5033		       00		      .byte.b	0
   3497  5033					      repend
   3498  5034		       00		      .byte.b	0
   3497  5034					      repend
   3498  5035		       00		      .byte.b	0
   3497  5035					      repend
   3498  5036		       00		      .byte.b	0
   3497  5036					      repend
   3498  5037		       00		      .byte.b	0
   3497  5037					      repend
   3498  5038		       00		      .byte.b	0
   3497  5038					      repend
   3498  5039		       00		      .byte.b	0
   3497  5039					      repend
   3498  503a		       00		      .byte.b	0
   3497  503a					      repend
   3498  503b		       00		      .byte.b	0
   3497  503b					      repend
   3498  503c		       00		      .byte.b	0
   3497  503c					      repend
   3498  503d		       00		      .byte.b	0
   3497  503d					      repend
   3498  503e		       00		      .byte.b	0
   3497  503e					      repend
   3498  503f		       00		      .byte.b	0
   3497  503f					      repend
   3498  5040		       00		      .byte.b	0
   3497  5040					      repend
   3498  5041		       00		      .byte.b	0
   3497  5041					      repend
   3498  5042		       00		      .byte.b	0
   3497  5042					      repend
   3498  5043		       00		      .byte.b	0
   3497  5043					      repend
   3498  5044		       00		      .byte.b	0
   3497  5044					      repend
   3498  5045		       00		      .byte.b	0
   3497  5045					      repend
   3498  5046		       00		      .byte.b	0
   3497  5046					      repend
   3498  5047		       00		      .byte.b	0
   3497  5047					      repend
   3498  5048		       00		      .byte.b	0
   3497  5048					      repend
   3498  5049		       00		      .byte.b	0
   3497  5049					      repend
   3498  504a		       00		      .byte.b	0
   3497  504a					      repend
   3498  504b		       00		      .byte.b	0
   3497  504b					      repend
   3498  504c		       00		      .byte.b	0
   3497  504c					      repend
   3498  504d		       00		      .byte.b	0
   3497  504d					      repend
   3498  504e		       00		      .byte.b	0
   3497  504e					      repend
   3498  504f		       00		      .byte.b	0
   3497  504f					      repend
   3498  5050		       00		      .byte.b	0
   3497  5050					      repend
   3498  5051		       00		      .byte.b	0
   3497  5051					      repend
   3498  5052		       00		      .byte.b	0
   3497  5052					      repend
   3498  5053		       00		      .byte.b	0
   3497  5053					      repend
   3498  5054		       00		      .byte.b	0
   3497  5054					      repend
   3498  5055		       00		      .byte.b	0
   3497  5055					      repend
   3498  5056		       00		      .byte.b	0
   3497  5056					      repend
   3498  5057		       00		      .byte.b	0
   3497  5057					      repend
   3498  5058		       00		      .byte.b	0
   3497  5058					      repend
   3498  5059		       00		      .byte.b	0
   3497  5059					      repend
   3498  505a		       00		      .byte.b	0
   3497  505a					      repend
   3498  505b		       00		      .byte.b	0
   3497  505b					      repend
   3498  505c		       00		      .byte.b	0
   3497  505c					      repend
   3498  505d		       00		      .byte.b	0
   3497  505d					      repend
   3498  505e		       00		      .byte.b	0
   3497  505e					      repend
   3498  505f		       00		      .byte.b	0
   3497  505f					      repend
   3498  5060		       00		      .byte.b	0
   3497  5060					      repend
   3498  5061		       00		      .byte.b	0
   3497  5061					      repend
   3498  5062		       00		      .byte.b	0
   3497  5062					      repend
   3498  5063		       00		      .byte.b	0
   3497  5063					      repend
   3498  5064		       00		      .byte.b	0
   3497  5064					      repend
   3498  5065		       00		      .byte.b	0
   3497  5065					      repend
   3498  5066		       00		      .byte.b	0
   3497  5066					      repend
   3498  5067		       00		      .byte.b	0
   3497  5067					      repend
   3498  5068		       00		      .byte.b	0
   3497  5068					      repend
   3498  5069		       00		      .byte.b	0
   3497  5069					      repend
   3498  506a		       00		      .byte.b	0
   3497  506a					      repend
   3498  506b		       00		      .byte.b	0
   3497  506b					      repend
   3498  506c		       00		      .byte.b	0
   3497  506c					      repend
   3498  506d		       00		      .byte.b	0
   3497  506d					      repend
   3498  506e		       00		      .byte.b	0
   3497  506e					      repend
   3498  506f		       00		      .byte.b	0
   3497  506f					      repend
   3498  5070		       00		      .byte.b	0
   3497  5070					      repend
   3498  5071		       00		      .byte.b	0
   3497  5071					      repend
   3498  5072		       00		      .byte.b	0
   3497  5072					      repend
   3498  5073		       00		      .byte.b	0
   3497  5073					      repend
   3498  5074		       00		      .byte.b	0
   3497  5074					      repend
   3498  5075		       00		      .byte.b	0
   3497  5075					      repend
   3498  5076		       00		      .byte.b	0
   3497  5076					      repend
   3498  5077		       00		      .byte.b	0
   3497  5077					      repend
   3498  5078		       00		      .byte.b	0
   3497  5078					      repend
   3498  5079		       00		      .byte.b	0
   3497  5079					      repend
   3498  507a		       00		      .byte.b	0
   3497  507a					      repend
   3498  507b		       00		      .byte.b	0
   3497  507b					      repend
   3498  507c		       00		      .byte.b	0
   3497  507c					      repend
   3498  507d		       00		      .byte.b	0
   3497  507d					      repend
   3498  507e		       00		      .byte.b	0
   3497  507e					      repend
   3498  507f		       00		      .byte.b	0
   3497  507f					      repend
   3498  5080		       00		      .byte.b	0
   3499  5081					      repend
   3500  5081				   .L0190		;  temp1 = temp1
   3501  5081
   3502  5081		       a5 cb		      LDA	temp1
   3503  5083		       85 cb		      STA	temp1
   3504  5085				   .
   3505  5085							; 
   3506  5085
   3507  5085				   .L0191		;  bank 6
   3508  5085
   3509  5085					      if	ECHO5
      3919 bytes of ROM space left in bank 5
   3510  5085					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   3511  5085					      endif
   3512  5085		       00 01	   ECHO5      =	1
   3513  5fd4					      ORG	$5FF4-bscode_length
   3514  5fd4					      RORG	$9FF4-bscode_length
   3515  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   3516  5fd6					      ifconst	FASTFETCH	; using DPC+
   3517  5fd6		       8e 58 10 	      stx	FASTFETCH
   3518  5fd9					      endif
   3519  5fd9		       9a		      txs
   3520  5fda				  -	      if	bankswitch == 64
   3521  5fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3522  5fda					      else
   3523  5fda		       a9 18		      lda	#>(start-1)
   3524  5fdc					      endif
   3525  5fdc		       48		      pha
   3526  5fdd		       a9 eb		      lda	#<(start-1)
   3527  5fdf		       48		      pha
   3528  5fe0		       48		      pha
   3529  5fe1		       8a		      txa
   3530  5fe2		       48		      pha
   3531  5fe3		       ba		      tsx
   3532  5fe4					      if	bankswitch != 64
   3533  5fe4		       b5 04		      lda	4,x	; get high byte of return address
   3534  5fe6		       2a		      rol
   3535  5fe7		       2a		      rol
   3536  5fe8		       2a		      rol
   3537  5fe9		       2a		      rol
   3538  5fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3539  5fec		       aa		      tax
   3540  5fed		       e8		      inx
   3541  5fee				  -	      else
   3542  5fee				  -	      lda	4,x	; get high byte of return address
   3543  5fee				  -	      tay
   3544  5fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3545  5fee				  -	      sta	4,x
   3546  5fee				  -	      tya
   3547  5fee				  -	      lsr
   3548  5fee				  -	      lsr
   3549  5fee				  -	      lsr
   3550  5fee				  -	      lsr
   3551  5fee				  -	      tax
   3552  5fee				  -	      inx
   3553  5fee					      endif
   3554  5fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3555  5ff1		       68		      pla
   3556  5ff2		       aa		      tax
   3557  5ff3		       68		      pla
   3558  5ff4		       60		      rts
   3559  5ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3560  5ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3561  5ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3562  5ff5					      endif
   3563  5ffc					      ORG	$5FFC
   3564  5ffc					      RORG	$9FFC
   3565  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   3566  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   3567  6000					      ORG	$6000
   3568  6000					      RORG	$B000
   3569  6000					      repeat	129
   3570  6000		       00		      .byte.b	0
   3569  6000					      repend
   3570  6001		       00		      .byte.b	0
   3569  6001					      repend
   3570  6002		       00		      .byte.b	0
   3569  6002					      repend
   3570  6003		       00		      .byte.b	0
   3569  6003					      repend
   3570  6004		       00		      .byte.b	0
   3569  6004					      repend
   3570  6005		       00		      .byte.b	0
   3569  6005					      repend
   3570  6006		       00		      .byte.b	0
   3569  6006					      repend
   3570  6007		       00		      .byte.b	0
   3569  6007					      repend
   3570  6008		       00		      .byte.b	0
   3569  6008					      repend
   3570  6009		       00		      .byte.b	0
   3569  6009					      repend
   3570  600a		       00		      .byte.b	0
   3569  600a					      repend
   3570  600b		       00		      .byte.b	0
   3569  600b					      repend
   3570  600c		       00		      .byte.b	0
   3569  600c					      repend
   3570  600d		       00		      .byte.b	0
   3569  600d					      repend
   3570  600e		       00		      .byte.b	0
   3569  600e					      repend
   3570  600f		       00		      .byte.b	0
   3569  600f					      repend
   3570  6010		       00		      .byte.b	0
   3569  6010					      repend
   3570  6011		       00		      .byte.b	0
   3569  6011					      repend
   3570  6012		       00		      .byte.b	0
   3569  6012					      repend
   3570  6013		       00		      .byte.b	0
   3569  6013					      repend
   3570  6014		       00		      .byte.b	0
   3569  6014					      repend
   3570  6015		       00		      .byte.b	0
   3569  6015					      repend
   3570  6016		       00		      .byte.b	0
   3569  6016					      repend
   3570  6017		       00		      .byte.b	0
   3569  6017					      repend
   3570  6018		       00		      .byte.b	0
   3569  6018					      repend
   3570  6019		       00		      .byte.b	0
   3569  6019					      repend
   3570  601a		       00		      .byte.b	0
   3569  601a					      repend
   3570  601b		       00		      .byte.b	0
   3569  601b					      repend
   3570  601c		       00		      .byte.b	0
   3569  601c					      repend
   3570  601d		       00		      .byte.b	0
   3569  601d					      repend
   3570  601e		       00		      .byte.b	0
   3569  601e					      repend
   3570  601f		       00		      .byte.b	0
   3569  601f					      repend
   3570  6020		       00		      .byte.b	0
   3569  6020					      repend
   3570  6021		       00		      .byte.b	0
   3569  6021					      repend
   3570  6022		       00		      .byte.b	0
   3569  6022					      repend
   3570  6023		       00		      .byte.b	0
   3569  6023					      repend
   3570  6024		       00		      .byte.b	0
   3569  6024					      repend
   3570  6025		       00		      .byte.b	0
   3569  6025					      repend
   3570  6026		       00		      .byte.b	0
   3569  6026					      repend
   3570  6027		       00		      .byte.b	0
   3569  6027					      repend
   3570  6028		       00		      .byte.b	0
   3569  6028					      repend
   3570  6029		       00		      .byte.b	0
   3569  6029					      repend
   3570  602a		       00		      .byte.b	0
   3569  602a					      repend
   3570  602b		       00		      .byte.b	0
   3569  602b					      repend
   3570  602c		       00		      .byte.b	0
   3569  602c					      repend
   3570  602d		       00		      .byte.b	0
   3569  602d					      repend
   3570  602e		       00		      .byte.b	0
   3569  602e					      repend
   3570  602f		       00		      .byte.b	0
   3569  602f					      repend
   3570  6030		       00		      .byte.b	0
   3569  6030					      repend
   3570  6031		       00		      .byte.b	0
   3569  6031					      repend
   3570  6032		       00		      .byte.b	0
   3569  6032					      repend
   3570  6033		       00		      .byte.b	0
   3569  6033					      repend
   3570  6034		       00		      .byte.b	0
   3569  6034					      repend
   3570  6035		       00		      .byte.b	0
   3569  6035					      repend
   3570  6036		       00		      .byte.b	0
   3569  6036					      repend
   3570  6037		       00		      .byte.b	0
   3569  6037					      repend
   3570  6038		       00		      .byte.b	0
   3569  6038					      repend
   3570  6039		       00		      .byte.b	0
   3569  6039					      repend
   3570  603a		       00		      .byte.b	0
   3569  603a					      repend
   3570  603b		       00		      .byte.b	0
   3569  603b					      repend
   3570  603c		       00		      .byte.b	0
   3569  603c					      repend
   3570  603d		       00		      .byte.b	0
   3569  603d					      repend
   3570  603e		       00		      .byte.b	0
   3569  603e					      repend
   3570  603f		       00		      .byte.b	0
   3569  603f					      repend
   3570  6040		       00		      .byte.b	0
   3569  6040					      repend
   3570  6041		       00		      .byte.b	0
   3569  6041					      repend
   3570  6042		       00		      .byte.b	0
   3569  6042					      repend
   3570  6043		       00		      .byte.b	0
   3569  6043					      repend
   3570  6044		       00		      .byte.b	0
   3569  6044					      repend
   3570  6045		       00		      .byte.b	0
   3569  6045					      repend
   3570  6046		       00		      .byte.b	0
   3569  6046					      repend
   3570  6047		       00		      .byte.b	0
   3569  6047					      repend
   3570  6048		       00		      .byte.b	0
   3569  6048					      repend
   3570  6049		       00		      .byte.b	0
   3569  6049					      repend
   3570  604a		       00		      .byte.b	0
   3569  604a					      repend
   3570  604b		       00		      .byte.b	0
   3569  604b					      repend
   3570  604c		       00		      .byte.b	0
   3569  604c					      repend
   3570  604d		       00		      .byte.b	0
   3569  604d					      repend
   3570  604e		       00		      .byte.b	0
   3569  604e					      repend
   3570  604f		       00		      .byte.b	0
   3569  604f					      repend
   3570  6050		       00		      .byte.b	0
   3569  6050					      repend
   3570  6051		       00		      .byte.b	0
   3569  6051					      repend
   3570  6052		       00		      .byte.b	0
   3569  6052					      repend
   3570  6053		       00		      .byte.b	0
   3569  6053					      repend
   3570  6054		       00		      .byte.b	0
   3569  6054					      repend
   3570  6055		       00		      .byte.b	0
   3569  6055					      repend
   3570  6056		       00		      .byte.b	0
   3569  6056					      repend
   3570  6057		       00		      .byte.b	0
   3569  6057					      repend
   3570  6058		       00		      .byte.b	0
   3569  6058					      repend
   3570  6059		       00		      .byte.b	0
   3569  6059					      repend
   3570  605a		       00		      .byte.b	0
   3569  605a					      repend
   3570  605b		       00		      .byte.b	0
   3569  605b					      repend
   3570  605c		       00		      .byte.b	0
   3569  605c					      repend
   3570  605d		       00		      .byte.b	0
   3569  605d					      repend
   3570  605e		       00		      .byte.b	0
   3569  605e					      repend
   3570  605f		       00		      .byte.b	0
   3569  605f					      repend
   3570  6060		       00		      .byte.b	0
   3569  6060					      repend
   3570  6061		       00		      .byte.b	0
   3569  6061					      repend
   3570  6062		       00		      .byte.b	0
   3569  6062					      repend
   3570  6063		       00		      .byte.b	0
   3569  6063					      repend
   3570  6064		       00		      .byte.b	0
   3569  6064					      repend
   3570  6065		       00		      .byte.b	0
   3569  6065					      repend
   3570  6066		       00		      .byte.b	0
   3569  6066					      repend
   3570  6067		       00		      .byte.b	0
   3569  6067					      repend
   3570  6068		       00		      .byte.b	0
   3569  6068					      repend
   3570  6069		       00		      .byte.b	0
   3569  6069					      repend
   3570  606a		       00		      .byte.b	0
   3569  606a					      repend
   3570  606b		       00		      .byte.b	0
   3569  606b					      repend
   3570  606c		       00		      .byte.b	0
   3569  606c					      repend
   3570  606d		       00		      .byte.b	0
   3569  606d					      repend
   3570  606e		       00		      .byte.b	0
   3569  606e					      repend
   3570  606f		       00		      .byte.b	0
   3569  606f					      repend
   3570  6070		       00		      .byte.b	0
   3569  6070					      repend
   3570  6071		       00		      .byte.b	0
   3569  6071					      repend
   3570  6072		       00		      .byte.b	0
   3569  6072					      repend
   3570  6073		       00		      .byte.b	0
   3569  6073					      repend
   3570  6074		       00		      .byte.b	0
   3569  6074					      repend
   3570  6075		       00		      .byte.b	0
   3569  6075					      repend
   3570  6076		       00		      .byte.b	0
   3569  6076					      repend
   3570  6077		       00		      .byte.b	0
   3569  6077					      repend
   3570  6078		       00		      .byte.b	0
   3569  6078					      repend
   3570  6079		       00		      .byte.b	0
   3569  6079					      repend
   3570  607a		       00		      .byte.b	0
   3569  607a					      repend
   3570  607b		       00		      .byte.b	0
   3569  607b					      repend
   3570  607c		       00		      .byte.b	0
   3569  607c					      repend
   3570  607d		       00		      .byte.b	0
   3569  607d					      repend
   3570  607e		       00		      .byte.b	0
   3569  607e					      repend
   3570  607f		       00		      .byte.b	0
   3569  607f					      repend
   3570  6080		       00		      .byte.b	0
   3571  6081					      repend
   3572  6081				   .L0192		;  temp1 = temp1
   3573  6081
   3574  6081		       a5 cb		      LDA	temp1
   3575  6083		       85 cb		      STA	temp1
   3576  6085				   .
   3577  6085							; 
   3578  6085
   3579  6085				   .L0193		;  bank 7
   3580  6085
   3581  6085					      if	ECHO6
      3919 bytes of ROM space left in bank 6
   3582  6085					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   3583  6085					      endif
   3584  6085		       00 01	   ECHO6      =	1
   3585  6fd4					      ORG	$6FF4-bscode_length
   3586  6fd4					      RORG	$BFF4-bscode_length
   3587  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   3588  6fd6					      ifconst	FASTFETCH	; using DPC+
   3589  6fd6		       8e 58 10 	      stx	FASTFETCH
   3590  6fd9					      endif
   3591  6fd9		       9a		      txs
   3592  6fda				  -	      if	bankswitch == 64
   3593  6fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3594  6fda					      else
   3595  6fda		       a9 18		      lda	#>(start-1)
   3596  6fdc					      endif
   3597  6fdc		       48		      pha
   3598  6fdd		       a9 eb		      lda	#<(start-1)
   3599  6fdf		       48		      pha
   3600  6fe0		       48		      pha
   3601  6fe1		       8a		      txa
   3602  6fe2		       48		      pha
   3603  6fe3		       ba		      tsx
   3604  6fe4					      if	bankswitch != 64
   3605  6fe4		       b5 04		      lda	4,x	; get high byte of return address
   3606  6fe6		       2a		      rol
   3607  6fe7		       2a		      rol
   3608  6fe8		       2a		      rol
   3609  6fe9		       2a		      rol
   3610  6fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3611  6fec		       aa		      tax
   3612  6fed		       e8		      inx
   3613  6fee				  -	      else
   3614  6fee				  -	      lda	4,x	; get high byte of return address
   3615  6fee				  -	      tay
   3616  6fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3617  6fee				  -	      sta	4,x
   3618  6fee				  -	      tya
   3619  6fee				  -	      lsr
   3620  6fee				  -	      lsr
   3621  6fee				  -	      lsr
   3622  6fee				  -	      lsr
   3623  6fee				  -	      tax
   3624  6fee				  -	      inx
   3625  6fee					      endif
   3626  6fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3627  6ff1		       68		      pla
   3628  6ff2		       aa		      tax
   3629  6ff3		       68		      pla
   3630  6ff4		       60		      rts
   3631  6ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3632  6ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3633  6ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3634  6ff5					      endif
   3635  6ffc					      ORG	$6FFC
   3636  6ffc					      RORG	$BFFC
   3637  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   3638  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   3639  7000					      ORG	$7000
   3640  7000					      RORG	$D000
   3641  7000					      repeat	129
   3642  7000		       00		      .byte.b	0
   3641  7000					      repend
   3642  7001		       00		      .byte.b	0
   3641  7001					      repend
   3642  7002		       00		      .byte.b	0
   3641  7002					      repend
   3642  7003		       00		      .byte.b	0
   3641  7003					      repend
   3642  7004		       00		      .byte.b	0
   3641  7004					      repend
   3642  7005		       00		      .byte.b	0
   3641  7005					      repend
   3642  7006		       00		      .byte.b	0
   3641  7006					      repend
   3642  7007		       00		      .byte.b	0
   3641  7007					      repend
   3642  7008		       00		      .byte.b	0
   3641  7008					      repend
   3642  7009		       00		      .byte.b	0
   3641  7009					      repend
   3642  700a		       00		      .byte.b	0
   3641  700a					      repend
   3642  700b		       00		      .byte.b	0
   3641  700b					      repend
   3642  700c		       00		      .byte.b	0
   3641  700c					      repend
   3642  700d		       00		      .byte.b	0
   3641  700d					      repend
   3642  700e		       00		      .byte.b	0
   3641  700e					      repend
   3642  700f		       00		      .byte.b	0
   3641  700f					      repend
   3642  7010		       00		      .byte.b	0
   3641  7010					      repend
   3642  7011		       00		      .byte.b	0
   3641  7011					      repend
   3642  7012		       00		      .byte.b	0
   3641  7012					      repend
   3642  7013		       00		      .byte.b	0
   3641  7013					      repend
   3642  7014		       00		      .byte.b	0
   3641  7014					      repend
   3642  7015		       00		      .byte.b	0
   3641  7015					      repend
   3642  7016		       00		      .byte.b	0
   3641  7016					      repend
   3642  7017		       00		      .byte.b	0
   3641  7017					      repend
   3642  7018		       00		      .byte.b	0
   3641  7018					      repend
   3642  7019		       00		      .byte.b	0
   3641  7019					      repend
   3642  701a		       00		      .byte.b	0
   3641  701a					      repend
   3642  701b		       00		      .byte.b	0
   3641  701b					      repend
   3642  701c		       00		      .byte.b	0
   3641  701c					      repend
   3642  701d		       00		      .byte.b	0
   3641  701d					      repend
   3642  701e		       00		      .byte.b	0
   3641  701e					      repend
   3642  701f		       00		      .byte.b	0
   3641  701f					      repend
   3642  7020		       00		      .byte.b	0
   3641  7020					      repend
   3642  7021		       00		      .byte.b	0
   3641  7021					      repend
   3642  7022		       00		      .byte.b	0
   3641  7022					      repend
   3642  7023		       00		      .byte.b	0
   3641  7023					      repend
   3642  7024		       00		      .byte.b	0
   3641  7024					      repend
   3642  7025		       00		      .byte.b	0
   3641  7025					      repend
   3642  7026		       00		      .byte.b	0
   3641  7026					      repend
   3642  7027		       00		      .byte.b	0
   3641  7027					      repend
   3642  7028		       00		      .byte.b	0
   3641  7028					      repend
   3642  7029		       00		      .byte.b	0
   3641  7029					      repend
   3642  702a		       00		      .byte.b	0
   3641  702a					      repend
   3642  702b		       00		      .byte.b	0
   3641  702b					      repend
   3642  702c		       00		      .byte.b	0
   3641  702c					      repend
   3642  702d		       00		      .byte.b	0
   3641  702d					      repend
   3642  702e		       00		      .byte.b	0
   3641  702e					      repend
   3642  702f		       00		      .byte.b	0
   3641  702f					      repend
   3642  7030		       00		      .byte.b	0
   3641  7030					      repend
   3642  7031		       00		      .byte.b	0
   3641  7031					      repend
   3642  7032		       00		      .byte.b	0
   3641  7032					      repend
   3642  7033		       00		      .byte.b	0
   3641  7033					      repend
   3642  7034		       00		      .byte.b	0
   3641  7034					      repend
   3642  7035		       00		      .byte.b	0
   3641  7035					      repend
   3642  7036		       00		      .byte.b	0
   3641  7036					      repend
   3642  7037		       00		      .byte.b	0
   3641  7037					      repend
   3642  7038		       00		      .byte.b	0
   3641  7038					      repend
   3642  7039		       00		      .byte.b	0
   3641  7039					      repend
   3642  703a		       00		      .byte.b	0
   3641  703a					      repend
   3642  703b		       00		      .byte.b	0
   3641  703b					      repend
   3642  703c		       00		      .byte.b	0
   3641  703c					      repend
   3642  703d		       00		      .byte.b	0
   3641  703d					      repend
   3642  703e		       00		      .byte.b	0
   3641  703e					      repend
   3642  703f		       00		      .byte.b	0
   3641  703f					      repend
   3642  7040		       00		      .byte.b	0
   3641  7040					      repend
   3642  7041		       00		      .byte.b	0
   3641  7041					      repend
   3642  7042		       00		      .byte.b	0
   3641  7042					      repend
   3642  7043		       00		      .byte.b	0
   3641  7043					      repend
   3642  7044		       00		      .byte.b	0
   3641  7044					      repend
   3642  7045		       00		      .byte.b	0
   3641  7045					      repend
   3642  7046		       00		      .byte.b	0
   3641  7046					      repend
   3642  7047		       00		      .byte.b	0
   3641  7047					      repend
   3642  7048		       00		      .byte.b	0
   3641  7048					      repend
   3642  7049		       00		      .byte.b	0
   3641  7049					      repend
   3642  704a		       00		      .byte.b	0
   3641  704a					      repend
   3642  704b		       00		      .byte.b	0
   3641  704b					      repend
   3642  704c		       00		      .byte.b	0
   3641  704c					      repend
   3642  704d		       00		      .byte.b	0
   3641  704d					      repend
   3642  704e		       00		      .byte.b	0
   3641  704e					      repend
   3642  704f		       00		      .byte.b	0
   3641  704f					      repend
   3642  7050		       00		      .byte.b	0
   3641  7050					      repend
   3642  7051		       00		      .byte.b	0
   3641  7051					      repend
   3642  7052		       00		      .byte.b	0
   3641  7052					      repend
   3642  7053		       00		      .byte.b	0
   3641  7053					      repend
   3642  7054		       00		      .byte.b	0
   3641  7054					      repend
   3642  7055		       00		      .byte.b	0
   3641  7055					      repend
   3642  7056		       00		      .byte.b	0
   3641  7056					      repend
   3642  7057		       00		      .byte.b	0
   3641  7057					      repend
   3642  7058		       00		      .byte.b	0
   3641  7058					      repend
   3642  7059		       00		      .byte.b	0
   3641  7059					      repend
   3642  705a		       00		      .byte.b	0
   3641  705a					      repend
   3642  705b		       00		      .byte.b	0
   3641  705b					      repend
   3642  705c		       00		      .byte.b	0
   3641  705c					      repend
   3642  705d		       00		      .byte.b	0
   3641  705d					      repend
   3642  705e		       00		      .byte.b	0
   3641  705e					      repend
   3642  705f		       00		      .byte.b	0
   3641  705f					      repend
   3642  7060		       00		      .byte.b	0
   3641  7060					      repend
   3642  7061		       00		      .byte.b	0
   3641  7061					      repend
   3642  7062		       00		      .byte.b	0
   3641  7062					      repend
   3642  7063		       00		      .byte.b	0
   3641  7063					      repend
   3642  7064		       00		      .byte.b	0
   3641  7064					      repend
   3642  7065		       00		      .byte.b	0
   3641  7065					      repend
   3642  7066		       00		      .byte.b	0
   3641  7066					      repend
   3642  7067		       00		      .byte.b	0
   3641  7067					      repend
   3642  7068		       00		      .byte.b	0
   3641  7068					      repend
   3642  7069		       00		      .byte.b	0
   3641  7069					      repend
   3642  706a		       00		      .byte.b	0
   3641  706a					      repend
   3642  706b		       00		      .byte.b	0
   3641  706b					      repend
   3642  706c		       00		      .byte.b	0
   3641  706c					      repend
   3642  706d		       00		      .byte.b	0
   3641  706d					      repend
   3642  706e		       00		      .byte.b	0
   3641  706e					      repend
   3642  706f		       00		      .byte.b	0
   3641  706f					      repend
   3642  7070		       00		      .byte.b	0
   3641  7070					      repend
   3642  7071		       00		      .byte.b	0
   3641  7071					      repend
   3642  7072		       00		      .byte.b	0
   3641  7072					      repend
   3642  7073		       00		      .byte.b	0
   3641  7073					      repend
   3642  7074		       00		      .byte.b	0
   3641  7074					      repend
   3642  7075		       00		      .byte.b	0
   3641  7075					      repend
   3642  7076		       00		      .byte.b	0
   3641  7076					      repend
   3642  7077		       00		      .byte.b	0
   3641  7077					      repend
   3642  7078		       00		      .byte.b	0
   3641  7078					      repend
   3642  7079		       00		      .byte.b	0
   3641  7079					      repend
   3642  707a		       00		      .byte.b	0
   3641  707a					      repend
   3642  707b		       00		      .byte.b	0
   3641  707b					      repend
   3642  707c		       00		      .byte.b	0
   3641  707c					      repend
   3642  707d		       00		      .byte.b	0
   3641  707d					      repend
   3642  707e		       00		      .byte.b	0
   3641  707e					      repend
   3642  707f		       00		      .byte.b	0
   3641  707f					      repend
   3642  7080		       00		      .byte.b	0
   3643  7081					      repend
   3644  7081							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3645  7081
   3646  7081							;----------------------------------------
   3647  7081							; Display Data
   3648  7081							;----------------------------------------
   3649  7081							; The Display Data bank is copied into RAM when DPC+ initializes the cartridge.
   3650  7081							; This allows us to manipulate the data during run-time, but have a known
   3651  7081							; starting state when the Atari is first turned on.
   3652  7081							;
   3653  7081							; Unlike normal Atari VCS/2600 sprite definitions, the sprite data in the
   3654  7081							; Display Data bank is stored right-side-up.
   3655  7081							;
   3656  7081							;----------------------------------------
   3657  7081
   3658  7081				   Zeros32
   3659  7081		       00 84	   SOUND_OFF  =	(* & $1fff)/32
   3660  7081				   DisplayDataDigitBlank
   3661  7081		       00		      .byte.b	0	;--
   3662  7082		       00		      .byte.b	0	;--
   3663  7083		       00		      .byte.b	0	;--
   3664  7084		       00		      .byte.b	0	;--
   3665  7085		       00		      .byte.b	0	;--
   3666  7086		       00		      .byte.b	0	;--
   3667  7087		       00		      .byte.b	0	;--
   3668  7088		       00		      .byte.b	0	;--
   3669  7089
   3670  7089							;	align 32
   3671  7089							;Zeros32:
   3672  7089							;SOUND_OFF = (* & $1fff)/32
   3673  7089							;	.byte 0,0,0,0,0,0,0,0
   3674  7089		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3675  7091		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3676  7099		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3677  70a1
   3678  70a1		       00 85	   SINE_WAVE  =	(* & $1fff)/32
   3679  70a1		       03 03 03 04*	      .byte.b	3,3,3,4,4,5,5,5
   3680  70a9		       05 05 05 05*	      .byte.b	5,5,5,5,4,4,3,3
   3681  70b1		       03 02 02 01*	      .byte.b	3,2,2,1,1,0,0,0
   3682  70b9		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,2,2
   3683  70c1
   3684  70e0		       00 00 00 00*	      align	32
   3685  70e0		       00 87	   TRIANGLE_WAVE =	(* & $1fff)/32
   3686  70e0		       00 00 01 01*	      .byte.b	0,0,1,1,1,2,2,2
   3687  70e8		       03 03 03 04*	      .byte.b	3,3,3,4,4,4,5,5
   3688  70f0		       05 05 04 04*	      .byte.b	5,5,4,4,4,3,3,3
   3689  70f8		       02 02 02 01*	      .byte.b	2,2,2,1,1,1,0,0
   3690  7100
   3691  7100					      align	32
   3692  7100		       00 88	   SAWTOOTH_WAVE =	(* & $1fff)/32
   3693  7100		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,1,1
   3694  7108		       01 01 02 02*	      .byte.b	1,1,2,2,2,2,2,2
   3695  7110		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,4,4
   3696  7118		       04 04 04 04*	      .byte.b	4,4,4,4,5,5,5,5
   3697  7120
   3698  7120					      align	32
   3699  7120		       00 89	   SQUARE_WAVE_VOL5 =	(* & $1fff)/32
   3700  7120		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3701  7128		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3702  7130		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   3703  7138		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   3704  7140
   3705  7140					      align	32
   3706  7140		       00 8a	   SQUARE_WAVE_VOL4 =	(* & $1fff)/32
   3707  7140		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3708  7148		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3709  7150		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   3710  7158		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   3711  7160
   3712  7160					      align	32
   3713  7160		       00 8b	   SQUARE_WAVE_VOL3 =	(* & $1fff)/32
   3714  7160		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3715  7168		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   3716  7170		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   3717  7178		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   3718  7180
   3719  7180					      align	32
   3720  7180		       00 8c	   NOISE_WAVE =	(* & $1fff)/32
   3721  7180		       07 01 09 0a*	      .byte.b	7, 1, 9,10, 2, 8, 8,14
   3722  7188		       03 0d 08 05*	      .byte.b	3,13, 8, 5,12, 2, 3, 7
   3723  7190		       07 01 08 04*	      .byte.b	7, 1, 8, 4,15, 1,13, 5
   3724  7198		       08 05 0b 06*	      .byte.b	8, 5,11, 6, 8, 7, 9, 2
   3725  71a0
   3726  71a0							; low and high byte of address table (for ROMdata array in C)
   3727  71a0		       5a		      .byte.b	<fetcher_address_table
   3728  71a1		       0d		      .byte.b	((>fetcher_address_table) & $0f) | (((>fetcher_address_table) / 2) & $70)
   3729  71a2		       00		      .byte.b	0
   3730  71a3		       00		      .byte.b	0
   3731  71a4				   FETCHER_BEGIN
   3732  71a4		       10		      .byte.b	16
   3733  71a5		       10		      .byte.b	16
   3734  71a6		       10		      .byte.b	16
   3735  71a7		       10		      .byte.b	16	; to zero-fill on boot
   3736  71a8							;bB.asm
   3737  71a8							; bB.asm file is split here
   3738  71a8				   .L0194		;  temp1 = temp1
   3739  71a8		       a5 cb		      LDA	temp1
   3740  71aa		       85 cb		      STA	temp1
   3741  71ac				   backgroundcolorL07
   3742  71ac		       00		      .byte.b	$00
   3743  71ad				   backgroundcolorL010
   3744  71ad		       40		      .byte.b	$40
   3745  71ae				   playerL023_0
   3746  71ae		       f0		      .byte.b	%11110000
   3747  71af		       f0		      .byte.b	%11110000
   3748  71b0		       f0		      .byte.b	%11110000
   3749  71b1		       f0		      .byte.b	%11110000
   3750  71b2		       f0		      .byte.b	%11110000
   3751  71b3		       f0		      .byte.b	%11110000
   3752  71b4		       f0		      .byte.b	%11110000
   3753  71b5		       f0		      .byte.b	%11110000
   3754  71b6				   playercolorL024_0
   3755  71b6		       7a		      .byte.b	$7a
   3756  71b7		       7a		      .byte.b	$7a
   3757  71b8		       7a		      .byte.b	$7a
   3758  71b9		       7a		      .byte.b	$7a
   3759  71ba		       7a		      .byte.b	$7a
   3760  71bb		       7a		      .byte.b	$7a
   3761  71bc		       7a		      .byte.b	$7a
   3762  71bd		       7a		      .byte.b	$7a
   3763  71be				   playerL025_1
   3764  71be		       f0		      .byte.b	%11110000
   3765  71bf		       f0		      .byte.b	%11110000
   3766  71c0		       f0		      .byte.b	%11110000
   3767  71c1		       f0		      .byte.b	%11110000
   3768  71c2		       f0		      .byte.b	%11110000
   3769  71c3		       f0		      .byte.b	%11110000
   3770  71c4		       f0		      .byte.b	%11110000
   3771  71c5		       f0		      .byte.b	%11110000
   3772  71c6				   playercolorL026_1
   3773  71c6		       ac		      .byte.b	$ac
   3774  71c7		       ac		      .byte.b	$ac
   3775  71c8		       ac		      .byte.b	$ac
   3776  71c9		       ac		      .byte.b	$ac
   3777  71ca		       ac		      .byte.b	$ac
   3778  71cb		       ac		      .byte.b	$ac
   3779  71cc		       ac		      .byte.b	$ac
   3780  71cd		       ac		      .byte.b	$ac
   3781  71ce				   PF_data1
   3782  71ce		       ff		      .byte.b	%11111111
   3783  71cf		       80		      .byte.b	%10000000
   3784  71d0		       80		      .byte.b	%10000000
   3785  71d1		       80		      .byte.b	%10000000
   3786  71d2		       80		      .byte.b	%10000000
   3787  71d3		       80		      .byte.b	%10000000
   3788  71d4		       80		      .byte.b	%10000000
   3789  71d5		       80		      .byte.b	%10000000
   3790  71d6		       80		      .byte.b	%10000000
   3791  71d7		       80		      .byte.b	%10000000
   3792  71d8		       80		      .byte.b	%10000000
   3793  71d9		       80		      .byte.b	%10000000
   3794  71da		       80		      .byte.b	%10000000
   3795  71db		       80		      .byte.b	%10000000
   3796  71dc		       80		      .byte.b	%10000000
   3797  71dd		       80		      .byte.b	%10000000
   3798  71de		       80		      .byte.b	%10000000
   3799  71df		       80		      .byte.b	%10000000
   3800  71e0		       80		      .byte.b	%10000000
   3801  71e1		       80		      .byte.b	%10000000
   3802  71e2		       80		      .byte.b	%10000000
   3803  71e3		       ff		      .byte.b	%11111111
   3804  71e4		       ff		      .byte.b	%11111111
   3805  71e5		       00		      .byte.b	%00000000
   3806  71e6		       00		      .byte.b	%00000000
   3807  71e7		       00		      .byte.b	%00000000
   3808  71e8		       00		      .byte.b	%00000000
   3809  71e9		       00		      .byte.b	%00000000
   3810  71ea		       00		      .byte.b	%00000000
   3811  71eb		       00		      .byte.b	%00000000
   3812  71ec		       00		      .byte.b	%00000000
   3813  71ed		       00		      .byte.b	%00000000
   3814  71ee		       00		      .byte.b	%00000000
   3815  71ef		       00		      .byte.b	%00000000
   3816  71f0		       00		      .byte.b	%00000000
   3817  71f1		       00		      .byte.b	%00000000
   3818  71f2		       00		      .byte.b	%00000000
   3819  71f3		       00		      .byte.b	%00000000
   3820  71f4		       00		      .byte.b	%00000000
   3821  71f5		       00		      .byte.b	%00000000
   3822  71f6		       00		      .byte.b	%00000000
   3823  71f7		       00		      .byte.b	%00000000
   3824  71f8		       00		      .byte.b	%00000000
   3825  71f9		       ff		      .byte.b	%11111111
   3826  71fa		       ff		      .byte.b	%11111111
   3827  71fb		       00		      .byte.b	%00000000
   3828  71fc		       00		      .byte.b	%00000000
   3829  71fd		       00		      .byte.b	%00000000
   3830  71fe		       00		      .byte.b	%00000000
   3831  71ff		       00		      .byte.b	%00000000
   3832  7200		       00		      .byte.b	%00000000
   3833  7201		       00		      .byte.b	%00000000
   3834  7202		       00		      .byte.b	%00000000
   3835  7203		       00		      .byte.b	%00000000
   3836  7204		       00		      .byte.b	%00000000
   3837  7205		       00		      .byte.b	%00000000
   3838  7206		       00		      .byte.b	%00000000
   3839  7207		       00		      .byte.b	%00000000
   3840  7208		       00		      .byte.b	%00000000
   3841  7209		       00		      .byte.b	%00000000
   3842  720a		       00		      .byte.b	%00000000
   3843  720b		       00		      .byte.b	%00000000
   3844  720c		       00		      .byte.b	%00000000
   3845  720d		       00		      .byte.b	%00000000
   3846  720e		       00		      .byte.b	%00000000
   3847  720f		       ff		      .byte.b	%11111111
   3848  7210		       ff		      .byte.b	%11111111
   3849  7211		       80		      .byte.b	%10000000
   3850  7212		       80		      .byte.b	%10000000
   3851  7213		       80		      .byte.b	%10000000
   3852  7214		       80		      .byte.b	%10000000
   3853  7215		       80		      .byte.b	%10000000
   3854  7216		       80		      .byte.b	%10000000
   3855  7217		       80		      .byte.b	%10000000
   3856  7218		       80		      .byte.b	%10000000
   3857  7219		       80		      .byte.b	%10000000
   3858  721a		       80		      .byte.b	%10000000
   3859  721b		       80		      .byte.b	%10000000
   3860  721c		       80		      .byte.b	%10000000
   3861  721d		       80		      .byte.b	%10000000
   3862  721e		       80		      .byte.b	%10000000
   3863  721f		       80		      .byte.b	%10000000
   3864  7220		       80		      .byte.b	%10000000
   3865  7221		       80		      .byte.b	%10000000
   3866  7222		       80		      .byte.b	%10000000
   3867  7223		       80		      .byte.b	%10000000
   3868  7224		       80		      .byte.b	%10000000
   3869  7225		       ff		      .byte.b	%11111111
   3870  7226				   playfieldcolorL028
   3871  7226		       3a		      .byte.b	$3a
   3872  7227				   backgroundcolorL029
   3873  7227		       90		      .byte.b	$90
   3874  7228		       90		      .byte.b	$90
   3875  7229		       90		      .byte.b	$90
   3876  722a		       90		      .byte.b	$90
   3877  722b		       90		      .byte.b	$90
   3878  722c		       90		      .byte.b	$90
   3879  722d		       90		      .byte.b	$90
   3880  722e		       90		      .byte.b	$90
   3881  722f		       00		      .byte.b	$00
   3882  7230		       90		      .byte.b	$90
   3883  7231		       90		      .byte.b	$90
   3884  7232		       90		      .byte.b	$90
   3885  7233		       90		      .byte.b	$90
   3886  7234		       90		      .byte.b	$90
   3887  7235		       90		      .byte.b	$90
   3888  7236		       90		      .byte.b	$90
   3889  7237		       90		      .byte.b	$90
   3890  7238		       90		      .byte.b	$90
   3891  7239		       00		      .byte.b	$00
   3892  723a		       90		      .byte.b	$90
   3893  723b		       90		      .byte.b	$90
   3894  723c		       90		      .byte.b	$90
   3895  723d		       90		      .byte.b	$90
   3896  723e		       90		      .byte.b	$90
   3897  723f		       90		      .byte.b	$90
   3898  7240		       90		      .byte.b	$90
   3899  7241		       90		      .byte.b	$90
   3900  7242		       90		      .byte.b	$90
   3901  7243		       00		      .byte.b	$00
   3902  7244		       90		      .byte.b	$90
   3903  7245		       90		      .byte.b	$90
   3904  7246		       90		      .byte.b	$90
   3905  7247		       90		      .byte.b	$90
   3906  7248		       90		      .byte.b	$90
   3907  7249		       90		      .byte.b	$90
   3908  724a		       90		      .byte.b	$90
   3909  724b		       90		      .byte.b	$90
   3910  724c		       90		      .byte.b	$90
   3911  724d		       00		      .byte.b	$00
   3912  724e		       90		      .byte.b	$90
   3913  724f		       90		      .byte.b	$90
   3914  7250		       90		      .byte.b	$90
   3915  7251		       90		      .byte.b	$90
   3916  7252		       90		      .byte.b	$90
   3917  7253		       90		      .byte.b	$90
   3918  7254		       90		      .byte.b	$90
   3919  7255		       90		      .byte.b	$90
   3920  7256		       90		      .byte.b	$90
   3921  7257		       00		      .byte.b	$00
   3922  7258		       90		      .byte.b	$90
   3923  7259		       90		      .byte.b	$90
   3924  725a		       90		      .byte.b	$90
   3925  725b		       90		      .byte.b	$90
   3926  725c		       90		      .byte.b	$90
   3927  725d		       90		      .byte.b	$90
   3928  725e		       90		      .byte.b	$90
   3929  725f		       90		      .byte.b	$90
   3930  7260		       90		      .byte.b	$90
   3931  7261		       00		      .byte.b	$00
   3932  7262		       90		      .byte.b	$90
   3933  7263		       90		      .byte.b	$90
   3934  7264		       90		      .byte.b	$90
   3935  7265		       90		      .byte.b	$90
   3936  7266		       90		      .byte.b	$90
   3937  7267		       90		      .byte.b	$90
   3938  7268		       90		      .byte.b	$90
   3939  7269		       90		      .byte.b	$90
   3940  726a		       90		      .byte.b	$90
   3941  726b		       00		      .byte.b	$00
   3942  726c		       90		      .byte.b	$90
   3943  726d		       90		      .byte.b	$90
   3944  726e		       90		      .byte.b	$90
   3945  726f		       90		      .byte.b	$90
   3946  7270		       90		      .byte.b	$90
   3947  7271		       90		      .byte.b	$90
   3948  7272		       90		      .byte.b	$90
   3949  7273		       90		      .byte.b	$90
   3950  7274		       90		      .byte.b	$90
   3951  7275		       00		      .byte.b	$00
   3952  7276		       90		      .byte.b	$90
   3953  7277		       90		      .byte.b	$90
   3954  7278		       90		      .byte.b	$90
   3955  7279		       90		      .byte.b	$90
   3956  727a		       90		      .byte.b	$90
   3957  727b		       90		      .byte.b	$90
   3958  727c		       90		      .byte.b	$90
   3959  727d		       90		      .byte.b	$90
   3960  727e				   playercolorL0157_1
   3961  727e		       cc		      .byte.b	$cc
   3962  727f		       cc		      .byte.b	$cc
   3963  7280		       cc		      .byte.b	$cc
   3964  7281		       cc		      .byte.b	$cc
   3965  7282		       cc		      .byte.b	$cc
   3966  7283		       cc		      .byte.b	$cc
   3967  7284		       cc		      .byte.b	$cc
   3968  7285		       cc		      .byte.b	$cc
   3969  7286				   playercolorL0168_1
   3970  7286		       ac		      .byte.b	$ac
   3971  7287		       ac		      .byte.b	$ac
   3972  7288		       ac		      .byte.b	$ac
   3973  7289		       ac		      .byte.b	$ac
   3974  728a		       ac		      .byte.b	$ac
   3975  728b		       ac		      .byte.b	$ac
   3976  728c		       ac		      .byte.b	$ac
   3977  728d		       ac		      .byte.b	$ac
   3978  728e					      if	ECHOFIRST
      3398 bytes of ROM space left in graphics bank
   3979  728e					      echo	"    ",[(DPC_graphics_end - *)]d , "bytes of ROM space left in graphics bank")
   3980  728e					      endif
   3981  728e		       00 01	   ECHOFIRST  =	1
   3982  728e
   3983  728e
   3984  728e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3985  728e
   3986  7fd4					      ORG	$7FF4-bscode_length
   3987  7fd4					      RORG	$DFF4-bscode_length
   3988  7fd4				   DPC_graphics_end
   3989  7fd4
   3990  7fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3991  7fd4
   3992  7fd4							; every bank has this stuff at the same place
   3993  7fd4							; this code can switch to/from any bank at any entry point
   3994  7fd4							; and can preserve register values
   3995  7fd4							; note: lines not starting with a space are not placed in all banks
   3996  7fd4							;
   3997  7fd4							; line below tells the compiler how long this is - do not remove
   3998  7fd4							;size=32
   3999  7fd4
   4000  7fd4				   begin_bscode
   4001  7fd4		       a2 ff		      ldx	#$ff
   4002  7fd6					      ifconst	FASTFETCH	; using DPC+
   4003  7fd6		       8e 58 10 	      stx	FASTFETCH
   4004  7fd9					      endif
   4005  7fd9		       9a		      txs
   4006  7fda				  -	      if	bankswitch == 64
   4007  7fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4008  7fda					      else
   4009  7fda		       a9 18		      lda	#>(start-1)
   4010  7fdc					      endif
   4011  7fdc		       48		      pha
   4012  7fdd		       a9 eb		      lda	#<(start-1)
   4013  7fdf		       48		      pha
   4014  7fe0
   4015  7fe0				   BS_return
   4016  7fe0		       48		      pha
   4017  7fe1		       8a		      txa
   4018  7fe2		       48		      pha
   4019  7fe3		       ba		      tsx
   4020  7fe4
   4021  7fe4					      if	bankswitch != 64
   4022  7fe4		       b5 04		      lda	4,x	; get high byte of return address
   4023  7fe6
   4024  7fe6		       2a		      rol
   4025  7fe7		       2a		      rol
   4026  7fe8		       2a		      rol
   4027  7fe9		       2a		      rol
   4028  7fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4029  7fec		       aa		      tax
   4030  7fed		       e8		      inx
   4031  7fee				  -	      else
   4032  7fee				  -	      lda	4,x	; get high byte of return address
   4033  7fee				  -	      tay
   4034  7fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4035  7fee				  -	      sta	4,x
   4036  7fee				  -	      tya
   4037  7fee				  -	      lsr
   4038  7fee				  -	      lsr
   4039  7fee				  -	      lsr
   4040  7fee				  -	      lsr
   4041  7fee				  -	      tax
   4042  7fee				  -	      inx
   4043  7fee					      endif
   4044  7fee
   4045  7fee				   BS_jsr
   4046  7fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4047  7ff1		       68		      pla
   4048  7ff2		       aa		      tax
   4049  7ff3		       68		      pla
   4050  7ff4		       60		      rts
   4051  7ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4052  7ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4053  7ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4054  7ff5					      endif
   4055  7ff5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4056  7ff5
   4057  8000					      org	$8000
   4058  8000					      rorg	$1000
   4059  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4060  8000
   4061  8000							; 1K Frequency Table.
   4062  8000							; Fred Quimby, Darrell Spice Jr, Chris Walton 2010
   4063  8000							;
   4064  8000							; The 1K Frequency Table can contain up to 256 frequency values
   4065  8000							;
   4066  8000							; Table entries are defined as 2^32*freq/20000
   4067  8000							;
   4068  8000							; If User ARM code is being used, then the last 512 bytes of the frequency
   4069  8000							; table will no longer be available, reducing the number of frequencies you can
   4070  8000							; use to 128.
   4071  8000
   4072  8000							; piano key frequencies (s = sharp)
   4073  8000
   4074  8000				   .freq_table_start
   4075  8000
   4076  8000		       00 00 00 00	      DC.L	0
   4077  8000		       00 01	   A0	      =	(* & $3ff)/4
   4078  8004		       ac 1c 5a 00	      DC.L	5905580
   4079  8008
   4080  8008		       00 02	   A0s	      =	(* & $3ff)/4
   4081  8008		       68 78 5f 00	      DC.L	6256744
   4082  800c
   4083  800c		       00 03	   B0	      =	(* & $3ff)/4
   4084  800c		       b5 25 65 00	      DC.L	6628789
   4085  8010
   4086  8010		       00 04	   C1	      =	(* & $3ff)/4
   4087  8010		       6e 29 6b 00	      DC.L	7022958
   4088  8014
   4089  8014		       00 05	   C1s	      =	(* & $3ff)/4
   4090  8014		       b5 88 71 00	      DC.L	7440565
   4091  8018
   4092  8018		       00 06	   D1	      =	(* & $3ff)/4
   4093  8018		       fc 48 78 00	      DC.L	7883004
   4094  801c
   4095  801c		       00 07	   D1s	      =	(* & $3ff)/4
   4096  801c		       07 70 7f 00	      DC.L	8351751
   4097  8020
   4098  8020		       00 08	   E1	      =	(* & $3ff)/4
   4099  8020		       f4 03 87 00	      DC.L	8848372
   4100  8024
   4101  8024		       00 09	   F1	      =	(* & $3ff)/4
   4102  8024		       3c 0b 8f 00	      DC.L	9374524
   4103  8028
   4104  8028		       00 0a	   F1s	      =	(* & $3ff)/4
   4105  8028		       ba 8c 97 00	      DC.L	9931962
   4106  802c
   4107  802c		       00 0b	   G1	      =	(* & $3ff)/4
   4108  802c		       b3 8f a0 00	      DC.L	10522547
   4109  8030
   4110  8030		       00 0c	   G1s	      =	(* & $3ff)/4
   4111  8030		       db 1b aa 00	      DC.L	11148251
   4112  8034
   4113  8034		       00 0d	   A1	      =	(* & $3ff)/4
   4114  8034		       58 39 b4 00	      DC.L	11811160
   4115  8038
   4116  8038		       00 0e	   A1s	      =	(* & $3ff)/4
   4117  8038		       d0 f0 be 00	      DC.L	12513488
   4118  803c
   4119  803c		       00 0f	   B1	      =	(* & $3ff)/4
   4120  803c		       6b 4b ca 00	      DC.L	13257579
   4121  8040
   4122  8040		       00 10	   C2	      =	(* & $3ff)/4
   4123  8040		       dc 52 d6 00	      DC.L	14045916
   4124  8044
   4125  8044		       00 11	   C2s	      =	(* & $3ff)/4
   4126  8044		       69 11 e3 00	      DC.L	14881129
   4127  8048
   4128  8048		       00 12	   D2	      =	(* & $3ff)/4
   4129  8048		       f7 91 f0 00	      DC.L	15766007
   4130  804c
   4131  804c		       00 13	   D2s	      =	(* & $3ff)/4
   4132  804c		       0f e0 fe 00	      DC.L	16703503
   4133  8050
   4134  8050		       00 14	   E2	      =	(* & $3ff)/4
   4135  8050		       e9 07 0e 01	      DC.L	17696745
   4136  8054
   4137  8054		       00 15	   F2	      =	(* & $3ff)/4
   4138  8054		       78 16 1e 01	      DC.L	18749048
   4139  8058
   4140  8058		       00 16	   F2s	      =	(* & $3ff)/4
   4141  8058		       74 19 2f 01	      DC.L	19863924
   4142  805c
   4143  805c		       00 17	   G2	      =	(* & $3ff)/4
   4144  805c		       67 1f 41 01	      DC.L	21045095
   4145  8060
   4146  8060		       00 18	   G2s	      =	(* & $3ff)/4
   4147  8060		       b5 37 54 01	      DC.L	22296501
   4148  8064
   4149  8064		       00 19	   A2	      =	(* & $3ff)/4
   4150  8064		       b0 72 68 01	      DC.L	23622320
   4151  8068
   4152  8068		       00 1a	   A2s	      =	(* & $3ff)/4
   4153  8068		       a0 e1 7d 01	      DC.L	25026976
   4154  806c
   4155  806c		       00 1b	   B2	      =	(* & $3ff)/4
   4156  806c		       d6 96 94 01	      DC.L	26515158
   4157  8070
   4158  8070		       00 1c	   C3	      =	(* & $3ff)/4
   4159  8070		       b7 a5 ac 01	      DC.L	28091831
   4160  8074
   4161  8074		       00 1d	   C3s	      =	(* & $3ff)/4
   4162  8074		       d2 22 c6 01	      DC.L	29762258
   4163  8078
   4164  8078		       00 1e	   D3	      =	(* & $3ff)/4
   4165  8078		       ee 23 e1 01	      DC.L	31532014
   4166  807c
   4167  807c		       00 1f	   D3s	      =	(* & $3ff)/4
   4168  807c		       1d c0 fd 01	      DC.L	33407005
   4169  8080
   4170  8080		       00 20	   E3	      =	(* & $3ff)/4
   4171  8080		       d1 0f 1c 02	      DC.L	35393489
   4172  8084
   4173  8084		       00 21	   F3	      =	(* & $3ff)/4
   4174  8084		       f0 2c 3c 02	      DC.L	37498096
   4175  8088
   4176  8088		       00 22	   F3s	      =	(* & $3ff)/4
   4177  8088		       e9 32 5e 02	      DC.L	39727849
   4178  808c
   4179  808c		       00 23	   G3	      =	(* & $3ff)/4
   4180  808c		       cd 3e 82 02	      DC.L	42090189
   4181  8090
   4182  8090		       00 24	   G3s	      =	(* & $3ff)/4
   4183  8090		       6a 6f a8 02	      DC.L	44593002
   4184  8094
   4185  8094		       00 25	   A3	      =	(* & $3ff)/4
   4186  8094		       60 e5 d0 02	      DC.L	47244640
   4187  8098
   4188  8098		       00 26	   A3s	      =	(* & $3ff)/4
   4189  8098		       41 c3 fb 02	      DC.L	50053953
   4190  809c
   4191  809c		       00 27	   B3	      =	(* & $3ff)/4
   4192  809c		       ac 2d 29 03	      DC.L	53030316
   4193  80a0
   4194  80a0		       00 28	   C4	      =	(* & $3ff)/4
   4195  80a0		       6e 4b 59 03	      DC.L	56183662
   4196  80a4
   4197  80a4		       00 29	   C4s	      =	(* & $3ff)/4
   4198  80a4		       a5 45 8c 03	      DC.L	59524517
   4199  80a8
   4200  80a8		       00 2a	   D4	      =	(* & $3ff)/4
   4201  80a8		       dd 47 c2 03	      DC.L	63064029
   4202  80ac
   4203  80ac		       00 2b	   D4s	      =	(* & $3ff)/4
   4204  80ac		       3b 80 fb 03	      DC.L	66814011
   4205  80b0
   4206  80b0		       00 2c	   E4	      =	(* & $3ff)/4
   4207  80b0		       a3 1f 38 04	      DC.L	70786979
   4208  80b4
   4209  80b4		       00 2d	   F4	      =	(* & $3ff)/4
   4210  80b4		       e0 59 78 04	      DC.L	74996192
   4211  80b8
   4212  80b8		       00 2e	   F4s	      =	(* & $3ff)/4
   4213  80b8		       d1 65 bc 04	      DC.L	79455697
   4214  80bc
   4215  80bc		       00 2f	   G4	      =	(* & $3ff)/4
   4216  80bc		       9b 7d 04 05	      DC.L	84180379
   4217  80c0
   4218  80c0		       00 30	   G4s	      =	(* & $3ff)/4
   4219  80c0		       d5 de 50 05	      DC.L	89186005
   4220  80c4
   4221  80c4		       00 31	   A4	      =	(* & $3ff)/4
   4222  80c4		       c1 ca a1 05	      DC.L	94489281
   4223  80c8
   4224  80c8		       00 32	   A4s	      =	(* & $3ff)/4
   4225  80c8		       82 86 f7 05	      DC.L	100107906
   4226  80cc
   4227  80cc		       00 33	   B4	      =	(* & $3ff)/4
   4228  80cc		       57 5b 52 06	      DC.L	106060631
   4229  80d0
   4230  80d0		       00 34	   C5	      =	(* & $3ff)/4
   4231  80d0		       dd 96 b2 06	      DC.L	112367325
   4232  80d4
   4233  80d4		       00 35	   C5s	      =	(* & $3ff)/4
   4234  80d4		       4a 8b 18 07	      DC.L	119049034
   4235  80d8
   4236  80d8		       00 36	   D5	      =	(* & $3ff)/4
   4237  80d8		       b9 8f 84 07	      DC.L	126128057
   4238  80dc
   4239  80dc		       00 37	   D5s	      =	(* & $3ff)/4
   4240  80dc		       76 00 f7 07	      DC.L	133628022
   4241  80e0
   4242  80e0		       00 38	   E5	      =	(* & $3ff)/4
   4243  80e0		       46 3f 70 08	      DC.L	141573958
   4244  80e4
   4245  80e4		       00 39	   F5	      =	(* & $3ff)/4
   4246  80e4		       bf b3 f0 08	      DC.L	149992383
   4247  80e8
   4248  80e8		       00 3a	   F5s	      =	(* & $3ff)/4
   4249  80e8		       a3 cb 78 09	      DC.L	158911395
   4250  80ec
   4251  80ec		       00 3b	   G5	      =	(* & $3ff)/4
   4252  80ec		       36 fb 08 0a	      DC.L	168360758
   4253  80f0
   4254  80f0		       00 3c	   G5s	      =	(* & $3ff)/4
   4255  80f0		       a9 bd a1 0a	      DC.L	178372009
   4256  80f4
   4257  80f4		       00 3d	   A5	      =	(* & $3ff)/4
   4258  80f4		       81 95 43 0b	      DC.L	188978561
   4259  80f8
   4260  80f8		       00 3e	   A5s	      =	(* & $3ff)/4
   4261  80f8		       03 0d ef 0b	      DC.L	200215811
   4262  80fc
   4263  80fc		       00 3f	   B5	      =	(* & $3ff)/4
   4264  80fc		       af b6 a4 0c	      DC.L	212121263
   4265  8100
   4266  8100		       00 40	   C6	      =	(* & $3ff)/4
   4267  8100		       b9 2d 65 0d	      DC.L	224734649
   4268  8104
   4269  8104		       00 41	   C6s	      =	(* & $3ff)/4
   4270  8104		       93 16 31 0e	      DC.L	238098067
   4271  8108
   4272  8108		       00 42	   D6	      =	(* & $3ff)/4
   4273  8108		       73 1f 09 0f	      DC.L	252256115
   4274  810c
   4275  810c		       00 43	   D6s	      =	(* & $3ff)/4
   4276  810c		       ec 00 ee 0f	      DC.L	267256044
   4277  8110
   4278  8110		       00 44	   E6	      =	(* & $3ff)/4
   4279  8110		       8b 7e e0 10	      DC.L	283147915
   4280  8114
   4281  8114		       00 45	   F6	      =	(* & $3ff)/4
   4282  8114		       7f 67 e1 11	      DC.L	299984767
   4283  8118
   4284  8118		       00 46	   F6s	      =	(* & $3ff)/4
   4285  8118		       45 97 f1 12	      DC.L	317822789
   4286  811c
   4287  811c		       00 47	   G6	      =	(* & $3ff)/4
   4288  811c		       6c f6 11 14	      DC.L	336721516
   4289  8120
   4290  8120		       00 48	   G6s	      =	(* & $3ff)/4
   4291  8120		       53 7b 43 15	      DC.L	356744019
   4292  8124
   4293  8124		       00 49	   A6	      =	(* & $3ff)/4
   4294  8124		       02 2b 87 16	      DC.L	377957122
   4295  8128
   4296  8128		       00 4a	   A6s	      =	(* & $3ff)/4
   4297  8128		       06 1a de 17	      DC.L	400431622
   4298  812c
   4299  812c		       00 4b	   B6	      =	(* & $3ff)/4
   4300  812c		       5d 6d 49 19	      DC.L	424242525
   4301  8130
   4302  8130		       00 4c	   C7	      =	(* & $3ff)/4
   4303  8130		       73 5b ca 1a	      DC.L	449469299
   4304  8134
   4305  8134		       00 4d	   C7s	      =	(* & $3ff)/4
   4306  8134		       26 2d 62 1c	      DC.L	476196134
   4307  8138
   4308  8138		       00 4e	   D7	      =	(* & $3ff)/4
   4309  8138		       e6 3e 12 1e	      DC.L	504512230
   4310  813c
   4311  813c		       00 4f	   D7s	      =	(* & $3ff)/4
   4312  813c		       d8 01 dc 1f	      DC.L	534512088
   4313  8140
   4314  8140		       00 50	   E7	      =	(* & $3ff)/4
   4315  8140		       17 fd c0 21	      DC.L	566295831
   4316  8144
   4317  8144		       00 51	   F7	      =	(* & $3ff)/4
   4318  8144		       fd ce c2 23	      DC.L	599969533
   4319  8148
   4320  8148		       00 52	   F7s	      =	(* & $3ff)/4
   4321  8148		       8a 2e e3 25	      DC.L	635645578
   4322  814c
   4323  814c		       00 53	   G7	      =	(* & $3ff)/4
   4324  814c		       d7 ec 23 28	      DC.L	673443031
   4325  8150
   4326  8150		       00 54	   G7s	      =	(* & $3ff)/4
   4327  8150		       a6 f6 86 2a	      DC.L	713488038
   4328  8154
   4329  8154		       00 55	   A7	      =	(* & $3ff)/4
   4330  8154		       04 56 0e 2d	      DC.L	755914244
   4331  8158
   4332  8158		       00 56	   A7s	      =	(* & $3ff)/4
   4333  8158		       0c 34 bc 2f	      DC.L	800863244
   4334  815c
   4335  815c		       00 57	   B7	      =	(* & $3ff)/4
   4336  815c		       bb da 92 32	      DC.L	848485051
   4337  8160
   4338  8160		       00 58	   C8	      =	(* & $3ff)/4
   4339  8160		       e5 b6 94 35	      DC.L	898938597
   4340  8164
   4341  8164							;values for 89-255 may go here 
   4342  8164
   4343  8164					      if	(* <= $1400)
   4344  8164		       00 00 00 00*	      ds	($1400-*)	; pad out remaining space in frequency table
   4345  8400				  -	      else
   4346  8400				  -	      echo	"FATAL ERROR - Frequency table exceeds 1K"
   4347  8400				  -	      err
   4348  8400					      endif
